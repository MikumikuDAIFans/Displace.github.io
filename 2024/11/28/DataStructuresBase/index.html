<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="Hexo Theme Redefine">
    
    <meta name="author" content="Displace">
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://mikumikudaifans.github.io/2024/11/28/datastructuresbase/"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:type" content="article">
<meta property="og:title" content="Data_structures_BaseDataType">
<meta property="og:url" content="https://mikumikudaifans.github.io/2024/11/28/DataStructuresBase/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://mikumikudaifans.github.io/Displace.github.io/images/redefine-og.webp">
<meta property="article:published_time" content="2024-11-27T16:00:00.000Z">
<meta property="article:modified_time" content="2025-04-15T09:02:51.213Z">
<meta property="article:author" content="Dispalce">
<meta property="article:tag" content="Note">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://mikumikudaifans.github.io/Displace.github.io/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/Displace.github.io/images/Logo_miku.png" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/Displace.github.io/images/Logo_miku.png">
    <meta name="theme-color" content="#33cccc">
    <link rel="shortcut icon" href="/Displace.github.io/images/Logo_miku.png">
    <!--- Page Info-->
    
    <title>
        
            Data_structures_BaseDataType | DisplaceStation
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
        <link href="https://fonts.googleapis.com/css2?family=Signika+Negative:wght@450..700&display=swap" rel="stylesheet">
    
    
    
        <link href="https://fonts.googleapis.com/css2?family=Signika+Negative:wght@300..700&family=Sour+Gummy:ital,wght@0,100..900;1,100..900&display=swa" rel="stylesheet">
    
    
        <link href="" rel="stylesheet">
    
    
        
<script src="/js/build/libs/anime.min.js"></script>

    

    <script id="hexo-configurations">
    window.config = {"hostname":"mikumikudaifans.github.io","root":"/","language":"en","path":"search.xml"};
    window.theme = {"articles":{"style":{"font_size":"20px","line_height":1.5,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":true,"list":["Lv1","Lv2","Lv3","Lv114514"]},"code_block":{"copy":true,"style":"simple","highlight_theme":{"light":"github","dark":"github"},"font":{"enable":true,"family":"Signika Negative","url":"https://fonts.googleapis.com/css2?family=Signika+Negative:wght@450..700&display=swap"}},"toc":{"enable":true,"max_depth":4,"number":true,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#33cccc","secondary":null,"default_mode":"dark"},"global":{"fonts":{"chinese":{"enable":false,"family":"Sour Gummy","url":"https://fonts.googleapis.com/css2?family=Signika+Negative:wght@300..700&family=Sour+Gummy:ital,wght@0,100..900;1,100..900&display=swa"},"english":{"enable":true,"family":"Sour Gummy","url":"https://fonts.googleapis.com/css2?family=Signika+Negative:wght@300..700&family=Sour+Gummy:ital,wght@0,100..900;1,100..900&display=swa"},"title":{"enable":true,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":true,"custom_message":null},"open_graph":{"enable":true,"image":"/Displace.github.io/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":10266068431}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/Displace.github.io/images/walllight.jpg","dark":"/Displace.github.io/images/walldark.jpg"},"title":"DisplaceStation_ZjY","subtitle":{"text":["何日才能抵达呢？","日复一日，必有精进","虽不能至，心向往之","路漫漫其修远兮，吾将上下而求索"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#33ccc","dark":"#d1d1b6"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":"Noto Sans SC","url":"https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap"},"social_links":{"enable":true,"style":"center","links":{"github":"https://github.com/MikumikuDAIFans","instagram":null,"zhihu":null,"twitter":"https://x.com/NRcJOqSVzVjuSdv","email":"zhangjiayanglovemiku@gmail.com","bilibili":"https://space.bilibili.com/11958169?spm_id_from=333.1007.0.0"},"qrs":{"weixin":"/Displace.github.io/images/socialQRS/weixin.jpg","qq":"/Displace.github.io/images/socialQRS/QQ.jpg"}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":true,"type":"fixed","audios":[{"name":"Never Coming Back","artist":"Evan Call","url":"/Displace.github.io/images/music/Evan Call - Never Coming Back.flac","cover":"/Displace.github.io/images/music/Evan Call - Never Coming Back.webp","lrc":"/Displace.github.io/images/music/Evan Call - Never Coming Back.webp"},{"name":"使一颗心免于哀伤","artist":"知更鸟&HOYO-MiX&Chevy","url":"/Displace.github.io/images/music/IfICanStopOneHeartFromBreaking.flac","cover":"/Displace.github.io/images/music/HoyomixCover.png","lrc":"/Displace.github.io/images/music/HoyomixCover.png"},{"name":"Time Flows Ever Onward","artist":"Evan Call","url":"/Displace.github.io/images/music/Evan Call - Time Flows Ever Onward.ogg","cover":"/Displace.github.io/images/music/Evan Call - Time Flows Ever Onward.webp","lrc":"/Displace.github.io/images/music/Evan Call - Time Flows Ever Onward.webp"},{"name":"Merry-Go-Round","artist":"石九让","url":"/Displace.github.io/images/music/Merry-Go-Round.flac","cover":"/Displace.github.io/images/music/Merry-Go-RoundCover.webp","lrc":"/Displace.github.io/images/music/Merry-Go-RoundCover.webp"}]},"mermaid":{"enable":false,"version":"11.4.1"}},"version":"2.8.2","navbar":{"auto_hide":true,"color":{"left":"#f78736","right":"#367df7","transparency":15},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-duotone fa-house"},"Archives":{"path":"/archives","icon":"fa-duotone fa-archive"},"Bookmarks":{"icon":"fa-solid fa-bookmark","path":"/bookmarks/"},"Friends":{"icon":"fa-duotone fa-link","path":"/links/"}},"search":{"enable":true,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":"Welcome to my website, where I update my daily work and learning experiences","show_on_mobile":true,"links":{"Photos":{"path":"/masonry","icon":"fa-duotone fa-image"}}},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2022/8/17 11:45:14"};
    window.lang_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
    window.data = {"masonry":true};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
        
<link rel="stylesheet" href="/fontawesome/duotone.min.css">

    
    
        
<link rel="stylesheet" href="/fontawesome/sharp-solid.min.css">

    
<meta name="generator" content="Hexo 7.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<style>
    :root {
        --preloader-background-color: #fff;
        --preloader-text-color: #000;
    }

    @media (prefers-color-scheme: dark) {
        :root {
            --preloader-background-color: #202124;
            --preloader-text-color: #fff;
        }
    }

    @media (prefers-color-scheme: light) {
        :root {
            --preloader-background-color: #fff;
            --preloader-text-color: #000;
        }
    }

    @media (max-width: 600px) {
        .ml13 {
            font-size: 2.6rem !important; /* Adjust this value as needed */
        }
    }

    .preloader {
        display: flex;
        flex-direction: column;
        gap: 1rem; /* Tailwind 'gap-4' is 1rem */
        align-items: center;
        justify-content: center;
        position: fixed;
        padding: 12px;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
        width: 100vw;
        height: 100vh; /* 'h-screen' is 100% of the viewport height */
        background-color: var(--preloader-background-color);
        z-index: 1100; /* 'z-[1100]' sets the z-index */
        transition: opacity 0.2s ease-in-out;
    }

    .ml13 {
        font-size: 3.2rem;
        /* text-transform: uppercase; */
        color: var(--preloader-text-color);
        letter-spacing: -1px;
        font-weight: 500;
        font-family: 'Chillax-Variable', sans-serif;
        text-align: center;
    }

    .ml13 .word {
        display: inline-flex;
        flex-wrap: wrap;
        white-space: nowrap;
    }

    .ml13 .letter {
        display: inline-block;
        line-height: 1em;
    }
</style>

<div class="preloader">
    <h2 class="ml13">
        DisplaceStation
    </h2>
    <script>
        var textWrapper = document.querySelector('.ml13');
        // Split text into words
        var words = textWrapper.textContent.trim().split(' ');

        // Clear the existing content
        textWrapper.innerHTML = '';

        // Wrap each word and its letters in spans
        words.forEach(function(word) {
            var wordSpan = document.createElement('span');
            wordSpan.classList.add('word');
            wordSpan.innerHTML = word.replace(/\S/g, "<span class='letter'>$&</span>");
            textWrapper.appendChild(wordSpan);
            textWrapper.appendChild(document.createTextNode(' ')); // Add space between words
        });

        var animation = anime.timeline({ loop: true })
            .add({
                targets: '.ml13 .letter',
                translateY: [20, 0],
                translateZ: 0,
                opacity: [0, 1],
                filter: ['blur(5px)', 'blur(0px)'],
                easing: "easeOutExpo",
                duration: 1200,
                delay: (el, i) => 300 + 20 * i,
            })
            .add({
                targets: '.ml13 .letter',
                translateY: [0, -20],
                opacity: [1, 0],
                filter: ['blur(0px)', 'blur(5px)'],
                easing: "easeInExpo",
                duration: 1000,
                delay: (el, i) => 15 * i,
                complete: function() {
                    hidePreloader();
                }
            }, '-=700');


        let themeStatus = JSON.parse(localStorage.getItem('REDEFINE-THEME-STATUS'))?.isDark;

        // If the theme status is not found in local storage, check the preferred color scheme
        if (themeStatus === undefined || themeStatus === null) {
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                themeStatus = 'dark';
            } else {
                themeStatus = 'light';
            }
        }

        // Now you can use the themeStatus variable in your code
        if (themeStatus) {
            document.documentElement.style.setProperty('--preloader-background-color', '#202124');
            document.documentElement.style.setProperty('--preloader-text-color', '#fff');
        } else {
            document.documentElement.style.setProperty('--preloader-background-color', '#fff');
            document.documentElement.style.setProperty('--preloader-text-color', '#000');
        }

        window.addEventListener('load', function () {
            setTimeout(hidePreloader, 5000); // Call hidePreloader after 5000 milliseconds if not already called by animation
        });

        function hidePreloader() {
            var preloader = document.querySelector('.preloader');
            preloader.style.opacity = '0';
            setTimeout(function () {
                preloader.style.display = 'none';
            }, 200);
        }
    </script>
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
                <a class="logo-image h-8 w-8 sm:w-10 sm:h-10 mr-3" href="/">
                    <img src="/Displace.github.io/images/Logo_miku.png" class="w-full h-full rounded-sm">
                </a>
            
            <a class="logo-title" href="/">
                
                DisplaceStation
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-duotone fa-house fa-fw"></i>
                                    HOME
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-duotone fa-archive fa-fw"></i>
                                    ARCHIVES
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/bookmarks/"
                                        >
                                    <i class="fa-solid fa-bookmark fa-fw"></i>
                                    BOOKMARKS
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/links/"
                                        >
                                    <i class="fa-duotone fa-link fa-fw"></i>
                                    FRIENDS
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                        <li class="navbar-item search search-popup-trigger">
                            <i class="fa-solid fa-magnifying-glass"></i>
                        </li>
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fa-solid fa-magnifying-glass"></i>
                    </div>
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                HOME
                            </span>
                            
                                <i class="fa-duotone fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                ARCHIVES
                            </span>
                            
                                <i class="fa-duotone fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/bookmarks/"
                        >
                            <span>
                                BOOKMARKS
                            </span>
                            
                                <i class="fa-solid fa-bookmark fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/links/"
                        >
                            <span>
                                FRIENDS
                            </span>
                            
                                <i class="fa-duotone fa-link fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
                
                    
                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full active"
                           href="/masonry"
                        >
                            <span>Photos</span>
                            <i class="fa-duotone fa-image fa-sm fa-fw"></i>
                        </a>
                    </li>
                
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">3</div>
        <div class="label text-third-text-color text-sm">Tags</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">8</div>
        <div class="label text-third-text-color text-sm">Categories</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">10</div>
        <div class="label text-third-text-color text-sm">Posts</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="post-page-container flex relative justify-between box-border w-full h-full">
	<div class="article-content-container">

		<div class="article-title relative w-full">
			
			
			
			<img src="/images/DataStructures/cat_selfphoto.png" alt="Data_structures_BaseDataType" class="w-full h-60 sm:h-72 md:h-80 object-cover sm:rounded-t-large dark:brightness-75" />
			
			<div class="w-full flex items-center absolute bottom-0 justify-start">
				<h1 class="article-title-cover text-center mx-6 my-6 text-second-text-color bg-background-color-transparent px-4 py-3 text-3xl sm:text-4xl md:text-5xl font-semibold backdrop-blur-lg rounded-xl border border-border-color ">Data_structures_BaseDataType</h1>
			</div>
			
		</div>

		
		<div class="article-header flex flex-row gap-2 items-center px-2 sm:px-6 md:px-8">
			<div class="avatar w-[46px] h-[46px] flex-shrink-0 rounded-medium border border-border-color p-[1px]">
				<img src="/Displace.github.io/images/Logo_miku.png">
			</div>
			<div class="info flex flex-col justify-between">
				<div class="author flex items-center">
					<span class="name text-default-text-color text-lg font-semibold">Displace</span>
					
					<span class="author-label ml-1.5 text-xs px-2 py-0.5 rounded-small text-third-text-color border border-shadow-color-1">Lv2</span>
					
				</div>
				<div class="meta-info">
					<div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fa-regular fa-pen-fancy"></i>&nbsp;
        <span class="desktop">2024-11-28</span>
        <span class="mobile">2024-11-28</span>
        <span class="hover-info">Created</span>
    </span>
    
        <span class="article-date article-meta-item">
            <i class="fa-regular fa-wrench"></i>&nbsp;
            <span class="desktop">2025-04-15 17:02:51</span>
            <span class="mobile">2025-04-15 17:02:51</span>
            <span class="hover-info">Updated</span>
        </span>
    

    
        <span class="article-categories article-meta-item">
            <i class="fa-regular fa-folders"></i>&nbsp;
            <ul>
                
                
                    
                        
                        <li>
                            <a href="/categories/Data-structures/">Data_structures</a>&nbsp;
                        </li>
                    
                    
                
            </ul>
        </span>
    
    
        <span class="article-tags article-meta-item">
            <i class="fa-regular fa-tags"></i>&nbsp;
            <ul>
                
                    <li>
                        <a href="/tags/Note/">Note</a>&nbsp;
                    </li>
                
            </ul>
        </span>
    

    
    
        <span class="article-wordcount article-meta-item">
            <i class="fa-regular fa-typewriter"></i>&nbsp;<span>13.7k Words</span>
        </span>
    
    
        <span class="article-min2read article-meta-item">
            <i class="fa-regular fa-clock"></i>&nbsp;<span>60 Mins</span>
        </span>
    
    
        <span class="article-pv article-meta-item">
            <i class="fa-regular fa-eye"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>
        </span>
    
</div>

				</div>
			</div>
		</div>
		

		


		<div class="article-content markdown-body px-2 sm:px-6 md:px-8 pb-8">
			<p>Data_structures_BaseDataType</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/images/DataStructures/house_tech.png"></p>
<p>本文代码采用C语言编写,用到了部分Cpp语法,详见<a class="button  regular" href="https://mikumikudaifans.github.io/Displace.github.io/2024/10/14/C_Note/" title="C_NOTE"><i class="fa-solid fa-play-circle"></i> C_NOTE</a> 的Cpp引用部分</p>
<p>由于每种数据结构各种操作需要相互协同工作才能起作用,总体代码长度过长,不方便阅读,故此我决定将不同操作分开讲解,并在章节最后附上整体的代码 <del>(其实就是合到一起)</del></p>
<h2 id="时间复杂度-空间复杂度"><a href="#时间复杂度-空间复杂度" class="headerlink" title="时间复杂度&空间复杂度"></a>时间复杂度&amp;空间复杂度</h2><h3 id="时间复杂度-time-complexity"><a href="#时间复杂度-time-complexity" class="headerlink" title="时间复杂度(time complexity)"></a>时间复杂度(time complexity)</h3><p>时间复杂度是指算法执行所需时间的量度，通常以输入规模 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 的函数形式表示。它反映了算法的运行时间如何随着输入规模的增加而变化。</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：常数时间复杂度，与输入规模无关，执行时间固定。</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：线性时间复杂度，时间与输入规模成正比，如遍历数组。</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.682ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3837.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="msub" transform="translate(1935,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mi" transform="translate(2848.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3448.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：对数时间复杂度，适合分治法（如二分查找）。</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：平方时间复杂度，常见于嵌套循环</li>
</ul>
<p>通常我们观察一段代码的运行次数来判断它的时间复杂度</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">def <span class="title">example</span><span class="params">(arr)</span>:</span></span><br><span class="line"><span class="function">    for i in range(len(arr)):</span></span><br><span class="line"><span class="function">        for j in range(len(arr)):</span></span><br><span class="line"><span class="function">            print(arr[i] + arr[j])</span></span><br></pre></td></tr></table></figure></div>

<p>外层循环运行 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 次，内层循环也运行 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 次，因此时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
<h3 id="空间复杂度-space-complexity"><a href="#空间复杂度-space-complexity" class="headerlink" title="空间复杂度(space complexity)"></a>空间复杂度(space complexity)</h3><h4 id="常见情况"><a href="#常见情况" class="headerlink" title="常见情况"></a>常见情况</h4><ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：仅使用常数空间，通常为变量或指针的操作，如简单循环。</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：需要存储所有输入元素的大小空间，如线性数组。</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：需要矩阵或二维表结构的空间，如图论算法。</li>
</ul>
<h4 id="计算空间复杂度的步骤"><a href="#计算空间复杂度的步骤" class="headerlink" title="计算空间复杂度的步骤"></a>计算空间复杂度的步骤</h4><ol>
<li><strong>识别固定存储</strong>：如函数内的常量。</li>
<li><strong>计算辅助结构</strong>：例如数组、栈、队列。</li>
<li><strong>加和取上限</strong>：得到整体复杂度。</li>
</ol>
<p>高效算法应在降低时间复杂度的前提下尽量减少空间开销</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表（Linear List）是计算机科学中一种常见的数据结构，用来表示元素按顺序排列的一组数据。在线性表中，数据元素之间存在一对一的线性关系，即每个数据元素有且仅有一个直接前驱和一个直接后继（第一个和最后一个元素除外）。线性表可用于各种场景，包括队列、栈、链表等</p>
<h3 id="顺序表-Sequence-List"><a href="#顺序表-Sequence-List" class="headerlink" title="顺序表(Sequence List)"></a>顺序表(Sequence List)</h3><p>顺序表 (Sequnce List) 使用一块连续的内存空间来存储线性表的数据元素。每个元素的存储位置可以通过一个下标直接访问,其本质是一个数组。</p>
<ul>
<li><p>优点：</p>
<ul>
<li>支持快速的随机访问，可以通过下标直接访问任何位置的元素。</li>
<li>空间利用率较高，不需要额外的存储空间。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>插入和删除元素的操作效率较低，涉及大量元素的移动。</li>
<li>顺序存储的大小固定，无法动态扩展。</li>
</ul>
</li>
</ul>
<h4 id="1-顺序表的静态定义"><a href="#1-顺序表的静态定义" class="headerlink" title="1. 顺序表的静态定义 :"></a>1. 顺序表的静态定义 :</h4><p>包含一个数组 和 一个用来记录当前顺序表长度的int变量</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  <span class="comment">//将顺序表的值类型另命名，方便后续修改数据类型类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义顺序表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">	ElemType data[MaxSize]; <span class="comment">//线性表本质是一个数组,被人为的添加了逻辑顺序和排序长度</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前顺序表中有多少个元素</span></span><br><span class="line">}SqList;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="2-插入"><a href="#2-插入" class="headerlink" title="2.插入 :"></a>2.插入 :</h4><p>从插入位置开始，将后续元素依次向后移动，腾出插入位置</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在排序表第i个位置添加元素  //排序表从1开始  //索引表从0开始</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, ElemType element)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//参数归一化,方便后续操作</span></span><br><span class="line">	<span class="type">int</span> i_index = i - <span class="number">1</span>; <span class="comment">//将参数从排序表转换为索引表</span></span><br><span class="line">	<span class="type">int</span> length_index = L.length - <span class="number">1</span>; <span class="comment">//将参数从排序表长度转换为末端索引值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i_index &lt; <span class="number">0</span> || i_index &gt; length_index)  <span class="comment">//判断i是否合法,</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the position of i is illegal , change it to less than L.length\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (length_index == MaxSize)   <span class="comment">//存储空间满了则无法继续插入值</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"MaxSize cannot insert value\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	L.length++; <span class="comment">//因为要加入一个新元素,故长度加一</span></span><br><span class="line">	length_index = L.length - <span class="number">1</span>; <span class="comment">//由于L.length发生了变化,需更新length_index</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = length_index; j &gt;= i_index; j--) <span class="comment">//根据索引</span></span><br><span class="line">	{</span><br><span class="line">		L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	L.data[i_index] = element;</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除 :"></a>3.删除 :</h4><p>从删除位置开始，将后续元素向前移动</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定元素值删除首个符合条件的元素  //若想删除所有的同一元素,则只需循环调用此函数即可</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DelteElement_by_value</span><span class="params">(SqList&amp; L, ElemType element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//初始化j,否则无法作为左操作数输入将其他变量的值赋予j</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length<span class="number">-1</span>; i++)<span class="comment">//获取第一个符合目标元素值的索引值</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (element == L.data[i])</span><br><span class="line">		{</span><br><span class="line">			j = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若未找到元素，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="number">-1</span>) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Element not found.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = j; i &lt; L.length - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		L.data[i] = L.data[i + <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定排序位置删除元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DelteElement_by_position</span><span class="params">(SqList&amp; L, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//参数归一化,方便后续操作</span></span><br><span class="line">	<span class="type">int</span> i_index = i - <span class="number">1</span>; <span class="comment">//将参数从排序表转换为索引表</span></span><br><span class="line">	<span class="type">int</span> length_index = L.length - <span class="number">1</span>; <span class="comment">//将参数从排序表长度转换为末端索引值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i_index &lt; <span class="number">0</span> || i_index &gt; length_index)  <span class="comment">//判断i是否合法,</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the position of i is illegal , change it to less than L.length\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = i_index; i &lt; L.length - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		L.data[i] = L.data[i + <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="4-查找"><a href="#4-查找" class="headerlink" title="4.查找 :"></a>4.查找 :</h4><p>直接通过下标访问目标位置元素</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据值查找该值所在的首个排序位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SerchFirstPosition_by_value</span><span class="params">(SqList&amp; L, ElemType element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//初始化j,否则无法作为左操作数输入将其他变量的值赋予j</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length - <span class="number">1</span>; i++)<span class="comment">//获取第一个符合目标元素值的排序位置</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (element == L.data[i])</span><br><span class="line">		{</span><br><span class="line">			j = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若未找到元素，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="number">-1</span>) </span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Element not found.\n"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the first position of value:%d is %d\n"</span>, element,j);</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据值查找该值所在的所有排序位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SerchAllPositions_by_value</span><span class="params">(SqList&amp; L, ElemType element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//初始化j,否则无法作为左操作数输入将其他变量的值赋予j</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= L.length<span class="number">-1</span>; i++)<span class="comment">//获取第一个符合目标元素值的排序位置</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (element == L.data[i])</span><br><span class="line">		{</span><br><span class="line">			j = i + <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the position of value:%d is %d\n"</span>, element, j);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若未找到元素，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The Element of %d is not found.\n"</span>, element);</span><br><span class="line">	}	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="顺序表总体代码"><a href="#顺序表总体代码" class="headerlink" title="顺序表总体代码"></a>顺序表总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>顺序表 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  <span class="comment">//将顺序表的值类型另命名，方便后续修改数据类型类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义顺序表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">	ElemType data[MaxSize]; <span class="comment">//线性表本质是一个数组,被人为的添加了逻辑顺序和排序长度</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前顺序表中有多少个元素</span></span><br><span class="line">}SqList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在排序表第i个位置添加元素  //排序表从1开始  //索引表从0开始</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, ElemType element)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//参数归一化,方便后续操作</span></span><br><span class="line">	<span class="type">int</span> i_index = i - <span class="number">1</span>; <span class="comment">//将参数从排序表转换为索引表</span></span><br><span class="line">	<span class="type">int</span> length_index = L.length - <span class="number">1</span>; <span class="comment">//将参数从排序表长度转换为末端索引值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i_index &lt; <span class="number">0</span> || i_index &gt; length_index)  <span class="comment">//判断i是否合法,</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the position of i is illegal , change it to less than L.length\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (length_index == MaxSize)   <span class="comment">//存储空间满了则无法继续插入值</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"MaxSize cannot insert value\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	L.length++; <span class="comment">//因为要加入一个新元素,故长度加一</span></span><br><span class="line">	length_index = L.length - <span class="number">1</span>; <span class="comment">//由于L.length发生了变化,需更新length_index</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = length_index; j &gt;= i_index; j--) <span class="comment">//根据索引</span></span><br><span class="line">	{</span><br><span class="line">		L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	L.data[i_index] = element;</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定元素值删除首个符合条件的元素  //若想删除所有的同一元素,则只需循环调用此函数即可</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DelteElement_by_value</span><span class="params">(SqList&amp; L, ElemType element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//初始化j,否则无法作为左操作数输入将其他变量的值赋予j</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length<span class="number">-1</span>; i++)<span class="comment">//获取第一个符合目标元素值的索引值</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (element == L.data[i])</span><br><span class="line">		{</span><br><span class="line">			j = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若未找到元素，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="number">-1</span>) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Element not found.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = j; i &lt; L.length - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		L.data[i] = L.data[i + <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定排序位置删除元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DelteElement_by_position</span><span class="params">(SqList&amp; L, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//参数归一化,方便后续操作</span></span><br><span class="line">	<span class="type">int</span> i_index = i - <span class="number">1</span>; <span class="comment">//将参数从排序表转换为索引表</span></span><br><span class="line">	<span class="type">int</span> length_index = L.length - <span class="number">1</span>; <span class="comment">//将参数从排序表长度转换为末端索引值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i_index &lt; <span class="number">0</span> || i_index &gt; length_index)  <span class="comment">//判断i是否合法,</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the position of i is illegal , change it to less than L.length\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = i_index; i &lt; L.length - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		L.data[i] = L.data[i + <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据值查找该值所在的首个排序位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SerchFirstPosition_by_value</span><span class="params">(SqList&amp; L, ElemType element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//初始化j,否则无法作为左操作数输入将其他变量的值赋予j</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length - <span class="number">1</span>; i++)<span class="comment">//获取第一个符合目标元素值的排序位置</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (element == L.data[i])</span><br><span class="line">		{</span><br><span class="line">			j = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若未找到元素，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="number">-1</span>) </span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Element not found.\n"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the first position of value:%d is %d\n"</span>, element,j);</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据值查找该值所在的所有排序位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SerchAllPositions_by_value</span><span class="params">(SqList&amp; L, ElemType element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//初始化j,否则无法作为左操作数输入将其他变量的值赋予j</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= L.length<span class="number">-1</span>; i++)<span class="comment">//获取第一个符合目标元素值的排序位置</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (element == L.data[i])</span><br><span class="line">		{</span><br><span class="line">			j = i + <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the position of value:%d is %d\n"</span>, element, j);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若未找到元素，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The Element of %d is not found.\n"</span>, element);</span><br><span class="line">	}	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印列表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%3d"</span>, L.data[i]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n-------length=%d---------\n"</span>, L.length);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SqList L;</span><br><span class="line">	L.data[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//向顺序表中添加数值</span></span><br><span class="line">	L.data[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">	L.data[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	L.data[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">	L.data[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">	L.data[<span class="number">5</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	L.length = <span class="number">6</span>; <span class="comment">//设置长度</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">PrintList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ListInsert(L, 3, 99);</span></span><br><span class="line">	<span class="comment">//PrintList(L);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//ListInsert(L, 7, 90);</span></span><br><span class="line">	<span class="comment">//PrintList(L);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//DelteElement_by_value(L,7);</span></span><br><span class="line">	<span class="comment">//PrintList(L);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//DelteElement_by_position(L, 4);</span></span><br><span class="line">	<span class="comment">//PrintList(L);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//SerchFirstPosition_by_value(L, 7);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">SerchAllPositions_by_value</span>(L, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>



<hr>
<h3 id="单链表-Single-Linked-List"><a href="#单链表-Single-Linked-List" class="headerlink" title="单链表(Single Linked List)"></a>单链表(Single Linked List)</h3><p>单链表是一种链式数据结构，用于存储一组节点。每个节点包含数据域和指针域，其中：</p>
<ol>
<li><strong>数据域（Data Field）</strong>：存储节点的数据。</li>
<li><strong>指针域（Next Field）</strong>：存储指向下一个节点的指针。</li>
</ol>
<p><del><strong>注意</strong>,这里构造的单链表头节点内无值,但因visual studio2022会自动在输出时为空的值域填充随机值,故用我们这里NULL即0填充,在实际使用链表时头节点会被填充数据,写入链表长度或其他数值信息</del></p>
<p>我改主意了,头节点数据填入链表长度</p>
<p>在链表中,节点的概念是逻辑性的虚拟的,实际代码层面只存在<strong>包含于构造体中的指针和数据</strong></p>
<h4 id="1-创建单链表"><a href="#1-创建单链表" class="headerlink" title="1.创建单链表"></a>1.创建单链表</h4><p>包含数据域 和 指针域,指针用于指向下一个结构体(节点)</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>{</span><br><span class="line">	ElementType data;  <span class="comment">//数据域</span></span><br><span class="line">	LNode* next;  <span class="comment">//指向结构体LNode的指针  </span></span><br><span class="line">}LNode,*LinkList;   <span class="comment">//定义链表的名字和头指针  //*LinkList表示LinkList是一个指针变量，指向结构体LNode的首地址</span></span><br><span class="line"><span class="comment">//LNode* 和 LinkList 都可以表示结构体LNode的首地址</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-头插法添加节点"><a href="#2-头插法添加节点" class="headerlink" title="2.头插法添加节点"></a>2.头插法添加节点</h4><p><img lazyload="" src="/images/loading.svg" data-src="/images/DataStructures/head_insert.png"></p>
<p>头插法是一种在链表头部插入节点的方式，适用于倒序建立链表。步骤如下：</p>
<ol>
<li>为新节点分配内存。</li>
<li>设置新节点的数据值。</li>
<li>将新节点的 <code>next</code> 指针指向当前的头节点。</li>
<li>更新头指针，使其指向新节点。</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//头插法，将新结点插入到链表的头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_head_insert</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LNode* s; <span class="comment">//定义一个指针变量s，指向新结点</span></span><br><span class="line">	ElementType x = <span class="number">0</span>; <span class="comment">//定义一个变量x，用于输入数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建头结点</span></span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给链表的头结点,malloc申请内存后返回首地址给到L,则L为结构体LNode的首地址(即头指针)</span></span><br><span class="line">	L-&gt;data = x;  <span class="comment">//头结点的data域置0</span></span><br><span class="line">	L-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//头插法，将新结点插入到链表的头部</span></span><br><span class="line">	<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//首次输入数据</span></span><br><span class="line">	<span class="keyword">while</span>(x != <span class="number">9999</span>) </span><br><span class="line">	{</span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给新结点		</span></span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		s-&gt;next = L-&gt;next; <span class="comment">//新结点的指针域指向旧头结点</span></span><br><span class="line">		L-&gt;next = s; <span class="comment">//将头结点的指针域指向新结点</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//再次输入数据,直到输入9999结束</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkList L; <span class="comment">//定义链表的头指针.L为结构体类型的指针变量，指向结构体LNode的头节点地址</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="3-尾插法添加节点"><a href="#3-尾插法添加节点" class="headerlink" title="3.尾插法添加节点"></a>3.尾插法添加节点</h4><p><img lazyload="" src="/images/loading.svg" data-src="/images/DataStructures/tail_insert.png"></p>
<p>尾插法是将新节点添加到链表尾部，适用于顺序建立链表。步骤如下：</p>
<ol>
<li>为新节点分配内存。</li>
<li>设置新节点的数据值。</li>
<li>将当前尾节点的 <code>next</code> 指针指向新节点。</li>
<li>更新尾节点，使其指向新节点</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尾插法，将新结点插入到链表的尾部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_tail_insert</span><span class="params">(LinkList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LNode* s,*r; <span class="comment">//定义一个指针变量s，指向新结点</span></span><br><span class="line">	ElementType x = <span class="number">0</span>; <span class="comment">//定义一个变量x，用于输入数据</span></span><br><span class="line">	<span class="comment">//创建头结点</span></span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给链表的头结点,malloc申请内存后返回首地址给到L,则L为结构体LNode的首地址(即头指针)</span></span><br><span class="line">	L-&gt;data = x;  <span class="comment">//头结点的data域置0</span></span><br><span class="line">	L-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	r = L; <span class="comment">//r指向头结点</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    <span class="comment">//尾插法，将新结点插入到链表的尾部</span></span><br><span class="line">	<span class="keyword">while</span>(x != <span class="number">9999</span>)</span><br><span class="line">	{ </span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		r-&gt;next =s; <span class="comment">//将r的指针域指向新结点,在第一次循环时,相当于让L的指针域指向新结点,以为上文定义了*r =L</span></span><br><span class="line">		r = s; <span class="comment">//r指向新结点</span></span><br><span class="line">		<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//输入数据</span></span><br><span class="line">	}</span><br><span class="line">	r-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//最后一个结点的指针域置空</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkList L; <span class="comment">//定义链表的头指针.L为结构体类型的指针变量，指向结构体LNode的头节点地址</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="5-单链表查询"><a href="#5-单链表查询" class="headerlink" title="5.单链表查询"></a>5.单链表查询</h4><ol>
<li>定义计数器变量</li>
<li>考虑非法参数并给出返回值</li>
<li>用while循环从头节点开始遍历链表,由计数器控制步数</li>
<li>考虑查找失败结果</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位置查找结点</span></span><br><span class="line"><span class="function">LNode* <span class="title">List_search_position</span><span class="params">(LinkList L, <span class="type">int</span> serch_position)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//定义一个变量i，用于记录当前结点的位置</span></span><br><span class="line">	<span class="keyword">if</span> (serch_position &lt; <span class="number">1</span>) <span class="comment">//如果serch_position小于1,则返回空指针</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"serch_position is less than 1,i will return head pointer,it means the serch_position is 1\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (serch_position &gt; L-&gt;data) <span class="comment">//如果serch_position大于链表的长度,则返回空指针</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"serch_position is greater than the length of the list\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (L != <span class="literal">nullptr</span> &amp;&amp; i != serch_position)<span class="comment">//当L不为空且i不等于serch_position时,遍历链表</span></span><br><span class="line">	{</span><br><span class="line">		L = L-&gt;next; <span class="comment">//L指向下一个结点</span></span><br><span class="line">		i++; </span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i != serch_position) <span class="comment">//如果循环完毕后,i不等于serch_position,则说明没有找到serch_position位置的结点</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The serch_position is not found,it may because the serch_position is greater than the length of the list\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> L; <span class="comment">//返回目标结点的指针</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找结点</span></span><br><span class="line"><span class="function">LNode* <span class="title">List_search_value</span><span class="params">(LinkList L, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (L != <span class="literal">nullptr</span> &amp;&amp; L-&gt;data != x) <span class="comment">//当L不为空且L的data域不等于x时,循环</span></span><br><span class="line">	{</span><br><span class="line">		L = L-&gt;next; <span class="comment">//L指向下一个结点</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (L != <span class="literal">nullptr</span>) <span class="comment">//如果L不为空,则返回L</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> L;  <span class="comment">//当循环完毕后,如果L不为空且L的data域等于x,则说明找到了x值对应的结点 //返回找到的结点</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//如果L为空,则说明没有找到x值对应的结点</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The value is not found\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkList Serch_pointer;<span class="comment">//定义指针变量，指向要查找的结点</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="6-按位置插入节点"><a href="#6-按位置插入节点" class="headerlink" title="6.按位置插入节点"></a>6.按位置插入节点</h4><ol>
<li>定义一个指针变量s，用于指向新结点</li>
<li>考虑在第一个位置插入的结点的情况，此时直接应用头插法算法</li>
<li>通过<code>List_search_position(L, insert_position - 1)</code>获取<strong>目标结点的前一个结点的指针域的值</strong></li>
<li>判断p是否为空，决定是否执行插入算法</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位置插入结点到第insert_position个位置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List_insert_position</span><span class="params">(LinkList L, <span class="type">int</span> insert_position, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	</span><br><span class="line">	LinkList s; <span class="comment">//定义一个指针变量s，用于指向新结点</span></span><br><span class="line">	<span class="keyword">if</span> (insert_position == <span class="number">1</span>) {</span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给新结点</span></span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		s-&gt;next = L-&gt;next; <span class="comment">//新结点的指针域指向旧头结点</span></span><br><span class="line">		L-&gt;next = s; <span class="comment">//将头结点的指针域指向新结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	LinkList p = <span class="built_in">List_search_position</span>(L, insert_position - <span class="number">1</span>);<span class="comment">//p指向insert_position位置的结点，即p的值为目标结点的前一个结点的指针域的值</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">//如果s为空,则说明insert_position大于链表的长度,插入到尾结点之后</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"insert_position is greater than the length of the list,you can't insert it\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给新结点</span></span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		s-&gt;next = p-&gt;next; <span class="comment">//新结点的指针域指向旧结点的下一个结点</span></span><br><span class="line">		p-&gt;next = s; <span class="comment">//将旧结点的指针域指向新结点</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="7-单链表删除节点"><a href="#7-单链表删除节点" class="headerlink" title="7.单链表删除节点"></a>7.单链表删除节点</h4><ol>
<li>通过<code>List_search_position(L, insert_position - 1)</code>获取<strong>目标结点的前一个结点的指针域的值</strong></li>
<li>判断p是否为空，决定是否执行删除算法</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位置删除指定结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List_delete_position</span><span class="params">(LinkList &amp;L, <span class="type">int</span> delete_position)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">	LinkList p = <span class="built_in">List_search_position</span>(L, delete_position - <span class="number">1</span>); <span class="comment">//p指向要删除的结点</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">//如果p为空,则说明delete_position大于链表的长度,删除失败</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"delete_position is greater than the length of the list,you can't delete it\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		LinkList q; <span class="comment">//定义一个指针变量q，用于储存被删除结点的地址</span></span><br><span class="line">		q = p-&gt;next; <span class="comment">//q获得了目标节点的指针域的值</span></span><br><span class="line">		p-&gt;next = q-&gt;next; <span class="comment">//将p的指针域指向q的下一个结点</span></span><br><span class="line">		<span class="built_in">free</span>(q); <span class="comment">//释放要删除的结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="单链表总体代码"><a href="#单链表总体代码" class="headerlink" title="单链表总体代码"></a>单链表总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>单链表总体代码 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>{</span><br><span class="line">	ElementType data;  <span class="comment">//数据域</span></span><br><span class="line">	LNode* next;  <span class="comment">//指向结构体LNode的指针  </span></span><br><span class="line">}LNode,*LinkList;   <span class="comment">//定义链表的名字和头指针  //*LinkList表示LinkList是一个指针变量，指向结构体LNode的首地址</span></span><br><span class="line"><span class="comment">//LNode* 和 LinkList 都可以表示结构体LNode的首地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法，将新结点插入到链表的头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_head_insert</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LNode* s; <span class="comment">//定义一个指针变量s，指向新结点</span></span><br><span class="line">	ElementType x = <span class="number">0</span>; <span class="comment">//定义一个变量x，用于输入数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建头结点</span></span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给链表的头结点,malloc申请内存后返回首地址给到L,则L为结构体LNode的首地址(即头指针)</span></span><br><span class="line">	<span class="comment">//L-&gt;data = x;  //头结点的data域置0</span></span><br><span class="line">	L-&gt;data = <span class="number">99</span>;  <span class="comment">//头结点的data域置为链表长度,注意这里的99是随便设置的,具体取值要根据链表实际长度来确定</span></span><br><span class="line">	L-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//头插法，将新结点插入到链表的头部</span></span><br><span class="line">	<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//首次输入数据</span></span><br><span class="line">	<span class="keyword">while</span>(x != <span class="number">9999</span>) </span><br><span class="line">	{</span><br><span class="line"></span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给新结点		</span></span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		s-&gt;next = L-&gt;next; <span class="comment">//新结点的指针域指向旧头结点</span></span><br><span class="line">		L-&gt;next = s; <span class="comment">//将头结点的指针域指向新结点</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//再次输入数据,直到输入9999结束</span></span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法，将新结点插入到链表的尾部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_tail_insert</span><span class="params">(LinkList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LNode* s,*r; <span class="comment">//定义一个指针变量s，指向新结点    r，指向最后一个结点</span></span><br><span class="line">	ElementType x = <span class="number">0</span>; <span class="comment">//定义一个变量x，用于输入数据</span></span><br><span class="line">	<span class="comment">//创建头结点</span></span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给链表的头结点,malloc申请内存后返回首地址给到L,则L为结构体LNode的首地址(即头指针)</span></span><br><span class="line">	<span class="comment">//L-&gt;data = x;  //头结点的data域置0</span></span><br><span class="line">	L-&gt;data = <span class="number">99</span>;  <span class="comment">//头结点的data域置为链表长度,注意这里的99是随便设置的,具体取值要根据链表实际长度来确定</span></span><br><span class="line">	L-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	r = L; <span class="comment">//r指向头结点</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    <span class="comment">//尾插法，将新结点插入到链表的尾部</span></span><br><span class="line">	<span class="keyword">while</span>(x != <span class="number">9999</span>)</span><br><span class="line">	{ </span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		r-&gt;next =s; <span class="comment">//将r的指针域指向新结点,在第一次循环时,相当于让L的指针域指向新结点,以为上文定义了*r =L</span></span><br><span class="line">		r = s; <span class="comment">//r指向新结点</span></span><br><span class="line">		<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//输入数据</span></span><br><span class="line">	}</span><br><span class="line">	r-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//最后一个结点的指针域置空</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置查找结点</span></span><br><span class="line"><span class="function">LNode* <span class="title">List_search_position</span><span class="params">(LinkList L, <span class="type">int</span> serch_position)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//定义一个变量i，用于记录当前结点的位置</span></span><br><span class="line">	<span class="keyword">if</span> (serch_position &lt; <span class="number">1</span>) <span class="comment">//如果serch_position小于1,则返回空指针</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"serch_position is less than 1,i will return head pointer,it means the serch_position is 1\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (serch_position &gt; L-&gt;data) <span class="comment">//如果serch_position大于链表的长度,则返回空指针</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"serch_position is greater than the length of the list\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (L != <span class="literal">nullptr</span> &amp;&amp; i != serch_position)<span class="comment">//当L不为空且i不等于serch_position时,遍历链表</span></span><br><span class="line">	{</span><br><span class="line">		L = L-&gt;next; <span class="comment">//L指向下一个结点</span></span><br><span class="line">		i++; </span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i != serch_position) <span class="comment">//如果循环完毕后,i不等于serch_position,则说明没有找到serch_position位置的结点</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The serch_position is not found,it may because the serch_position is greater than the length of the list\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> L; <span class="comment">//返回目标结点的指针</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找结点</span></span><br><span class="line"><span class="function">LNode* <span class="title">List_search_value</span><span class="params">(LinkList L, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (L != <span class="literal">nullptr</span> &amp;&amp; L-&gt;data != x) <span class="comment">//当L不为空且L的data域不等于x时,循环</span></span><br><span class="line">	{</span><br><span class="line">		L = L-&gt;next; <span class="comment">//L指向下一个结点</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (L != <span class="literal">nullptr</span>) <span class="comment">//如果L不为空,则返回L</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> L;  <span class="comment">//当循环完毕后,如果L不为空且L的data域等于x,则说明找到了x值对应的结点 //返回找到的结点</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//如果L为空,则说明没有找到x值对应的结点</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The value is not found\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置插入结点到第insert_position个位置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List_insert_position</span><span class="params">(LinkList L, <span class="type">int</span> insert_position, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	</span><br><span class="line">	LinkList s; <span class="comment">//定义一个指针变量s，用于指向新结点</span></span><br><span class="line">	<span class="keyword">if</span> (insert_position == <span class="number">1</span>) {</span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给新结点</span></span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		s-&gt;next = L-&gt;next; <span class="comment">//新结点的指针域指向旧头结点</span></span><br><span class="line">		L-&gt;next = s; <span class="comment">//将头结点的指针域指向新结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	LinkList p = <span class="built_in">List_search_position</span>(L, insert_position - <span class="number">1</span>);<span class="comment">//p指向insert_position位置的结点，即p的值为目标结点的前一个结点的指针域的值</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">//如果s为空,则说明insert_position大于链表的长度,插入到尾结点之后</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"insert_position is greater than the length of the list,you can't insert it\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给新结点</span></span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		s-&gt;next = p-&gt;next; <span class="comment">//新结点的指针域指向旧结点的下一个结点</span></span><br><span class="line">		p-&gt;next = s; <span class="comment">//将旧结点的指针域指向新结点</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置删除指定结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List_delete_position</span><span class="params">(LinkList &amp;L, <span class="type">int</span> delete_position)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">	LinkList p = <span class="built_in">List_search_position</span>(L, delete_position - <span class="number">1</span>); <span class="comment">//p指向要删除的结点</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">//如果p为空,则说明delete_position大于链表的长度,删除失败</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"delete_position is greater than the length of the list,you can't delete it\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		LinkList q; <span class="comment">//定义一个指针变量q，用于储存被删除结点的地址</span></span><br><span class="line">		q = p-&gt;next; <span class="comment">//q获得了目标节点的指针域的值</span></span><br><span class="line">		p-&gt;next = q-&gt;next; <span class="comment">//将p的指针域指向q的下一个结点</span></span><br><span class="line">		<span class="built_in">free</span>(q); <span class="comment">//释放要删除的结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_print</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span>(L != <span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, L-&gt;data);</span><br><span class="line">		L = L-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkList L; <span class="comment">//定义链表的头指针.L为结构体类型的指针变量，指向结构体LNode的头节点地址</span></span><br><span class="line">	LinkList Serch_pointer;<span class="comment">//定义指针变量，指向要查找的结点</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">List_head_insert</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//List_tail_insert(L);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">List_print</span>(L);</span><br><span class="line"></span><br><span class="line">	Serch_pointer = <span class="built_in">List_search_position</span>(L, <span class="number">1</span>); <span class="comment">//查找第3个结点</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The data of the serch_pointer is %d\n"</span>, Serch_pointer-&gt;data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Serch_pointer = List_search_value(L, 10); //查找值为10的结点</span></span><br><span class="line">	<span class="comment">//printf("The data of the serch_pointer is %d and the value is %d\n", L, Serch_pointer-&gt;data);</span></span><br><span class="line">	<span class="comment">////打印指针没有实际意义，只是为了测试指针是否存在,层序每次运行的结果都不一样，所以指针的值也是随机的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//List_insert_position(L, 1, 100); //在第3个位置插入值为100的结点</span></span><br><span class="line">	<span class="comment">//List_print(L);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">List_delete_position</span>(L, <span class="number">1</span>); <span class="comment">//删除第3个结点</span></span><br><span class="line">	<span class="built_in">List_print</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h2 id="栈-（Stack）"><a href="#栈-（Stack）" class="headerlink" title="栈 （Stack）"></a>栈 （Stack）</h2><p>栈是一种**后进先出（LIFO）**的数据结构。栈中元素只能在一端添加或移除，这一端被称为“栈顶”。在栈的操作中，常用的操作有：</p>
<ul>
<li><strong>push</strong>：将元素压入栈顶。</li>
<li><strong>pop</strong>：将栈顶元素弹出。</li>
<li><strong>peek</strong>：查看栈顶元素，但不移除它。</li>
</ul>
<p><strong>栈的应用</strong>：广泛用于递归算法、表达式求值、括号匹配、函数调用等场景。</p>
<p>栈的本质为人为控制进出规则的数组,通过控制索引来控制数组中的数据进出，栈可以顺序定义也可链式定义</p>
<h3 id="顺序栈-squencial-stack"><a href="#顺序栈-squencial-stack" class="headerlink" title="顺序栈(squencial stack)"></a>顺序栈(squencial stack)</h3><p>有顺序表发展而来的数据结构，其在内存中需要连续的空间</p>
<h4 id="1-顺序栈结构定义"><a href="#1-顺序栈结构定义" class="headerlink" title="1.顺序栈结构定义"></a>1.顺序栈结构定义</h4><p>顺序栈由一个数组和一个用于标记数组索引的整型值组成</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈(squencial stack)结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Stack</span></span><br><span class="line">{</span><br><span class="line">	ElementType data[MAX_SIZE];<span class="comment">//栈体</span></span><br><span class="line">	<span class="type">int</span> top;<span class="comment">//栈顶索引</span></span><br><span class="line">}SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SqStack S;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="2-初始化栈"><a href="#2-初始化栈" class="headerlink" title="2.初始化栈"></a>2.初始化栈</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	S.top = <span class="number">-1</span>;<span class="comment">//栈顶索引初始化为-1,表示栈为空 同时意味着栈索引从0开始</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="3-入栈操作-Push"><a href="#3-入栈操作-Push" class="headerlink" title="3.入栈操作(Push)"></a>3.入栈操作(Push)</h4><ol>
<li>判断是否可继续入栈</li>
<li>修改索引，填值</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断栈是否为满</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsStackFull</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == MAdata_x_SIZE - <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is full!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作(Push)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack&amp; S, ElementType data_x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsStackFull</span>(S))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//S.top++;</span></span><br><span class="line">		<span class="comment">//S.data[S.top] = data_x; //该代码可被优化</span></span><br><span class="line"></span><br><span class="line">		S.data[++S.top] = data_x; <span class="comment">//优化后代码  其中[++S.top]表示S.data索引自增1，然后将data_x值存入栈顶</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="4-出栈操作-Pop"><a href="#4-出栈操作-Pop" class="headerlink" title="4.出栈操作(Pop)"></a>4.出栈操作(Pop)</h4><ol>
<li>判断栈内是否有值</li>
<li>取值，修改索引</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出栈操作(Pop)(获取栈顶元素并删除栈内的栈顶元素)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack&amp; S, ElementType&amp; data_x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty,can not pop!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//data_x = S.data[S.top];</span></span><br><span class="line">		<span class="comment">//S.top--;</span></span><br><span class="line">		data_x = S.data[S.top--]; <span class="comment">//优化后代码  其中[S.top--]表示S.data先调用索引为[S.top]的值后,再将索引自减1，然后取出栈顶元素值</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">}<span class="comment">//出栈本质为索引向前移动</span></span><br></pre></td></tr></table></figure></div>



<h4 id="5-读取栈顶元素-Peek"><a href="#5-读取栈顶元素-Peek" class="headerlink" title="5.读取栈顶元素(Peek)"></a>5.读取栈顶元素(Peek)</h4><ol>
<li>判断栈内是否有值</li>
<li>取值</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取栈顶元素(Peek)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Peek</span><span class="params">(SqStack&amp; S, ElementType&amp; data_x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty,can not get top!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		data_x = S.data[S.top];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}	</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="顺序栈总体代码"><a href="#顺序栈总体代码" class="headerlink" title="顺序栈总体代码"></a>顺序栈总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>顺序栈总体代码 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAdata_x_SIZE 8</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈(squencial stack)结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Stack</span></span><br><span class="line">{</span><br><span class="line">	ElementType data[MAdata_x_SIZE];</span><br><span class="line">	<span class="type">int</span> top; <span class="comment">//栈顶索引</span></span><br><span class="line">}SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	S.top = <span class="number">-1</span>;<span class="comment">//栈顶索引初始化为-1,表示栈为空 同时意味着栈索引从0开始</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为满</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsStackFull</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == MAdata_x_SIZE - <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is full!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack&amp; S, ElementType data_x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsStackFull</span>(S))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//S.top++;</span></span><br><span class="line">		<span class="comment">//S.data[S.top] = data_x; //该代码可被优化</span></span><br><span class="line"></span><br><span class="line">		S.data[++S.top] = data_x; <span class="comment">//优化后代码  其中[++S.top]表示S.data索引自增1，然后将data_x值存入栈顶</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作(获取栈顶元素并删除栈内的栈顶元素)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack&amp; S, ElementType&amp; data_x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty,can not pop!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//data_x = S.data[S.top];</span></span><br><span class="line">		<span class="comment">//S.top--;</span></span><br><span class="line">		data_x = S.data[S.top--]; <span class="comment">//优化后代码  其中[S.top--]表示S.data先调用索引为[S.top]的值后,再将索引自减1，然后取出栈顶元素值</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">}<span class="comment">//出栈本质为索引向前移动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack&amp; S, ElementType&amp; data_x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty,can not get top!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		data_x = S.data[S.top];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStack</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty,nothing to print!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= S.top; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, S.data[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SqStack S;</span><br><span class="line">	<span class="built_in">InitStack</span>(S);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">6</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">7</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">9</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试栈</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAdata_x_SIZE; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">PrintStack</span>(S);</span><br><span class="line">		ElementType y;</span><br><span class="line">		<span class="built_in">GetTop</span>(S,y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Top element is %d\n"</span>, y);</span><br><span class="line">		<span class="built_in">Pop</span>(S, y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Pop element is %d\n"</span>, y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"After pop, stack is:\n"</span>);</span><br><span class="line">		<span class="built_in">PrintStack</span>(S);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h3 id="链栈（Link-Stack"><a href="#链栈（Link-Stack" class="headerlink" title="链栈（Link Stack)"></a>链栈（Link Stack)</h3><p>由链表发展而来,使用零散内存空间</p>
<h4 id="1-链栈定义"><a href="#1-链栈定义" class="headerlink" title="1. 链栈定义"></a>1. 链栈定义</h4><p>完全继承链表定义形式</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkStack</span></span><br><span class="line">{</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkStack</span>* next;</span><br><span class="line">}*LS;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS L;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="2-链栈初始化"><a href="#2-链栈初始化" class="headerlink" title="2. 链栈初始化"></a>2. 链栈初始化</h4><p>由于链表仅能由头结点开始遍历的特性,考虑到后续操作,链栈最佳初始化方案为头插法</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createStack</span><span class="params">(LS &amp;L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS p;</span><br><span class="line">	ElemType x = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//头结点</span></span><br><span class="line">	L = (LS)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkStack));</span><br><span class="line">	L-&gt;data = x;</span><br><span class="line">	L-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//后续第一个进入栈的节点将指向空,当栈为空时,next指向空</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="3-栈的状态"><a href="#3-栈的状态" class="headerlink" title="3.栈的状态"></a>3.栈的状态</h4><p>链栈没必要设置上限,除非是大数据流进入,否则零散利用内存的分配方式几乎不可能将内存占满</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LS L)</span><span class="comment">//当栈为空时,next指向空</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="4-入栈"><a href="#4-入栈" class="headerlink" title="4. 入栈"></a>4. 入栈</h4><p>算法与头插法创建链表相同</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(LS&amp; L, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS p;</span><br><span class="line">	p = (LS)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkStack));</span><br><span class="line">	p-&gt;data = x;</span><br><span class="line">	p-&gt;next = L-&gt;next;</span><br><span class="line">	L-&gt;next = p;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="5-出栈"><a href="#5-出栈" class="headerlink" title="5.出栈"></a>5.出栈</h4><p>调用并删除链表中第一个结点</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(LS&amp; L, ElemType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS p;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	p = L-&gt;next;</span><br><span class="line">	x = p-&gt;data;</span><br><span class="line">	L-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="6-获取栈顶数据"><a href="#6-获取栈顶数据" class="headerlink" title="6. 获取栈顶数据"></a>6. 获取栈顶数据</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getTop</span><span class="params">(LS L, ElemType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	x = L-&gt;next-&gt;data;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="链栈总体代码"><a href="#链栈总体代码" class="headerlink" title="链栈总体代码"></a>链栈总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>链栈总体代码 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkStack</span></span><br><span class="line">{</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkStack</span>* next;</span><br><span class="line">}*LS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createStack</span><span class="params">(LS &amp;L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS p;</span><br><span class="line">	ElemType x = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//头结点</span></span><br><span class="line">	L = (LS)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkStack));</span><br><span class="line">	L-&gt;data = x;</span><br><span class="line">	L-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//后续第一个进入栈的节点将指向空,当栈为空时,next指向空</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LS L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(LS&amp; L, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS p;</span><br><span class="line">	p = (LS)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkStack));</span><br><span class="line">	p-&gt;data = x;</span><br><span class="line">	p-&gt;next = L-&gt;next;</span><br><span class="line">	L-&gt;next = p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(LS&amp; L, ElemType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS p;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	p = L-&gt;next;</span><br><span class="line">	x = p-&gt;data;</span><br><span class="line">	L-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getTop</span><span class="params">(LS L, ElemType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	x = L-&gt;next-&gt;data;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStack</span><span class="params">(LS L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (L-&gt;next!= <span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, L-&gt;next-&gt;data);</span><br><span class="line">		L = L-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS L;</span><br><span class="line">	<span class="built_in">createStack</span>(L);</span><br><span class="line">	<span class="built_in">push</span>(L, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push</span>(L, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">push</span>(L, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">push</span>(L, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printStack</span>(L);</span><br><span class="line"></span><br><span class="line">	ElemType x;</span><br><span class="line">	<span class="built_in">pop</span>(L, x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"poped element is %d\n"</span>, x);</span><br><span class="line">	<span class="built_in">printStack</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">getTop</span>(L, x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"top element is %d\n"</span>, x);</span><br><span class="line">	<span class="built_in">printStack</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><p>队列是一种**先进先出（FIFO）**的数据结构。队列中元素只能从一端进入（队尾），从另一端移除（队头）。常用操作包括：</p>
<ul>
<li><strong>enqueue</strong>：将元素加入队尾。</li>
<li><strong>dequeue</strong>：将队头元素移除。</li>
<li><strong>peek</strong>：查看队头元素。</li>
</ul>
<p><strong>队列的应用</strong>：广泛用于任务调度、广度优先搜索、数据缓冲等场景。</p>
<h3 id="循环-顺序-队列-SquenceQueue"><a href="#循环-顺序-队列-SquenceQueue" class="headerlink" title="循环(顺序)队列(SquenceQueue)"></a>循环(顺序)队列(SquenceQueue)</h3><h4 id="1-创建队列"><a href="#1-创建队列" class="headerlink" title="1. 创建队列"></a>1. 创建队列</h4><p>循环队列又一个自定义的数组和队首与队尾两个逻辑指针构成</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">	ElementType data[MAX_SIZE];</span><br><span class="line">	<span class="type">int</span> front, rear;  </span><br><span class="line">} SquenceQueue;</span><br><span class="line"><span class="comment">//在循环队列中，data[SQ.rear]中的SQ.rear的值</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-队列初始化"><a href="#2-队列初始化" class="headerlink" title="2. 队列初始化"></a>2. 队列初始化</h4><p>规定队列首尾标相等时为空</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SquenceQueue&amp; SQ)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SQ.front = SQ.rear = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SquenceQueue SQ;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="3-入队"><a href="#3-入队" class="headerlink" title="3. 入队"></a>3. 入队</h4><p><strong>循环队列核心算法</strong> : </p>
<p><code>(SQ.rear + 1) % MAX_SIZE</code>算法实现了索引循环的功能,且<code>SQ.rear + 1</code>避免了在数组被占满时尾标与头标重合的情况,即组下标越界，使得队列满时队首和队尾重合，再插入元素时会覆盖队首元素</p>
<p>该算法规定队首和队尾相等时为空,<code>(SQ.rear + 1) % MAX_SIZE</code>的存在<code>SQ.rear</code>和<code>SQ.front</code>的取值范围为<code>[0,MAX_SIZE-1]</code>,构造体中的数组最后一位的被索引跳过,该存储单元值为0,且不会被调用</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SquenceQueue&amp; SQ,ElementType value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> ((SQ.rear + <span class="number">1</span>) % MAX_SIZE == SQ.front) <span class="comment">//队尾标加1并向队列长度取余，等于队头，表示队列已满   </span></span><br><span class="line">	{                                         </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is full!\n"</span>);           </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;                         </span><br><span class="line">	}</span><br><span class="line">	SQ.data[SQ.rear] = value;</span><br><span class="line">	SQ.rear = (SQ.rear + <span class="number">1</span>) % MAX_SIZE; <span class="comment">//当队尾标移动到倒数第二个位置时表示队列已满，向队列长度取余，使队尾标归零</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="4-出队"><a href="#4-出队" class="headerlink" title="4. 出队"></a>4. 出队</h4><p>与入队原理相同</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SquenceQueue&amp; SQ, ElementType&amp; value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (SQ.front == SQ.rear) <span class="comment">//队列为空，队头和队尾重合</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	value = SQ.data[SQ.front];</span><br><span class="line">	SQ.front = (SQ.front + <span class="number">1</span>) % MAX_SIZE; <span class="comment">//队头向队列长度取余，使队头标归零</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="5-查看队首元素"><a href="#5-查看队首元素" class="headerlink" title="5. 查看队首元素"></a>5. 查看队首元素</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">peek</span><span class="params">(SquenceQueue SQ, ElementType&amp; value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (SQ.front == SQ.rear) <span class="comment">//队列为空，队头和队尾重合</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	value = SQ.data[SQ.front];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="循环队列总体代码"><a href="#循环队列总体代码" class="headerlink" title="循环队列总体代码"></a>循环队列总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>循环队列总体代码 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">	ElementType data[MAX_SIZE];</span><br><span class="line">	<span class="type">int</span> front, rear;  </span><br><span class="line">} SquenceQueue;</span><br><span class="line"><span class="comment">//在循环队列中，data[SQ.rear]中的SQ.rear的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SquenceQueue&amp; SQ)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SQ.front = SQ.rear = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SquenceQueue&amp; SQ,ElementType value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> ((SQ.rear + <span class="number">1</span>) % MAX_SIZE == SQ.front) <span class="comment">//队尾标加1并向队列长度取余，等于队头，表示队列已满   </span></span><br><span class="line">	{                                         </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is full!\n"</span>);           <span class="comment">//</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;                         </span><br><span class="line">	}</span><br><span class="line">	SQ.data[SQ.rear] = value;</span><br><span class="line">	SQ.rear = (SQ.rear + <span class="number">1</span>) % MAX_SIZE; <span class="comment">//当队尾标移动到倒数第二个位置时表示队列已满，向队列长度取余，使队尾标归零</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SquenceQueue&amp; SQ, ElementType&amp; value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (SQ.front == SQ.rear) <span class="comment">//队列为空，队头和队尾重合</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	value = SQ.data[SQ.front];</span><br><span class="line">	SQ.front = (SQ.front + <span class="number">1</span>) % MAX_SIZE; <span class="comment">//队头向队列长度取余，使队头标归零</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintQueue</span><span class="params">(SquenceQueue SQ)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (SQ.front == SQ.rear) <span class="comment">//队列为空，队头和队尾重合</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = SQ.front; i != SQ.rear; i = (i + <span class="number">1</span>) % MAX_SIZE)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, SQ.data[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">peek</span><span class="params">(SquenceQueue SQ, ElementType&amp; value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (SQ.front == SQ.rear) <span class="comment">//队列为空，队头和队尾重合</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	value = SQ.data[SQ.front];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main_SQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SquenceQueue SQ;</span><br><span class="line">	<span class="built_in">InitQueue</span>(SQ);</span><br><span class="line">	<span class="built_in">EnQueue</span>(SQ, <span class="number">11</span>);</span><br><span class="line">	<span class="built_in">EnQueue</span>(SQ, <span class="number">22</span>);</span><br><span class="line">	<span class="built_in">EnQueue</span>(SQ, <span class="number">33</span>);	</span><br><span class="line">	<span class="built_in">EnQueue</span>(SQ, <span class="number">44</span>);</span><br><span class="line">	<span class="built_in">EnQueue</span>(SQ, <span class="number">55</span>);</span><br><span class="line">	<span class="built_in">PrintQueue</span>(SQ);</span><br><span class="line"></span><br><span class="line">	ElementType testvalue;</span><br><span class="line">	<span class="built_in">DeQueue</span>(SQ, testvalue);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"DeQueue value is %d\n"</span>, testvalue);</span><br><span class="line">	<span class="built_in">PrintQueue</span>(SQ);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DeQueue</span>(SQ, testvalue);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"DeQueue value is %d\n"</span>, testvalue);</span><br><span class="line">	<span class="built_in">PrintQueue</span>(SQ);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EnQueue</span>(SQ, <span class="number">66</span>);</span><br><span class="line">	<span class="built_in">PrintQueue</span>(SQ);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h3 id="链队列-LinkQueue"><a href="#链队列-LinkQueue" class="headerlink" title="链队列(LinkQueue)"></a>链队列(LinkQueue)</h3><p>链队列由一个单链表和分别指代首尾的两个指针构成,用两个构造体分别构造单链表和首尾指针组</p>
<h4 id="1-构建链队列"><a href="#1-构建链队列" class="headerlink" title="1. 构建链队列"></a>1. 构建链队列</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueueNode</span></span><br><span class="line">{</span><br><span class="line">    ElementType data;</span><br><span class="line">    LinkQueueNode *next;</span><br><span class="line">} LQN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueuePointers</span></span><br><span class="line">{</span><br><span class="line">    LQN *front;</span><br><span class="line">    LQN *rear;</span><br><span class="line">} LQP;</span><br></pre></td></tr></table></figure></div>

<h4 id="1-初始化链队列"><a href="#1-初始化链队列" class="headerlink" title="1. 初始化链队列"></a>1. 初始化链队列</h4><p>由于构造体<code>LinkQueuePointers</code>包含了用于指向<code>LinkQueueNode</code>的指针,因此只需创<code>LinkQueuePointers</code>的实例即可通过内置的指针来向内存申请空间</p>
<p>注意 : <code>(LQN*)malloc(sizeof(struct LinkQueuePointers));</code>这行代码的含义是向内存空间申请一个大小为两个指针空间,且这连个指针式用于指向构造体<code>LinkQueuePointers</code>的</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LQP &amp;P)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    P.front = P.rear = (LQN*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueuePointers));</span><br><span class="line">    P.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQP P;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="1-入队"><a href="#1-入队" class="headerlink" title="1. 入队"></a>1. 入队</h4><p>单链表尾插法入队,链表在内存空间足够大的情况下无需考虑长度上限问题</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LQP&amp; P, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQN *newp = (LQN*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueuePointers));   </span><br><span class="line">    newp-&gt;data = x;</span><br><span class="line">    P.rear-&gt;next = newp;<span class="comment">//尾指针的next指向新节点</span></span><br><span class="line">    P.rear = newp; <span class="comment">//尾指针向后移动</span></span><br><span class="line">    newp-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//此时尾节点更新,需设置为节点next为空</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="1-出队"><a href="#1-出队" class="headerlink" title="1. 出队"></a>1. 出队</h4><ol>
<li>判断队列是否为空</li>
<li>拿到第一个结点的数据并断链和释放内存</li>
<li>考虑当取出最后一个结点元素时,尾指针与头指针复位的问题</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LQP&amp; P, ElementType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (P.front == P.rear) <span class="comment">//判断队列是否为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Queue is Empty,nothing can DeQueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LQN* dep = P.front-&gt;next; <span class="comment">//获取队首地址</span></span><br><span class="line">    x = dep-&gt;data; <span class="comment">//获取队首数据</span></span><br><span class="line">    P.front-&gt;next = dep-&gt;next; <span class="comment">//队首指针指向取出元素的节点的后面的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (P.rear == dep) <span class="comment">//当取出的元素是最后一个元素时,使rear指针指向front指针,即队列为空</span></span><br><span class="line">    {</span><br><span class="line">        P.rear = P.front;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(dep);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="1-查看队首元素"><a href="#1-查看队首元素" class="headerlink" title="1. 查看队首元素"></a>1. 查看队首元素</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PeekQueue</span><span class="params">(LQP P, ElementType &amp;x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (P.front == P.rear) <span class="comment">//判断队列是否为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Queue is Empty,nothing can DeQueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LQN* peekp = P.front-&gt;next; <span class="comment">//获取队首地址</span></span><br><span class="line">    x = peekp-&gt;data; <span class="comment">//获取队首数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>


<h4 id="链式队列总体代码"><a href="#链式队列总体代码" class="headerlink" title="链式队列总体代码"></a>链式队列总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>链式队列总体代码 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueueNode</span></span><br><span class="line">{</span><br><span class="line">    ElementType data;</span><br><span class="line">    LinkQueueNode *next;</span><br><span class="line">} LQN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueuePointers</span></span><br><span class="line">{</span><br><span class="line">    LQN *front;</span><br><span class="line">    LQN *rear;</span><br><span class="line">} LQP;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用尾插法建立链队列,规 定链尾为rear指针,链头为front指针</span></span><br><span class="line"><span class="comment">//入队时,将新结点p插入rear指针后面,然后将rear指针指向新结点p</span></span><br><span class="line"><span class="comment">//出队时,将front指针指向front指针后面的结点,并返回其数据</span></span><br><span class="line"><span class="comment">//判空时,若front指针为空,则队列为空,否则不为空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LQP &amp;P)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    P.front = P.rear = (LQN*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueuePointers));</span><br><span class="line">    P.front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LQP&amp; P, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQN *newp = (LQN*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueuePointers));   </span><br><span class="line">    newp-&gt;data = x;</span><br><span class="line">    P.rear-&gt;next = newp;<span class="comment">//尾指针的next指向新节点</span></span><br><span class="line">    P.rear = newp; <span class="comment">//尾指针向后移动</span></span><br><span class="line">    newp-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//此时尾节点更新,需设置为节点next为空</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LQP&amp; P, ElementType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (P.front == P.rear) <span class="comment">//判断队列是否为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Queue is Empty,nothing can DeQueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LQN* dep = P.front-&gt;next; <span class="comment">//获取队首地址</span></span><br><span class="line">    x = dep-&gt;data; <span class="comment">//获取队首数据</span></span><br><span class="line">    P.front-&gt;next = dep-&gt;next; <span class="comment">//队首指针指向取出元素的节点的后面的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (P.rear == dep) <span class="comment">//当取出的元素是最后一个元素时,使rear指针指向front指针,即队列为空</span></span><br><span class="line">    {</span><br><span class="line">        P.rear = P.front;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(dep);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PeekQueue</span><span class="params">(LQP P, ElementType &amp;x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (P.front == P.rear) <span class="comment">//判断队列是否为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Queue is Empty,nothing can DeQueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LQN* peekp = P.front-&gt;next; <span class="comment">//获取队首地址</span></span><br><span class="line">    x = peekp-&gt;data; <span class="comment">//获取队首数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintQueue</span><span class="params">(LQP P)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQN* p = P.front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!= <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);   </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQP P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitQueue</span>(P);</span><br><span class="line">    <span class="built_in">EnQueue</span>(P, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EnQueue</span>(P, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EnQueue</span>(P, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">EnQueue</span>(P, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">EnQueue</span>(P, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintQueue</span>(P);</span><br><span class="line"></span><br><span class="line">    ElementType x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">DeQueue</span>(P, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dequeue is %d\n"</span>, x);</span><br><span class="line">    <span class="built_in">PrintQueue</span>(P);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeQueue</span>(P, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dequeue is %d\n"</span>, x);</span><br><span class="line">    <span class="built_in">PrintQueue</span>(P);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnQueue</span>(P, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">PrintQueue</span>(P);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PeekQueue</span>(P, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"front of queue is %d\n"</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树-BinaryTree"><a href="#二叉树-BinaryTree" class="headerlink" title="二叉树(BinaryTree)"></a>二叉树(BinaryTree)</h3><p><strong>二叉树</strong>是一种树形数据结构，其中每个节点最多有两个子节点，称为左子节点和右子节点。二叉树具有层次关系，广泛用于数据组织和处理。</p>
<h4 id="定义二叉树"><a href="#定义二叉树" class="headerlink" title="定义二叉树"></a>定义二叉树</h4><p>二叉树主体由两个指针和一个数据组成,但构建二叉树还需要队列的辅助,采用链式队列为优</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BT_ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTreeNode</span></span><br><span class="line">{</span><br><span class="line">    BT_ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTreeNode</span> *lchild, *rchild;</span><br><span class="line">} BiTreeNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTreeTagList</span> <span class="comment">//指针构造体,用于辅助构建二叉树</span></span><br><span class="line">{</span><br><span class="line">    BiTree p; <span class="comment">//指向二叉树节点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTreeTagList</span> *p_next; <span class="comment">//指向按顺序进入二叉树的下一个节点的指针(指针的指针)</span></span><br><span class="line">    <span class="comment">//用于在双亲结点构建完成后对孩子结点进行孙子结点的构建</span></span><br><span class="line">}*BiTreeTag;</span><br></pre></td></tr></table></figure></div>


<h4 id="层次创建二叉树"><a href="#层次创建二叉树" class="headerlink" title="层次创建二叉树"></a>层次创建二叉树</h4><p>依照输入字符的顺序依次从上到下从左到右插入二叉树中</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BiTreeCreate_by_InputChar</span><span class="params">(BiTree &amp;root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    root = <span class="literal">NULL</span>; <span class="comment">//指向树的根节点</span></span><br><span class="line">    BiTree pnew; <span class="comment">//指向新创建的树节点,用于构建二叉树</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    BiTreeTag phead = <span class="literal">NULL</span>, ptail = <span class="literal">NULL</span>; <span class="comment">//分别指向辅助构建二叉树的指针链表的头和尾</span></span><br><span class="line">    BiTreeTag listpnew = <span class="literal">NULL</span>; <span class="comment">//指向辅助构建二叉树的指针链表中新创建的节点(链表的新元素),用于构建二叉树的辅助指针链表</span></span><br><span class="line">    BiTreeTag pcur = <span class="literal">NULL</span>; <span class="comment">//指向正在处理的辅助构建二叉树的指针链表的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf_s</span>(<span class="string">"%c"</span>, &amp;c))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//换行符,表示输入结束</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pnew = (BiTree)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(BiTreeNode));</span><br><span class="line">        <span class="comment">//calloc分配内存,语法为:void *calloc(size_t num, size_t size);</span></span><br><span class="line">        <span class="comment">//calloc分配的内存空间,其大小为num*size字节,并初始化为0,即新建的节点的左右孩子指针都为NULL</span></span><br><span class="line"></span><br><span class="line">        pnew-&gt;data = c; <span class="comment">//为新创建的节点赋值</span></span><br><span class="line"></span><br><span class="line">        listpnew = (BiTreeTag)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(BiTreeTag));</span><br><span class="line">        <span class="comment">//在第一次输入值时作为辅助链表的头指针</span></span><br><span class="line">        <span class="comment">//在第二次输入值以后该指针是用于给辅助链表中的指针传值用的中间量</span></span><br><span class="line"></span><br><span class="line">        listpnew-&gt;p = pnew; <span class="comment">//为新创建的节点指针赋值,此时辅助指针链表得到了目前正在进行树节点构建的节点的指针值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">        {</span><br><span class="line">            root = pnew; <span class="comment">//如果树还没有根节点,则为根节点赋值</span></span><br><span class="line">            phead = listpnew; <span class="comment">//为辅助指针链表的头指针赋值</span></span><br><span class="line">            ptail = listpnew; <span class="comment">//为辅助指针链表的尾指针也赋值</span></span><br><span class="line">            pcur = listpnew; <span class="comment">//pcur指向当前正在处理的辅助指针链表的元素</span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            ptail-&gt;p_next = listpnew; <span class="comment">//如果树已经有根节点,则将新创建的节点指针插入到辅助指针链表的尾部</span></span><br><span class="line">            ptail = listpnew; <span class="comment">//尾指针后移</span></span><br><span class="line">            <span class="keyword">if</span> (pcur-&gt;p-&gt;lchild == <span class="literal">NULL</span>) <span class="comment">//pcur-&gt;p代表正在被加入孩子节点的节点的指针,即pnew</span></span><br><span class="line">            {</span><br><span class="line">                pcur-&gt;p-&gt;lchild = pnew; <span class="comment">//为pcur-&gt;p的左孩子指针赋值</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pcur-&gt;p-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                pcur-&gt;p-&gt;rchild = pnew; <span class="comment">//为pcur-&gt;p的右孩子指针赋值</span></span><br><span class="line">                <span class="comment">//此时pcur-&gt;p已经完成了左右孩子的构建,pcur指向下一个待处理的辅助指针链表的元素</span></span><br><span class="line">                pcur = pcur-&gt;p_next; <span class="comment">//pcur指向下一个待处理的辅助指针链表的元素</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>





<h4 id="先序遍历-深度优先遍历"><a href="#先序遍历-深度优先遍历" class="headerlink" title="先序遍历(深度优先遍历)"></a>先序遍历(深度优先遍历)</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;data); <span class="comment">//先序遍历,根节点-&gt;左子树-&gt;右子树</span></span><br><span class="line">    <span class="built_in">PreOrder</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">PreOrder</span>(root-&gt;rchild);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;   </span><br><span class="line">    <span class="built_in">InOrder</span>(root-&gt;lchild); <span class="comment">//左子树-&gt;根节点-&gt;右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;data);</span><br><span class="line">    <span class="built_in">InOrder</span>(root-&gt;rchild);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">PostOrder</span>(root-&gt;lchild); <span class="comment">//左子树-&gt;右子树-&gt;根节点</span></span><br><span class="line">    <span class="built_in">PostOrder</span>(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;data);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>需要辅助队列进行打印操作,这里使用的头文件来引用ListQueue的数据结构和方法</p>
<ol>
<li>节点入队</li>
<li>打印并出队</li>
<li>判断出队的节点左右孩子是否为空,不为空则使其左右孩子入队,为空则继续</li>
<li>返回 1</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//层序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQP Q; <span class="comment">//队列</span></span><br><span class="line">    BiTree p; <span class="comment">//指向当前节点</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,root);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(Q))<span class="comment">// !bool等于对bool值取反</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p); <span class="comment">//出队 p承接当前出队的节点</span></span><br><span class="line">        <span class="built_in">putchar</span>(p-&gt;data); <span class="comment">//打印当前节点 putchar(p-&gt;data) = printf("%c", p-&gt;data)</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;lchild); <span class="comment">//左孩子入队</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;rchild); <span class="comment">//右孩子入队</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>头文件和队列方法 </summary>
              <div class="content">
              <p>头文件</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BT_ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTreeNode</span></span><br><span class="line">{</span><br><span class="line">    BT_ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTreeNode</span>* lchild, * rchild;</span><br><span class="line">} BiTreeNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTreeTagList</span> <span class="comment">//指针构造体,用于辅助构建二叉树</span></span><br><span class="line">{</span><br><span class="line">    BiTree p; <span class="comment">//指向二叉树节点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTreeTagList</span>* p_next; <span class="comment">//指向按顺序进入二叉树的下一个节点的指针(指针的指针)</span></span><br><span class="line">    <span class="comment">//用于在双亲结点构建完成后对孩子结点进行孙子结点的构建</span></span><br><span class="line">}*BiTreeTag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BiTree ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueueNode</span></span><br><span class="line">{</span><br><span class="line">    ElementType data;</span><br><span class="line">    LinkQueueNode* next;</span><br><span class="line">} LQN;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueuePointers</span></span><br><span class="line">{</span><br><span class="line">    LQN* front;</span><br><span class="line">    LQN* rear;</span><br><span class="line">} LQP;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int fuc_print(int f);  // 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LQP&amp; P)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LQP&amp; P, ElementType x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LQP P)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LQP&amp; P, ElementType&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>队列方法</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LQP &amp;P)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    P.front = P.rear = (LQN*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueuePointers));</span><br><span class="line">    P.front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LQP&amp; P, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQN *newp = (LQN*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueuePointers));   </span><br><span class="line">    newp-&gt;data = x;</span><br><span class="line">    P.rear-&gt;next = newp;<span class="comment">//尾指针的next指向新节点</span></span><br><span class="line">    P.rear = newp; <span class="comment">//尾指针向后移动</span></span><br><span class="line">    newp-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//此时尾节点更新,需设置为节点next为空</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LQP P)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> P.front == P.rear; <span class="comment">// 队列为空返回 true，否则返回 false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LQP&amp; P, ElementType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (P.front == P.rear) <span class="comment">//判断队列是否为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Queue is Empty,nothing can DeQueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LQN* dep = P.front-&gt;next; <span class="comment">//获取队首地址</span></span><br><span class="line">    x = dep-&gt;data; <span class="comment">//获取队首数据</span></span><br><span class="line">    P.front-&gt;next = dep-&gt;next; <span class="comment">//队首指针指向取出元素的节点的后面的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (P.rear == dep) <span class="comment">//当取出的元素是最后一个元素时,使rear指针指向front指针,即队列为空</span></span><br><span class="line">    {</span><br><span class="line">        P.rear = P.front;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(dep);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>


<h4 id="二叉树创建与遍历总体代码"><a href="#二叉树创建与遍历总体代码" class="headerlink" title="二叉树创建与遍历总体代码"></a>二叉树创建与遍历总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>二叉树创建与遍历总体代码 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"C_L_Header.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BT_ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTreeNode</span></span><br><span class="line">{</span><br><span class="line">    BT_ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTreeNode</span>* lchild, * rchild;</span><br><span class="line">} BiTreeNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTreeTagList</span> <span class="comment">//指针构造体,用于辅助构建二叉树</span></span><br><span class="line">{</span><br><span class="line">    BiTree p; <span class="comment">//指向二叉树节点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTreeTagList</span>* p_next; <span class="comment">//指向按顺序进入二叉树的下一个节点的指针(指针的指针)</span></span><br><span class="line">    <span class="comment">//用于在双亲结点构建完成后对孩子结点进行孙子结点的构建</span></span><br><span class="line">}*BiTreeTag;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BiTreeCreate_by_InputChar</span><span class="params">(BiTree &amp;root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    root = <span class="literal">NULL</span>; <span class="comment">//指向树的根节点</span></span><br><span class="line">    BiTree pnew; <span class="comment">//指向新创建的树节点,用于构建二叉树</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    BiTreeTag phead = <span class="literal">NULL</span>, ptail = <span class="literal">NULL</span>; <span class="comment">//分别指向辅助构建二叉树的指针链表的头和尾</span></span><br><span class="line">    BiTreeTag listpnew = <span class="literal">NULL</span>; <span class="comment">//指向辅助构建二叉树的指针链表中新创建的节点(链表的新元素),用于构建二叉树的辅助指针链表</span></span><br><span class="line">    BiTreeTag pcur = <span class="literal">NULL</span>; <span class="comment">//指向正在处理的辅助构建二叉树的指针链表的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf_s</span>(<span class="string">"%c"</span>, &amp;c))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//换行符,表示输入结束</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pnew = (BiTree)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(BiTreeNode));</span><br><span class="line">        <span class="comment">//calloc分配内存,语法为:void *calloc(size_t num, size_t size);</span></span><br><span class="line">        <span class="comment">//calloc分配的内存空间,其大小为num*size字节,并初始化为0,即新建的节点的左右孩子指针都为NULL</span></span><br><span class="line"></span><br><span class="line">        pnew-&gt;data = c; <span class="comment">//为新创建的节点赋值</span></span><br><span class="line"></span><br><span class="line">        listpnew = (BiTreeTag)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(BiTreeTag));</span><br><span class="line">        <span class="comment">//在第一次输入值时作为辅助链表的头指针</span></span><br><span class="line">        <span class="comment">//在第二次输入值以后该指针是用于给辅助链表中的指针传值用的中间量</span></span><br><span class="line"></span><br><span class="line">        listpnew-&gt;p = pnew; <span class="comment">//为新创建的节点指针赋值,此时辅助指针链表得到了目前正在进行树节点构建的节点的指针值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">        {</span><br><span class="line">            root = pnew; <span class="comment">//如果树还没有根节点,则为根节点赋值</span></span><br><span class="line">            phead = listpnew; <span class="comment">//为辅助指针链表的头指针赋值</span></span><br><span class="line">            ptail = listpnew; <span class="comment">//为辅助指针链表的尾指针也赋值</span></span><br><span class="line">            pcur = listpnew; <span class="comment">//pcur指向当前正在处理的辅助指针链表的元素</span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            ptail-&gt;p_next = listpnew; <span class="comment">//如果树已经有根节点,则将新创建的节点指针插入到辅助指针链表的尾部</span></span><br><span class="line">            ptail = listpnew; <span class="comment">//尾指针后移</span></span><br><span class="line">            <span class="keyword">if</span> (pcur-&gt;p-&gt;lchild == <span class="literal">NULL</span>) <span class="comment">//pcur-&gt;p代表正在被加入孩子节点的节点的指针,即pnew</span></span><br><span class="line">            {</span><br><span class="line">                pcur-&gt;p-&gt;lchild = pnew; <span class="comment">//为pcur-&gt;p的左孩子指针赋值</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pcur-&gt;p-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                pcur-&gt;p-&gt;rchild = pnew; <span class="comment">//为pcur-&gt;p的右孩子指针赋值</span></span><br><span class="line">                <span class="comment">//此时pcur-&gt;p已经完成了左右孩子的构建,pcur指向下一个待处理的辅助指针链表的元素</span></span><br><span class="line">                pcur = pcur-&gt;p_next; <span class="comment">//pcur指向下一个待处理的辅助指针链表的元素</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;data); <span class="comment">//先序遍历,根节点-&gt;左子树-&gt;右子树</span></span><br><span class="line">    <span class="built_in">PreOrder</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">PreOrder</span>(root-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;   </span><br><span class="line">    <span class="built_in">InOrder</span>(root-&gt;lchild); <span class="comment">//左子树-&gt;根节点-&gt;右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;data);</span><br><span class="line">    <span class="built_in">InOrder</span>(root-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">PostOrder</span>(root-&gt;lchild); <span class="comment">//左子树-&gt;右子树-&gt;根节点</span></span><br><span class="line">    <span class="built_in">PostOrder</span>(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;data);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印树状二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintTree</span><span class="params">(BiTree root, <span class="type">const</span> <span class="type">char</span>* prefix, <span class="type">int</span> isLeft)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前节点，显示前缀与分支符号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, prefix);</span><br><span class="line">    <span class="built_in">printf</span>(isLeft ? <span class="string">"├── "</span> : <span class="string">"└── "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, root-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的前缀</span></span><br><span class="line">    <span class="type">char</span> newPrefix[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(newPrefix, <span class="built_in">sizeof</span>(newPrefix), <span class="string">"%s%s"</span>, prefix, isLeft ? <span class="string">"│   "</span> : <span class="string">"    "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归打印左右子树</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild || root-&gt;rchild) {</span><br><span class="line">        <span class="built_in">PrintTree</span>(root-&gt;rchild, newPrefix, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">PrintTree</span>(root-&gt;lchild, newPrefix, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQP Q; <span class="comment">//队列</span></span><br><span class="line">    BiTree p; <span class="comment">//指向当前节点</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,root);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(Q))<span class="comment">// !bool等于对bool值取反</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p); <span class="comment">//出队 p承接当前出队的节点</span></span><br><span class="line">        <span class="built_in">putchar</span>(p-&gt;data); <span class="comment">//打印当前节点 putchar(p-&gt;data) = printf("%c", p-&gt;data)</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;lchild); <span class="comment">//左孩子入队</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;rchild); <span class="comment">//右孩子入队</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    BiTree Btree01;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入二叉树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入二叉树节点序列（以换行结束）：\n"</span>);</span><br><span class="line">    <span class="built_in">BiTreeCreate_by_InputChar</span>(Btree01);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"先序遍历结果:\n"</span>);</span><br><span class="line">    <span class="built_in">PreOrder</span>(Btree01);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"中序遍历结果:\n"</span>);</span><br><span class="line">    <span class="built_in">InOrder</span>(Btree01);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"后序遍历结果:\n"</span>);</span><br><span class="line">    <span class="built_in">PostOrder</span>(Btree01);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"层序遍历结果:\n"</span>);</span><br><span class="line">    <span class="built_in">LevelOrder</span>(Btree01);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印树状结构</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树状打印结果:\n"</span>);</span><br><span class="line">    <span class="built_in">PrintTree</span>(Btree01, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h2 id="哈夫曼树与哈夫曼编码"><a href="#哈夫曼树与哈夫曼编码" class="headerlink" title="哈夫曼树与哈夫曼编码"></a>哈夫曼树与哈夫曼编码</h2><p>哈夫曼树（Huffman Tree）是一种带权路径长度最短的二叉树，广泛应用于数据压缩领域。下面我将详细介绍其原理和实现。</p>
<h3 id="1-哈夫曼树基本概念"><a href="#1-哈夫曼树基本概念" class="headerlink" title="1. 哈夫曼树基本概念"></a>1. 哈夫曼树基本概念</h3><p><strong>定义</strong>：给定N个权值作为N个叶子结点，构造一棵二叉树，使该树的带权路径长度（WPL）达到最小。</p>
<p><strong>相关术语</strong>：</p>
<ul>
<li>路径长度：从根节点到某节点的路径上的边数</li>
<li>带权路径长度：结点权值 × 路径长度</li>
<li>树的带权路径长度：所有叶子结点的带权路径长度之和</li>
</ul>
<h3 id="2-哈夫曼树的构建算法"><a href="#2-哈夫曼树的构建算法" class="headerlink" title="2. 哈夫曼树的构建算法"></a>2. 哈夫曼树的构建算法</h3><p><strong>构建步骤</strong>：</p>
<ol>
<li>将每个数据作为一个结点，构成森林F</li>
<li>从F中选出两个根结点权值最小的树作为左右子树，构造新树</li>
<li>新树根结点权值为左右子树根结点权值之和</li>
<li>将新树加入F，删除原来的两棵树</li>
<li>重复2-4步，直到F中只剩一棵树</li>
</ol>
<h3 id="3-C语言实现"><a href="#3-C语言实现" class="headerlink" title="3. C语言实现"></a>3. C语言实现</h3><h4 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> {</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data;    <span class="comment">// 字符数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> weight;   <span class="comment">// 权重</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> *<span class="title">left</span>, *<span class="title">right</span>;</span>  <span class="comment">// 左右孩子指针</span></span><br><span class="line">} HuffmanNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">char</span> code[<span class="number">256</span>];        <span class="comment">// 哈夫曼编码</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data;    <span class="comment">// 对应的字符</span></span><br><span class="line">} HuffmanCode;</span><br></pre></td></tr></table></figure></div>

<h4 id="哈夫曼树构建实现"><a href="#哈夫曼树构建实现" class="headerlink" title="哈夫曼树构建实现"></a>哈夫曼树构建实现</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建哈夫曼树</span></span><br><span class="line">HuffmanNode* <span class="title function_">createHuffmanTree</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> data[], <span class="type">unsigned</span> <span class="type">int</span> weight[], <span class="type">int</span> size)</span> {</span><br><span class="line">    HuffmanNode **nodes = (HuffmanNode**)<span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(HuffmanNode*));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        nodes[i] = (HuffmanNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HuffmanNode));</span><br><span class="line">        nodes[i]-&gt;data = data[i];</span><br><span class="line">        nodes[i]-&gt;weight = weight[i];</span><br><span class="line">        nodes[i]-&gt;left = nodes[i]-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建哈夫曼树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size - <span class="number">1</span>; i++) {</span><br><span class="line">        <span class="comment">// 找到两个最小权重的节点</span></span><br><span class="line">        <span class="type">int</span> min1 = <span class="number">-1</span>, min2 = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++) {</span><br><span class="line">            <span class="keyword">if</span> (nodes[j] != <span class="literal">NULL</span>) {</span><br><span class="line">                <span class="keyword">if</span> (min1 == <span class="number">-1</span> || nodes[j]-&gt;weight &lt; nodes[min1]-&gt;weight) {</span><br><span class="line">                    min2 = min1;</span><br><span class="line">                    min1 = j;</span><br><span class="line">                } <span class="keyword">else</span> <span class="keyword">if</span> (min2 == <span class="number">-1</span> || nodes[j]-&gt;weight &lt; nodes[min2]-&gt;weight) {</span><br><span class="line">                    min2 = j;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建新节点</span></span><br><span class="line">        HuffmanNode *newNode = (HuffmanNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HuffmanNode));</span><br><span class="line">        newNode-&gt;weight = nodes[min1]-&gt;weight + nodes[min2]-&gt;weight;</span><br><span class="line">        newNode-&gt;left = nodes[min1];</span><br><span class="line">        newNode-&gt;right = nodes[min2];</span><br><span class="line">        newNode-&gt;data = <span class="number">0</span>;  <span class="comment">// 非叶子节点data设为0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新节点数组</span></span><br><span class="line">        nodes[min1] = newNode;</span><br><span class="line">        nodes[min2] = <span class="literal">NULL</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    HuffmanNode *root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="keyword">if</span> (nodes[i] != <span class="literal">NULL</span>) {</span><br><span class="line">            root = nodes[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(nodes);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="哈夫曼编码生成"><a href="#哈夫曼编码生成" class="headerlink" title="哈夫曼编码生成"></a>哈夫曼编码生成</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成哈夫曼编码表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">generateHuffmanCodes</span><span class="params">(HuffmanNode *root, HuffmanCode codes[], <span class="type">char</span> *code, <span class="type">int</span> depth)</span> {</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 叶子节点，保存编码</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) {</span><br><span class="line">        code[depth] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="built_in">strcpy</span>(codes[index].code, code);</span><br><span class="line">        codes[index].data = root-&gt;data;</span><br><span class="line">        index++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左子树编码为0</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>) {</span><br><span class="line">        code[depth] = <span class="string">'0'</span>;</span><br><span class="line">        generateHuffmanCodes(root-&gt;left, codes, code, depth + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 右子树编码为1</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>) {</span><br><span class="line">        code[depth] = <span class="string">'1'</span>;</span><br><span class="line">        generateHuffmanCodes(root-&gt;right, codes, code, depth + <span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="4-完整示例代码"><a href="#4-完整示例代码" class="headerlink" title="4. 完整示例代码"></a>4. 完整示例代码</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> {</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> weight;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">HuffmanNode</span> *<span class="title">left</span>, *<span class="title">right</span>;</span></span><br><span class="line">} HuffmanNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">char</span> code[<span class="number">256</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data;</span><br><span class="line">} HuffmanCode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建哈夫曼树（实现同上）</span></span><br><span class="line">HuffmanNode* <span class="title function_">createHuffmanTree</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> data[], <span class="type">unsigned</span> <span class="type">int</span> weight[], <span class="type">int</span> size)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成哈夫曼编码（实现同上）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">generateHuffmanCodes</span><span class="params">(HuffmanNode *root, HuffmanCode codes[], <span class="type">char</span> *code, <span class="type">int</span> depth)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印哈夫曼编码</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printHuffmanCodes</span><span class="params">(HuffmanCode codes[], <span class="type">int</span> size)</span> {</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Huffman Codes:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c: %s\n"</span>, codes[i].data, codes[i].code);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> {</span><br><span class="line">    <span class="comment">// 示例数据</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> data[] = {<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>};</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> weight[] = {<span class="number">5</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">45</span>};</span><br><span class="line">    <span class="type">int</span> size = <span class="keyword">sizeof</span>(data) / <span class="keyword">sizeof</span>(data[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建哈夫曼树</span></span><br><span class="line">    HuffmanNode *root = createHuffmanTree(data, weight, size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成编码</span></span><br><span class="line">    HuffmanCode codes[size];</span><br><span class="line">    <span class="type">char</span> code[<span class="number">256</span>];</span><br><span class="line">    generateHuffmanCodes(root, codes, code, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印编码</span></span><br><span class="line">    printHuffmanCodes(codes, size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="5-应用场景分析"><a href="#5-应用场景分析" class="headerlink" title="5. 应用场景分析"></a>5. 应用场景分析</h3><p><strong>典型应用</strong>：</p>
<ol>
<li>数据压缩（如ZIP、JPEG等格式）</li>
<li>编码优化（如电报传输）</li>
<li>加密算法中的变长编码</li>
</ol>
<p><strong>性能特点</strong>：</p>
<ul>
<li>压缩效率高，特别是对于非均匀分布的数据</li>
<li>编码解码需要哈夫曼树结构</li>
<li>属于无损压缩算法</li>
</ul>
<h3 id="6-扩展与优化"><a href="#6-扩展与优化" class="headerlink" title="6. 扩展与优化"></a>6. 扩展与优化</h3><p><strong>实际工程中的优化</strong>：</p>
<ol>
<li>使用优先队列（堆）优化最小节点查找</li>
<li>采用规范哈夫曼编码（Canonical Huffman Code）减少存储空间</li>
<li>实现位级操作提高编解码效率</li>
</ol>
<p><strong>带优先队列的优化实现</strong>：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 优先队列实现（最小堆）</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    HuffmanNode **nodes;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">} PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化优先队列</span></span><br><span class="line">PriorityQueue* <span class="title function_">createPriorityQueue</span><span class="params">(<span class="type">int</span> capacity)</span> {</span><br><span class="line">    PriorityQueue *pq = (PriorityQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PriorityQueue));</span><br><span class="line">    pq-&gt;nodes = (HuffmanNode**)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(HuffmanNode*));</span><br><span class="line">    pq-&gt;size = <span class="number">0</span>;</span><br><span class="line">    pq-&gt;capacity = capacity;</span><br><span class="line">    <span class="keyword">return</span> pq;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入节点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(PriorityQueue *pq, HuffmanNode *node)</span> {</span><br><span class="line">    <span class="keyword">if</span> (pq-&gt;size &gt;= pq-&gt;capacity) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    pq-&gt;nodes[pq-&gt;size] = node;</span><br><span class="line">    <span class="type">int</span> i = pq-&gt;size;</span><br><span class="line">    pq-&gt;size++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 上浮调整</span></span><br><span class="line">    <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; pq-&gt;nodes[(i<span class="number">-1</span>)/<span class="number">2</span>]-&gt;weight &gt; pq-&gt;nodes[i]-&gt;weight) {</span><br><span class="line">        HuffmanNode *temp = pq-&gt;nodes[i];</span><br><span class="line">        pq-&gt;nodes[i] = pq-&gt;nodes[(i<span class="number">-1</span>)/<span class="number">2</span>];</span><br><span class="line">        pq-&gt;nodes[(i<span class="number">-1</span>)/<span class="number">2</span>] = temp;</span><br><span class="line">        i = (i<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取最小节点</span></span><br><span class="line">HuffmanNode* <span class="title function_">extractMin</span><span class="params">(PriorityQueue *pq)</span> {</span><br><span class="line">    <span class="keyword">if</span> (pq-&gt;size &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    HuffmanNode *min = pq-&gt;nodes[<span class="number">0</span>];</span><br><span class="line">    pq-&gt;nodes[<span class="number">0</span>] = pq-&gt;nodes[pq-&gt;size<span class="number">-1</span>];</span><br><span class="line">    pq-&gt;size--;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下沉调整</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) {</span><br><span class="line">        <span class="type">int</span> left = <span class="number">2</span>*i + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">2</span>*i + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> smallest = i;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (left &lt; pq-&gt;size &amp;&amp; pq-&gt;nodes[left]-&gt;weight &lt; pq-&gt;nodes[smallest]-&gt;weight)</span><br><span class="line">            smallest = left;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; pq-&gt;size &amp;&amp; pq-&gt;nodes[right]-&gt;weight &lt; pq-&gt;nodes[smallest]-&gt;weight)</span><br><span class="line">            smallest = right;</span><br><span class="line">        <span class="keyword">if</span> (smallest == i) <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        HuffmanNode *temp = pq-&gt;nodes[i];</span><br><span class="line">        pq-&gt;nodes[i] = pq-&gt;nodes[smallest];</span><br><span class="line">        pq-&gt;nodes[smallest] = temp;</span><br><span class="line">        i = smallest;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用优先队列构建哈夫曼树</span></span><br><span class="line">HuffmanNode* <span class="title function_">buildHuffmanTreeWithPQ</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> data[], <span class="type">unsigned</span> <span class="type">int</span> weight[], <span class="type">int</span> size)</span> {</span><br><span class="line">    PriorityQueue *pq = createPriorityQueue(size);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化优先队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        HuffmanNode *node = (HuffmanNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HuffmanNode));</span><br><span class="line">        node-&gt;data = data[i];</span><br><span class="line">        node-&gt;weight = weight[i];</span><br><span class="line">        node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">        insert(pq, node);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建哈夫曼树</span></span><br><span class="line">    <span class="keyword">while</span> (pq-&gt;size &gt; <span class="number">1</span>) {</span><br><span class="line">        HuffmanNode *left = extractMin(pq);</span><br><span class="line">        HuffmanNode *right = extractMin(pq);</span><br><span class="line">        </span><br><span class="line">        HuffmanNode *newNode = (HuffmanNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HuffmanNode));</span><br><span class="line">        newNode-&gt;weight = left-&gt;weight + right-&gt;weight;</span><br><span class="line">        newNode-&gt;left = left;</span><br><span class="line">        newNode-&gt;right = right;</span><br><span class="line">        newNode-&gt;data = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        insert(pq, newNode);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    HuffmanNode *root = extractMin(pq);</span><br><span class="line">    <span class="built_in">free</span>(pq-&gt;nodes);</span><br><span class="line">    <span class="built_in">free</span>(pq);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>


		</div>

		
		<div class="post-copyright-info w-full my-8 px-2 sm:px-6 md:px-8">
			<div class="article-copyright-info-container">
    <ul>
        <li><strong>Title:</strong> Data_structures_BaseDataType</li>
        <li><strong>Author:</strong> Displace</li>
        <li><strong>Created at
                :</strong> 2024-11-28 00:00:00</li>
        
            <li>
                <strong>Updated at
                    :</strong> 2025-04-15 17:02:51
            </li>
        
        <li>
            <strong>Link:</strong> https://mikumikudaifans.github.io/Displace.github.io/2024/11/28/DataStructuresBase/
        </li>
        <li>
            <strong>
                License:
            </strong>
            

            
                This work is licensed under <a class="license" target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0">CC BY-NC-SA 4.0</a>.
            
        </li>
    </ul>
</div>

		</div>
		

		
		<ul class="post-tags-box text-lg mt-1.5 flex-wrap justify-center flex md:hidden">
			
			<li class="tag-item mx-0.5">
				<a href="/tags/Note/">#Note</a>&nbsp;
			</li>
			
		</ul>
		

		

		
		<div class="article-nav my-8 flex justify-between items-center px-2 sm:px-6 md:px-8">
			
			<div class="article-prev border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="prev" rel="prev" href="/2025/01/01/Mathematical_Symbol/">
					<span class="left arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-left"></i>
					</span>
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">MathematicalSymbol</span>
						<span class="post-nav-item">Prev posts</span>
					</span>
				</a>
			</div>
			
			
			<div class="article-next border-border-color shadow-redefine-flat shadow-shadow-color-2 rounded-medium px-4 py-2 hover:shadow-redefine-flat-hover hover:shadow-shadow-color-2">
				<a class="next" rel="next" href="/2024/11/28/DataStructuresAdvance/">
					<span class="title flex justify-center items-center">
						<span class="post-nav-title-item">Data_structures_Algorithms</span>
						<span class="post-nav-item">Next posts</span>
					</span>
					<span class="right arrow-icon flex justify-center items-center">
						<i class="fa-solid fa-chevron-right"></i>
					</span>
				</a>
			</div>
			
		</div>
		


		
		<div class="comment-container px-2 sm:px-6 md:px-8 pb-8">
			<div class="comments-container mt-10 w-full ">
    <div id="comment-anchor" class="w-full h-2.5"></div>
    <div class="comment-area-title w-full my-1.5 md:my-2.5 text-xl md:text-3xl font-bold">
        Comments
    </div>
    

        
            
    <div id="waline"></div>
    <script type="module" data-swup-reload-script>
      import { init } from '/js/libs/waline.mjs';

      function loadWaline() {
        init({
          el: '#waline',
          serverURL: 'https://commentgitalk.vercel.app/',
          lang: 'zh-CN',
          dark: 'body[class~="dark-mode"]',
          reaction: false,
          requiredMeta: ['nick', 'mail'],
          emoji: ['https://unpkg.com/@waline/emojis@1.2.0/soul-emoji'],
          
          
        });
      }

      if (typeof swup !== 'undefined') {
        loadWaline();
      } else {
        window.addEventListener('DOMContentLoaded', loadWaline);
      }
    </script>



        
    
</div>

		</div>
		
	</div>

	
	<div class="toc-content-container">
		<div class="post-toc-wrap">
	<div class="post-toc">
		<div class="toc-title">On this page</div>
		<div class="page-title">Data_structures_BaseDataType</div>
		<ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">1.</span> <span class="nav-text">时间复杂度&amp;空间复杂度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-time-complexity"><span class="nav-number">1.1.</span> <span class="nav-text">时间复杂度(time complexity)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-space-complexity"><span class="nav-number">1.2.</span> <span class="nav-text">空间复杂度(space complexity)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E8%A7%81%E6%83%85%E5%86%B5"><span class="nav-number">1.2.1.</span> <span class="nav-text">常见情况</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">1.2.2.</span> <span class="nav-text">计算空间复杂度的步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">线性表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8-Sequence-List"><span class="nav-number">2.1.</span> <span class="nav-text">顺序表(Sequence List)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E9%9D%99%E6%80%81%E5%AE%9A%E4%B9%89"><span class="nav-number">2.1.1.</span> <span class="nav-text">1. 顺序表的静态定义 :</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E6%8F%92%E5%85%A5"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.插入 :</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%88%A0%E9%99%A4"><span class="nav-number">2.1.3.</span> <span class="nav-text">3.删除 :</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E6%9F%A5%E6%89%BE"><span class="nav-number">2.1.4.</span> <span class="nav-text">4.查找 :</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="nav-number">2.1.5.</span> <span class="nav-text">顺序表总体代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8-Single-Linked-List"><span class="nav-number">2.2.</span> <span class="nav-text">单链表(Single Linked List)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="nav-number">2.2.1.</span> <span class="nav-text">1.创建单链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%A4%B4%E6%8F%92%E6%B3%95%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.2.</span> <span class="nav-text">2.头插法添加节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%B0%BE%E6%8F%92%E6%B3%95%E6%B7%BB%E5%8A%A0%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.3.</span> <span class="nav-text">3.尾插法添加节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%8D%95%E9%93%BE%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="nav-number">2.2.4.</span> <span class="nav-text">5.单链表查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E6%8C%89%E4%BD%8D%E7%BD%AE%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.5.</span> <span class="nav-text">6.按位置插入节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.6.</span> <span class="nav-text">7.单链表删除节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="nav-number">2.2.7.</span> <span class="nav-text">单链表总体代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88-%EF%BC%88Stack%EF%BC%89"><span class="nav-number">3.</span> <span class="nav-text">栈 （Stack）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88-squencial-stack"><span class="nav-number">3.1.</span> <span class="nav-text">顺序栈(squencial stack)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="nav-number">3.1.1.</span> <span class="nav-text">1.顺序栈结构定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%A0%88"><span class="nav-number">3.1.2.</span> <span class="nav-text">2.初始化栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%85%A5%E6%A0%88%E6%93%8D%E4%BD%9C-Push"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.入栈操作(Push)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%87%BA%E6%A0%88%E6%93%8D%E4%BD%9C-Pop"><span class="nav-number">3.1.4.</span> <span class="nav-text">4.出栈操作(Pop)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%AF%BB%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-Peek"><span class="nav-number">3.1.5.</span> <span class="nav-text">5.读取栈顶元素(Peek)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="nav-number">3.1.6.</span> <span class="nav-text">顺序栈总体代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%EF%BC%88Link-Stack"><span class="nav-number">3.2.</span> <span class="nav-text">链栈（Link Stack)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E9%93%BE%E6%A0%88%E5%AE%9A%E4%B9%89"><span class="nav-number">3.2.1.</span> <span class="nav-text">1. 链栈定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%93%BE%E6%A0%88%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">3.2.2.</span> <span class="nav-text">2. 链栈初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%A0%88%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.栈的状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%85%A5%E6%A0%88"><span class="nav-number">3.2.4.</span> <span class="nav-text">4. 入栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E5%87%BA%E6%A0%88"><span class="nav-number">3.2.5.</span> <span class="nav-text">5.出栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-%E8%8E%B7%E5%8F%96%E6%A0%88%E9%A1%B6%E6%95%B0%E6%8D%AE"><span class="nav-number">3.2.6.</span> <span class="nav-text">6. 获取栈顶数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E6%A0%88%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="nav-number">3.2.7.</span> <span class="nav-text">链栈总体代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="nav-number">4.</span> <span class="nav-text">队列（Queue）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF-%E9%A1%BA%E5%BA%8F-%E9%98%9F%E5%88%97-SquenceQueue"><span class="nav-number">4.1.</span> <span class="nav-text">循环(顺序)队列(SquenceQueue)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9B%E5%BB%BA%E9%98%9F%E5%88%97"><span class="nav-number">4.1.1.</span> <span class="nav-text">1. 创建队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E9%98%9F%E5%88%97%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-number">4.1.2.</span> <span class="nav-text">2. 队列初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E5%85%A5%E9%98%9F"><span class="nav-number">4.1.3.</span> <span class="nav-text">3. 入队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%87%BA%E9%98%9F"><span class="nav-number">4.1.4.</span> <span class="nav-text">4. 出队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E6%9F%A5%E7%9C%8B%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0"><span class="nav-number">4.1.5.</span> <span class="nav-text">5. 查看队首元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="nav-number">4.1.6.</span> <span class="nav-text">循环队列总体代码</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E9%98%9F%E5%88%97-LinkQueue"><span class="nav-number">4.2.</span> <span class="nav-text">链队列(LinkQueue)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%9E%84%E5%BB%BA%E9%93%BE%E9%98%9F%E5%88%97"><span class="nav-number">4.2.1.</span> <span class="nav-text">1. 构建链队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E9%98%9F%E5%88%97"><span class="nav-number">4.2.2.</span> <span class="nav-text">1. 初始化链队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%85%A5%E9%98%9F"><span class="nav-number">4.2.3.</span> <span class="nav-text">1. 入队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%87%BA%E9%98%9F"><span class="nav-number">4.2.4.</span> <span class="nav-text">1. 出队</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E6%9F%A5%E7%9C%8B%E9%98%9F%E9%A6%96%E5%85%83%E7%B4%A0"><span class="nav-number">4.2.5.</span> <span class="nav-text">1. 查看队首元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%93%BE%E5%BC%8F%E9%98%9F%E5%88%97%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="nav-number">4.2.6.</span> <span class="nav-text">链式队列总体代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91"><span class="nav-number">5.</span> <span class="nav-text">树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-BinaryTree"><span class="nav-number">5.1.</span> <span class="nav-text">二叉树(BinaryTree)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.1.1.</span> <span class="nav-text">定义二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E6%AC%A1%E5%88%9B%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">5.1.2.</span> <span class="nav-text">层次创建二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="nav-number">5.1.3.</span> <span class="nav-text">先序遍历(深度优先遍历)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">5.1.4.</span> <span class="nav-text">中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">5.1.5.</span> <span class="nav-text">后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">5.1.6.</span> <span class="nav-text">层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86%E6%80%BB%E4%BD%93%E4%BB%A3%E7%A0%81"><span class="nav-number">5.1.7.</span> <span class="nav-text">二叉树创建与遍历总体代码</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E4%B8%8E%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="nav-number">6.</span> <span class="nav-text">哈夫曼树与哈夫曼编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-number">6.1.</span> <span class="nav-text">1. 哈夫曼树基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E6%9E%84%E5%BB%BA%E7%AE%97%E6%B3%95"><span class="nav-number">6.2.</span> <span class="nav-text">2. 哈夫曼树的构建算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-C%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.3.</span> <span class="nav-text">3. C语言实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="nav-number">6.3.1.</span> <span class="nav-text">数据结构定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%9E%84%E5%BB%BA%E5%AE%9E%E7%8E%B0"><span class="nav-number">6.3.2.</span> <span class="nav-text">哈夫曼树构建实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E7%94%9F%E6%88%90"><span class="nav-number">6.3.3.</span> <span class="nav-text">哈夫曼编码生成</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="nav-number">6.4.</span> <span class="nav-text">4. 完整示例代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="nav-number">6.5.</span> <span class="nav-text">5. 应用场景分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E6%89%A9%E5%B1%95%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="nav-number">6.6.</span> <span class="nav-text">6. 扩展与优化</span></a></li></ol></li></ol>

	</div>
</div>
	</div>
	
</div>
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
            <div class="customize-info my-1">你说的对，但是《原神》是由米哈游自主研发的一款全新开放世界冒险游戏。</div>
        
        <div class="text-center">
            &copy;
            
              <span>2022</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart fa-beat" style="--fa-animation-duration: 0.5s; color: #f54545"></i>&nbsp;&nbsp;<a href="/">Displace</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        10 posts in total
                    </span>
                    
                        <span>
                            54k words in total
                        </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">VISITOR COUNT</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">TOTAL PAGE VIEWS</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">POWERED BY <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a></span>
            <span class="text-sm lg:block">THEME&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.2</a></span>
        </div>
        
        
            <div>
                Blog up for <span class="odometer" id="runtime_days" ></span> days <span class="odometer" id="runtime_hours"></span> hrs <span class="odometer" id="runtime_minutes"></span> Min <span class="odometer" id="runtime_seconds"></span> Sec
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
        
    </div>  
</footer>
		</div>
	</div>

	
	<div class="post-tools">
		<div class="post-tools-container">
	<ul class="article-tools-list">
		<!-- TOC aside toggle -->
		
		<li class="right-bottom-tools page-aside-toggle">
			<i class="fa-regular fa-outdent"></i>
		</li>
		

		<!-- go comment -->
		
		<li class="go-comment">
			<i class="fa-regular fa-comments"></i>
		</li>
		
	</ul>
</div>
	</div>
	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	
	<div class="search-pop-overlay">
	<div class="popup search-popup">
		<div class="search-header">
			<span class="search-input-field-pre">
				<i class="fa-solid fa-keyboard"></i>
			</span>
			<div class="search-input-container">
				<input autocomplete="off" autocorrect="off" autocapitalize="off" placeholder="Search..." spellcheck="false" type="search" class="search-input">
			</div>
			<span class="popup-btn-close">
				<i class="fa-solid fa-times"></i>
			</span>
		</div>
		<div id="search-result">
			<div id="no-result">
				<i class="fa-solid fa-spinner fa-spin-pulse fa-5x fa-fw"></i>
			</div>
		</div>
	</div>
</div>
	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>




	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>



    
<script src="/js/build/tools/localSearch.js" type="module"></script>




    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>






    
<script src="/js/build/libs/minimasonry.min.js"></script>

    
<script src="/js/build/plugins/masonry.js" type="module"></script>







    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





    
<script src="/js/build/layouts/bookmarkNav.js" type="module"></script>


	
	<div id="aplayer"></div>

<script src="/js/build/libs/APlayer.min.js"></script>


<script src="/js/build/plugins/aplayer.js"></script>


	
</body>

</html>