<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MachingLearningCodeNote</title>
    <url>/2025/01/01/MachingLearningCodNote/</url>
    <content><![CDATA[<p>MachingLearningCodeNote</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/images/MachingLearningCodNote/CatMikuDemen.png"></p>
]]></content>
      <categories>
        <category>MachingLearning</category>
      </categories>
      <tags>
        <tag>Code</tag>
      </tags>
  </entry>
  <entry>
    <title>Data_structures_Algorithms</title>
    <url>/2024/11/28/DataStructuresAdvance/</url>
    <content><![CDATA[<p>Data_structures_Algorithms</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/images/DataStructuresAdvance/mikucodes.png"></p>
<p>这个可视化网站可极大的降低数据结构学习的难度,再后续遇到逻辑难以相通时可用该网站进行辅助学习 <a class="button  regular" href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html" title="数据结构算法可视化"><i class="fa-solid fa-play-circle"></i> 数据结构算法可视化</a> </p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><h3 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h3><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><h4 id="生成最小树"><a href="#生成最小树" class="headerlink" title="生成最小树"></a>生成最小树</h4><h5 id="普里面姆算法-Prim"><a href="#普里面姆算法-Prim" class="headerlink" title="普里面姆算法(Prim)"></a>普里面姆算法(Prim)</h5><h5 id="克鲁斯卡尔算法"><a href="#克鲁斯卡尔算法" class="headerlink" title="克鲁斯卡尔算法()"></a>克鲁斯卡尔算法()</h5><h4 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h4><h5 id="迪杰斯特拉算法-Dijkstra"><a href="#迪杰斯特拉算法-Dijkstra" class="headerlink" title="迪杰斯特拉算法(Dijkstra)"></a>迪杰斯特拉算法(Dijkstra)</h5><h5 id="弗洛伊德算法-Floyd"><a href="#弗洛伊德算法-Floyd" class="headerlink" title="弗洛伊德算法(Floyd)"></a>弗洛伊德算法(Floyd)</h5><p>啊啊啊</p>
<p>依然是以后再来写,桀桀桀桀桀</p>
<h2 id="串-数组-广义表"><a href="#串-数组-广义表" class="headerlink" title="串,数组,广义表"></a>串,数组,广义表</h2><h3 id="串-String"><a href="#串-String" class="headerlink" title="串(String)"></a>串(String)</h3><h3 id="串匹配算法"><a href="#串匹配算法" class="headerlink" title="串匹配算法"></a>串匹配算法</h3><p>啊吧啊吧啊吧啊吧,不想写力,开摆!!!</p>
<h3 id="数组-Arry"><a href="#数组-Arry" class="headerlink" title="数组(Arry)"></a>数组(Arry)</h3><h3 id="矩阵-Matrix"><a href="#矩阵-Matrix" class="headerlink" title="矩阵(Matrix)"></a>矩阵(Matrix)</h3><h4 id="矩阵的压缩存储"><a href="#矩阵的压缩存储" class="headerlink" title="矩阵的压缩存储"></a>矩阵的压缩存储</h4><h3 id="广义表-Generalized-List"><a href="#广义表-Generalized-List" class="headerlink" title="广义表(Generalized List)"></a>广义表(Generalized List)</h3><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>在正式进行查找算法实现前应先掌握基本的测试工具</p>
<h4 id="1-随机生成数组"><a href="#1-随机生成数组" class="headerlink" title="1. 随机生成数组"></a>1. 随机生成数组</h4><p>用于查找和排序的测试</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">RList</span></span><br><span class="line">{</span><br><span class="line">    ElementType data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机生成数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenerateRandomList</span><span class="params">(RList &amp;list)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++)</span><br><span class="line">    {</span><br><span class="line">        list.data[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line">    list.length = MAX_SIZE;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="2-数组复制"><a href="#2-数组复制" class="headerlink" title="2. 数组复制"></a>2. 数组复制</h4><p>由于此处采用顺序表构造体做为基础创建随机数组,需要将构造体中的数组取出,并赋值到一个新的数组上<br><del>不要问我为什么不直接用数组,我懒得改代码</del></p>
<p><code>memcpy</code> 是 C/C++ 标准库中的一个函数，用于<strong>将一段内存中的数据复制到另一段内存</strong>。它是高效的、适合字节级别复制的操作</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组复制</span></span><br><span class="line"><span class="built_in">memcpy</span>(str, random_list.data, <span class="built_in">sizeof</span>(<span class="type">int</span>) * random_list.length);</span><br><span class="line"><span class="comment">//    (目标地址,源地址         ,单个元素大小  *  元素总数           )</span></span><br></pre></td></tr></table></figure></div>

<p><code>memcpy</code>要求提供分别作为目标和源的两个相同数据类型的组的地址,以及所需内存大小</p>
<h4 id="3-快速排序-Quick-Sort"><a href="#3-快速排序-Quick-Sort" class="headerlink" title="3. 快速排序(Quick Sort)"></a>3. 快速排序(Quick Sort)</h4><p><code>qsort(ElementType arr[], int num_of_elem, int size_of_everyelem, int (*compare)(const void *, const void *));</code>是C内置的快速排序函数</p>
<ul>
<li><code>arr[]</code> 是需要排序的数组。</li>
<li><code>n</code> 是数组的元素个数。</li>
<li><code>sizeof(int)</code> 是每个数组元素的大小（即 <code>size</code> 参数）。</li>
<li><code>compare</code> 是比较函数，它会告诉 <code>qsrot</code> 如何排列数组元素。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* left, <span class="type">const</span> <span class="type">void</span>* right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">//return *(int*)left - *(int*)right; //升序排列</span></span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)right - *(<span class="type">int</span>*)left; <span class="comment">//降序排列</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">qsort</span>(random_list.data, random_list.length,<span class="built_in">sizeof</span>(ElementType),compare);</span><br><span class="line"><span class="comment">//   (数组              ,数组中元素个数      ,每个元素大小         ,排序算法); </span></span><br></pre></td></tr></table></figure></div>

<p>上述代码中的<code>const void* right</code> 表示一个指向 <strong>不可变数据</strong> 的通用指针。它是 C 语言中一种不带类型的指针。</p>
<p>因为 <code>qsort</code> 是一个通用排序函数，它可以排序任何类型的数据（如 <code>int</code>、<code>float</code> 或结构体等），所以 <code>qsort</code> 的比较函数接收的参数类型必须是通用的，即 <code>void*</code>。</p>
<p><code>const</code> 的作用是 <strong>保证数据只读</strong>，即在比较函数中不能修改指针指向的数据。</p>
<p>在正式进行比较时应将其转换为目标数据类型的指针,即使用<code>(int*)right</code></p>
<p><code>*(int*)right</code>的含义为right指针指向的数据,即数组中的一个元素</p>
<h4 id="用于测试查找和排序的随机数组头文件"><a href="#用于测试查找和排序的随机数组头文件" class="headerlink" title="用于测试查找和排序的随机数组头文件"></a>用于测试查找和排序的随机数组头文件</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>SortTest_Header.h </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">RandomList</span></span><br><span class="line">{</span><br><span class="line">    <span class="type">int</span> data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenerateRandomList_head</span><span class="params">(RandomList&amp; list)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++)</span><br><span class="line">    {</span><br><span class="line">        list.data[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line">    list.length = MAX_SIZE;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare_head</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* left, <span class="type">const</span> <span class="type">void</span>* right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)left - *(<span class="type">int</span>*)right; <span class="comment">//升序排列</span></span><br><span class="line">    <span class="comment">//return *(int*)right - *(int*)left; //降序排列</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreatRandomList_head</span><span class="params">(RandomList &amp;random_list)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">GenerateRandomList_head</span>(random_list);</span><br><span class="line">    <span class="type">int</span> str[MAX_SIZE];</span><br><span class="line">    <span class="built_in">memcpy</span>(str, random_list.data, <span class="built_in">sizeof</span>(<span class="type">int</span>) * random_list.length);<span class="comment">//拷贝数组</span></span><br><span class="line">    <span class="comment">//qsort(str, random_list.length, sizeof(int), compare_head); //排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, str[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
              </div>
            </details>   



<h3 id="顺序查找-Sequence-Search"><a href="#顺序查找-Sequence-Search" class="headerlink" title="顺序查找(Sequence Search)"></a>顺序查找(Sequence Search)</h3><p>用于查找数组中指定值的元素的位置，实现算法为基于索引的顺序遍历,该代码在单链表章节已经实现过了，故不在此重复编写</p>
<p>详情请转到  <strong>线性表—顺序表—4.查找</strong>  </p>
<h3 id="折半查找（Binary-Search）"><a href="#折半查找（Binary-Search）" class="headerlink" title="折半查找（Binary Search）"></a>折半查找（Binary Search）</h3><p>折半查找，也称为<strong>二分查找</strong>，是一种在有序数组中查找目标值的算法。其核心思想是每次将查找范围缩小一半，直至找到目标值或确认目标值不存在</p>
<p><strong>前提</strong>：数组必须是<strong>有序</strong>的（升序或降序）。</p>
<p><strong>时间复杂度</strong>：</p>
<ul>
<li>最坏情况下：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.682ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3837.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="msub" transform="translate(1935,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mi" transform="translate(2848.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3448.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></li>
<li>最好情况下：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></li>
</ul>
<h4 id="折半查找的步骤"><a href="#折半查找的步骤" class="headerlink" title="折半查找的步骤"></a>折半查找的步骤</h4><ol>
<li>设定<strong>初始范围</strong>，定义两个指针 <code>low</code>（范围起始索引）和 <code>high</code>（范围结束索引）。</li>
<li>计算<strong>中间索引</strong> <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="23.615ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 10438 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(878,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(1223,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mo" transform="translate(2020.8,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mo" transform="translate(3076.6,0)"><path data-c="230A" d="M174 734Q174 735 175 737T177 740T180 744T184 747T189 749T196 750Q206 748 214 735V-210H310H373Q401 -210 411 -213T422 -230T411 -247T369 -251Q362 -251 338 -251T298 -250H190Q178 -246 174 -234V734Z"></path></g><g data-mml-node="mo" transform="translate(3520.6,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(3909.6,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(4207.6,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(4692.6,0)"><path data-c="1D464" d="M580 385Q580 406 599 424T641 443Q659 443 674 425T690 368Q690 339 671 253Q656 197 644 161T609 80T554 12T482 -11Q438 -11 404 5T355 48Q354 47 352 44Q311 -11 252 -11Q226 -11 202 -5T155 14T118 53T104 116Q104 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Q21 293 29 315T52 366T96 418T161 441Q204 441 227 416T250 358Q250 340 217 250T184 111Q184 65 205 46T258 26Q301 26 334 87L339 96V119Q339 122 339 128T340 136T341 143T342 152T345 165T348 182T354 206T362 238T373 281Q402 395 406 404Q419 431 449 431Q468 431 475 421T483 402Q483 389 454 274T422 142Q420 131 420 107V100Q420 85 423 71T442 42T487 26Q558 26 600 148Q609 171 620 213T632 273Q632 306 619 325T593 357T580 385Z"></path></g><g data-mml-node="mo" transform="translate(5630.8,0)"><path data-c="2B" d="M56 237T56 250T70 270H369V420L370 570Q380 583 389 583Q402 583 409 568V270H707Q722 262 722 250T707 230H409V-68Q401 -82 391 -82H389H387Q375 -82 369 -68V230H70Q56 237 56 250Z"></path></g><g data-mml-node="mi" transform="translate(6631,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mi" transform="translate(7207,0)"><path data-c="1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(7552,0)"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mi" transform="translate(8029,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mo" transform="translate(8605,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(8994,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(9494,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(9994,0)"><path data-c="230B" d="M229 734Q229 735 230 737T232 740T235 744T239 747T244 749T251 750Q262 748 269 735V-235Q266 -240 256 -249L147 -250H77Q43 -250 32 -247T21 -230T32 -213T72 -209Q79 -209 99 -209T133 -210H229V734Z"></path></g></g></g></svg></mjx-container></li>
<li>比较中间值：<ul>
<li>如果目标值等于中间值，则查找成功。</li>
<li>如果目标值小于中间值，则将 <code>high</code> 移动到 <code>mid - 1</code>，缩小范围到左半部分。</li>
<li>如果目标值大于中间值，则将 <code>low</code> 移动到 <code>mid + 1</code>，缩小范围到右半部分。</li>
</ul>
</li>
<li>重复以上步骤，直至找到目标值或 <code>low &gt; high</code>（表示目标值不存在）。</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//二分查找(折半查找)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(RList list, ElementType target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span> , high = list.length - <span class="number">1</span> , mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) <span class="comment">//确保在循环到仅剩三个元素时仍会对mid=low的情况进行判断</span></span><br><span class="line">    {</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>; <span class="comment">//mid为中间位置，当low=high时，mid=low ，除法默认为整除，当low+hight为奇数时，结果向下取整</span></span><br><span class="line">        <span class="keyword">if</span> (list.data[mid] == target)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list.data[mid] &lt; target)</span><br><span class="line">        {</span><br><span class="line">            low = mid + <span class="number">1</span>;<span class="comment">//目标值在list.data[mid]的右半部分</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            high = mid - <span class="number">1</span>;<span class="comment">//目标值在list.data[mid]的左半部分</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="折半查找总体代码"><a href="#折半查找总体代码" class="headerlink" title="折半查找总体代码"></a>折半查找总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>折半查找 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">RList</span></span><br><span class="line">{</span><br><span class="line">    ElementType data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机生成数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenerateRandomList</span><span class="params">(RList &amp;list)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++)</span><br><span class="line">    {</span><br><span class="line">        list.data[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line">    list.length = MAX_SIZE;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(RList list)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; list.length; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"data[%d] : %d |  "</span>, i,list.data[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"length : %d\n"</span>, list.length);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找(折半查找)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch</span><span class="params">(RList list, ElementType target)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span> , high = list.length - <span class="number">1</span> , mid;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) <span class="comment">//确保在循环到仅剩三个元素时仍会对mid=low的情况进行判断</span></span><br><span class="line">    {</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>; <span class="comment">//mid为中间位置，当low=high时，mid=low ，除法默认为整除，当low+hight为奇数时，结果向下取整</span></span><br><span class="line">        <span class="keyword">if</span> (list.data[mid] == target)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (list.data[mid] &lt; target)</span><br><span class="line">        {</span><br><span class="line">            low = mid + <span class="number">1</span>;<span class="comment">//目标值在list.data[mid]的右半部分</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            high = mid - <span class="number">1</span>;<span class="comment">//目标值在list.data[mid]的左半部分</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* left, <span class="type">const</span> <span class="type">void</span>* right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)left - *(<span class="type">int</span>*)right;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RList random_list;</span><br><span class="line">    <span class="comment">//random_list.data[0]= -1;</span></span><br><span class="line">    <span class="built_in">GenerateRandomList</span>(random_list);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Random List:\n"</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(random_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//快速排序库函数qsrot(Quick Sort)</span></span><br><span class="line">    <span class="built_in">qsort</span>(random_list.data, random_list.length,<span class="built_in">sizeof</span>(ElementType),compare);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Sorted List:\n"</span>);</span><br><span class="line">    <span class="built_in">PrintList</span>(random_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="type">int</span> target;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter the target value to search: "</span>);</span><br><span class="line">    <span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;target);</span><br><span class="line">    <span class="type">int</span> index = <span class="built_in">BinarySearch</span>(random_list, target);</span><br><span class="line">    <span class="keyword">if</span> (index == <span class="number">-1</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Not found!\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Found at order %d!\n"</span>, index);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>



<hr>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><h3 id="二叉排序树-BinarySortTree"><a href="#二叉排序树-BinarySortTree" class="headerlink" title="二叉排序树(BinarySortTree)"></a>二叉排序树(BinarySortTree)</h3><p>二叉排序树是一棵二叉树，满足以下性质：</p>
<ol>
<li>每个节点的值大于其左子树中所有节点的值。</li>
<li>每个节点的值小于其右子树中所有节点的值。</li>
<li>每个子树本身也是一棵二叉排序树。</li>
</ol>
<h4 id="创建和插入"><a href="#创建和插入" class="headerlink" title="创建和插入"></a>创建和插入</h4><h5 id="1-创建"><a href="#1-创建" class="headerlink" title="1. 创建"></a>1. 创建</h5><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBST</span><span class="params">(BST&amp; root, KeyType str[], <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">InsertBST</span>(root, str[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="2-1-常规循环插入"><a href="#2-1-常规循环插入" class="headerlink" title="2.1 常规循环插入"></a>2.1 常规循环插入</h5><p>根据目标值与当前节点的比较：</p>
<ul>
<li>如果目标值小于当前节点值，递归插入到左子树。</li>
<li>如果目标值大于当前节点值，递归插入到右子树。</li>
</ul>
<p>插入时保持二叉排序树的性质。</p>
<p><strong>时间复杂度</strong>：<mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.79ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2117 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="210E" d="M137 683Q138 683 209 688T282 694Q294 694 294 685Q294 674 258 534Q220 386 220 383Q220 381 227 388Q288 442 357 442Q411 442 444 415T478 336Q478 285 440 178T402 50Q403 36 407 31T422 26Q450 26 474 56T513 138Q516 149 519 151T535 153Q555 153 555 145Q555 144 551 130Q535 71 500 33Q466 -10 419 -10H414Q367 -10 346 17T325 74Q325 90 361 192T398 345Q398 404 354 404H349Q266 404 205 306L198 293L164 158Q132 28 127 16Q114 -11 83 -11Q69 -11 59 -2T48 16Q48 30 121 320L195 616Q195 629 188 632T149 637H128Q122 643 122 645T124 664Q129 683 137 683Z"></path></g><g data-mml-node="mo" transform="translate(1728,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InsertBST</span><span class="params">(BST&amp; root, KeyType key_new)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        root = (BST)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BinarySortTreeNode));</span><br><span class="line">        root -&gt; key = key_new;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//第一个节点插入成功</span></span><br><span class="line">    }</span><br><span class="line">    BST p = root;<span class="comment">//p用于遍历树</span></span><br><span class="line">    BST parent = <span class="literal">NULL</span>;<span class="comment">//用于储存目标节点的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (p) <span class="comment">//当p不为空时,执行循环,为空时中断</span></span><br><span class="line">    {</span><br><span class="line">        parent = p;</span><br><span class="line">        <span class="keyword">if</span> (key_new == p-&gt;key)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//节点已存在,插入失败</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key_new &lt; p-&gt;key)</span><br><span class="line">        {</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        }    </span><br><span class="line">    }<span class="comment">//在循环结束时,parent指向p应进入的叶子节点的父节点</span></span><br><span class="line">    BST pnew = (BST)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BinarySortTreeNode));</span><br><span class="line">    pnew-&gt;key = key_new;</span><br><span class="line">    <span class="keyword">if</span> (pnew-&gt;key &lt; parent-&gt;key)</span><br><span class="line">    {</span><br><span class="line">        parent-&gt;left = pnew;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        parent-&gt;right = pnew;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//插入成功    </span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h5 id="2-2-递归插入"><a href="#2-2-递归插入" class="headerlink" title="2.2 递归插入"></a>2.2 递归插入</h5><p><strong>递归基准条件</strong>：</p>
<ul>
<li>如果当前节点为空（<code>NULL</code>），则新节点应该插入到此处。</li>
</ul>
<p><strong>递归逻辑</strong>：</p>
<ul>
<li>如果插入值小于当前节点值，递归处理左子树。</li>
<li>如果插入值大于当前节点值，递归处理右子树。</li>
<li>如果插入值等于当前节点值，视为重复值，通常忽略或返回。</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>每次递归调用返回当前节点指针，以确保树结构能够正确链接。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归插入节点</span></span><br><span class="line"><span class="function">BST <span class="title">InsertBST_recursion</span><span class="params">(BST &amp;root, KeyType key_new)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">//将root作为递归遍历的核心节点,携带着key_new持续递归遍历到树底部,最后root为空则创建节点并放入key_new</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        root = (BST)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BinarySortTreeNode));</span><br><span class="line">        root -&gt; key = key_new;</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">//第一个节点插入成功</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key_new &lt; root-&gt;key)</span><br><span class="line">    {</span><br><span class="line">        root-&gt;left = <span class="built_in">InsertBST_recursion</span>(root-&gt;left, key_new);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        root-&gt;right = <span class="built_in">InsertBST_recursion</span>(root-&gt;right, key_new);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">//插入成功 </span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h4><p>按二叉排序树规则遍历查找</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_BST</span><span class="params">(BST root, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    KeyType p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> &amp;&amp; root-&gt;key != key)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">        {</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        }</span><br><span class="line">    }<span class="comment">//循环结束时,root指向目标节点或NULL</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"未找到节点: %d\n"</span>, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//未找到</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"找到节点: %d\n"</span>, root-&gt;key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//找到</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><h5 id="1-查找目标节点"><a href="#1-查找目标节点" class="headerlink" title="1. 查找目标节点"></a>1. 查找目标节点</h5><p>通过递归，根据二叉排序树的性质（左子树小于根，右子树大于根）：</p>
<ul>
<li>如果目标值小于当前节点值，递归到左子树。</li>
<li>如果目标值大于当前节点值，递归到右子树。</li>
<li>如果相等，找到了需要删除的目标节点。</li>
</ul>
<h5 id="2-分类讨论删除目标节点"><a href="#2-分类讨论删除目标节点" class="headerlink" title="2.分类讨论删除目标节点"></a>2.分类讨论删除目标节点</h5><p>根据目标节点的左右子树情况分为三种情况：</p>
<p><strong>(1) 目标节点为叶子节点（没有左右子树）</strong></p>
<ul>
<li>直接删除节点，并将父节点指向它的指针设置为 <code>NULL</code>。</li>
<li><strong>代码体现</strong>：目标节点被替换为空（<code>root = NULL;</code>），然后释放该节点。</li>
</ul>
<p><strong>(2) 目标节点只有一棵子树</strong></p>
<ul>
<li><p>如果目标节点只有左子树或只有右子树：</p>
<ul>
<li>用它的唯一子树替代它的位置。</li>
<li>将当前节点的指针更新为左子树或右子树，最后释放当前节点。</li>
</ul>
</li>
<li><p>代码体现：</p>
<ul>
<li>如果 <code>root-&gt;left == NULL</code>，则 <code>root = root-&gt;right;</code>。</li>
</ul>
</li>
<li><p>如果 <code>root-&gt;right == NULL</code>，则 <code>root = root-&gt;left;</code>。</p>
</li>
</ul>
<p><strong>(3) 目标节点有两棵子树</strong></p>
<ul>
<li><p>找到替换节点：</p>
<ul>
<li><strong>右子树中的最小节点</strong>，或</li>
<li><strong>左子树中的最大节点</strong>。</li>
</ul>
</li>
<li><p>用替换节点的值覆盖目标节点的值。</p>
</li>
<li><p>在对应的子树中递归删除替换节点。</p>
</li>
<li><p>代码体现：</p>
<ul>
<li>找到右子树中的最小节点：从 <code>root-&gt;right</code> 开始，向左寻找直到 <code>temp-&gt;left == NULL</code>。</li>
</ul>
</li>
<li><p>覆盖值后递归调用删除函数。</p>
</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteBST</span><span class="params">(BST&amp; root, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="comment">//树为空或树中无此节点递归查找目标节点失败</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DeleteBST</span>(root-&gt;left, key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DeleteBST</span>(root-&gt;right, key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//找到了目标节点</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>)<span class="comment">//目标节点是叶子节点且只有右子树</span></span><br><span class="line">        {           </span><br><span class="line">            BST temp = root;<span class="comment">//temp指针保存待指向删除节点的指针</span></span><br><span class="line">            root = root-&gt;right;<span class="comment">//root指针被修改为待指向删除节点的右子树</span></span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>)<span class="comment">//目标节点是叶子节点且只有左子树</span></span><br><span class="line">        {</span><br><span class="line">            BST temp = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//目标节点既有左子树又有右子树</span></span><br><span class="line">        <span class="comment">//此时删除目标节点后需用右子树中的最小节点替换目标节点,或用左子树中的最大节点替换目标节点</span></span><br><span class="line">        <span class="comment">//在操作层面体现为将替换节点移动到目标节点的位置然后删除替换节点</span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//右子树中的最小节点替换       </span></span><br><span class="line">        {</span><br><span class="line">         </span><br><span class="line">            BST temp = root-&gt;right;<span class="comment">//temp指针保存指向目标节点的右子树</span></span><br><span class="line">            <span class="keyword">while</span> (temp-&gt;left != <span class="literal">NULL</span>)<span class="comment">//找到右子树中的最小节点</span></span><br><span class="line">            {</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            root-&gt;key = temp-&gt;key;<span class="comment">//将待删除节点的右子树中的最小节点的值赋给待删除节点</span></span><br><span class="line">            <span class="built_in">DeleteBST</span>(root-&gt;right, temp-&gt;key);<span class="comment">//删除右子树中的最小节点</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//else//左子树中的最大节点替换</span></span><br><span class="line">        <span class="comment">//{</span></span><br><span class="line">        <span class="comment">//    BST temp = root-&gt;left;//temp指针保存待指向删除节点的左子树</span></span><br><span class="line">        <span class="comment">//    while (temp-&gt;right != NULL)//找到左子树中的最大节点</span></span><br><span class="line">        <span class="comment">//    {</span></span><br><span class="line">        <span class="comment">//        temp = temp-&gt;right;</span></span><br><span class="line">        <span class="comment">//    }</span></span><br><span class="line">        <span class="comment">//    root-&gt;key = temp-&gt;key;//将待删除节点的左子树中的最大节点的值赋给待删除节点</span></span><br><span class="line">        <span class="comment">//    DeleteBST(root-&gt;left, temp-&gt;key);//删除左子树中的最大节点</span></span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//删除成功</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>





<h4 id="二叉排序树总体代码"><a href="#二叉排序树总体代码" class="headerlink" title="二叉排序树总体代码"></a>二叉排序树总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>二叉排序树 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"C_L_Header.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BinarySortTreeNode</span></span><br><span class="line">{</span><br><span class="line">    KeyType key;</span><br><span class="line">    BinarySortTreeNode* left;</span><br><span class="line">    BinarySortTreeNode* right;</span><br><span class="line">}*BST;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">RList</span></span><br><span class="line">{</span><br><span class="line">    KeyType data[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">};</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GenerateRandomList_T</span><span class="params">(RList&amp; list)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++)</span><br><span class="line">    {</span><br><span class="line">        list.data[i] = <span class="built_in">rand</span>() % <span class="number">100</span>;</span><br><span class="line">    }</span><br><span class="line">    list.length = MAX_SIZE;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//比较函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare_T</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* left, <span class="type">const</span> <span class="type">void</span>* right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> *(<span class="type">int</span>*)left - *(<span class="type">int</span>*)right; <span class="comment">//升序排列</span></span><br><span class="line">    <span class="comment">//return *(int*)right - *(int*)left; //降序排列</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//递归插入节点</span></span><br><span class="line"><span class="function">BST <span class="title">InsertBST_recursion</span><span class="params">(BST &amp;root, KeyType key_new)</span></span></span><br><span class="line"><span class="function"></span>{<span class="comment">//将root作为递归遍历的核心节点,携带着key_new持续递归遍历到树底部,最后root为空则创建节点并放入key_new</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        root = (BST)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BinarySortTreeNode));</span><br><span class="line">        root -&gt; key = key_new;</span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">//第一个节点插入成功</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key_new &lt; root-&gt;key)</span><br><span class="line">    {</span><br><span class="line">        root-&gt;left = <span class="built_in">InsertBST_recursion</span>(root-&gt;left, key_new);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        root-&gt;right = <span class="built_in">InsertBST_recursion</span>(root-&gt;right, key_new);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root; <span class="comment">//插入成功 </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//插入节点</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InsertBST</span><span class="params">(BST&amp; root, KeyType key_new)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        root = (BST)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BinarySortTreeNode));</span><br><span class="line">        root -&gt; key = key_new;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//第一个节点插入成功</span></span><br><span class="line">    }</span><br><span class="line">    BST p = root;<span class="comment">//p用于遍历树</span></span><br><span class="line">    BST parent = <span class="literal">NULL</span>;<span class="comment">//用于储存目标节点的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (p) <span class="comment">//当p不为空时,执行循环,为空时中断</span></span><br><span class="line">    {</span><br><span class="line">        parent = p;</span><br><span class="line">        <span class="keyword">if</span> (key_new == p-&gt;key)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//节点已存在,插入失败</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (key_new &lt; p-&gt;key)</span><br><span class="line">        {</span><br><span class="line">            p = p-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            p = p-&gt;right;</span><br><span class="line">        }    </span><br><span class="line">    }<span class="comment">//在循环结束时,parent指向p应进入的叶子节点的父节点</span></span><br><span class="line">    BST pnew = (BST)<span class="built_in">calloc</span>(<span class="number">1</span>,<span class="built_in">sizeof</span>(<span class="keyword">struct</span> BinarySortTreeNode));</span><br><span class="line">    pnew-&gt;key = key_new;</span><br><span class="line">    <span class="keyword">if</span> (pnew-&gt;key &lt; parent-&gt;key)</span><br><span class="line">    {</span><br><span class="line">        parent-&gt;left = pnew;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        parent-&gt;right = pnew;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//插入成功    </span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建二叉排序树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateBST</span><span class="params">(BST&amp; root, KeyType str[], <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    root = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//InsertBST(root, str[i]);</span></span><br><span class="line">        <span class="built_in">InsertBST_recursion</span>(root, str[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Search_BST</span><span class="params">(BST root, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    KeyType p = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">NULL</span> &amp;&amp; root-&gt;key != key)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">        {</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        }</span><br><span class="line">    }<span class="comment">//循环结束时,root指向目标节点或NULL</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"未找到节点: %d\n"</span>, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//未找到</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"找到节点: %d\n"</span>, root-&gt;key);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//找到</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeleteBST</span><span class="params">(BST&amp; root, KeyType key)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)<span class="comment">//树为空或树中无此节点递归查找目标节点失败</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"未找到节点: %d\n"</span>, key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (key &lt; root-&gt;key)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DeleteBST</span>(root-&gt;left, key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; root-&gt;key)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">DeleteBST</span>(root-&gt;right, key);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//找到了目标节点</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span>)<span class="comment">//目标节点是叶子节点且只有右子树</span></span><br><span class="line">        {           </span><br><span class="line">            BST temp = root;<span class="comment">//temp指针保存待指向删除节点的指针</span></span><br><span class="line">            root = root-&gt;right;<span class="comment">//root指针被修改为待指向删除节点的右子树</span></span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right == <span class="literal">NULL</span>)<span class="comment">//目标节点是叶子节点且只有左子树</span></span><br><span class="line">        {</span><br><span class="line">            BST temp = root;</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">            <span class="built_in">free</span>(temp);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//目标节点既有左子树又有右子树</span></span><br><span class="line">        <span class="comment">//此时删除目标节点后需用右子树中的最小节点替换目标节点,或用左子树中的最大节点替换目标节点</span></span><br><span class="line">        <span class="comment">//在操作层面体现为将替换节点移动到目标节点的位置然后删除替换节点</span></span><br><span class="line">        <span class="keyword">else</span><span class="comment">//右子树中的最小节点替换       </span></span><br><span class="line">        {</span><br><span class="line">         </span><br><span class="line">            BST temp = root-&gt;right;<span class="comment">//temp指针保存指向目标节点的右子树</span></span><br><span class="line">            <span class="keyword">while</span> (temp-&gt;left != <span class="literal">NULL</span>)<span class="comment">//找到右子树中的最小节点</span></span><br><span class="line">            {</span><br><span class="line">                temp = temp-&gt;left;</span><br><span class="line">            }</span><br><span class="line">            root-&gt;key = temp-&gt;key;<span class="comment">//将待删除节点的右子树中的最小节点的值赋给待删除节点</span></span><br><span class="line">            <span class="built_in">DeleteBST</span>(root-&gt;right, temp-&gt;key);<span class="comment">//删除右子树中的最小节点</span></span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//else//左子树中的最大节点替换</span></span><br><span class="line">        <span class="comment">//{</span></span><br><span class="line">        <span class="comment">//    BST temp = root-&gt;left;//temp指针保存待指向删除节点的左子树</span></span><br><span class="line">        <span class="comment">//    while (temp-&gt;right != NULL)//找到左子树中的最大节点</span></span><br><span class="line">        <span class="comment">//    {</span></span><br><span class="line">        <span class="comment">//        temp = temp-&gt;right;</span></span><br><span class="line">        <span class="comment">//    }</span></span><br><span class="line">        <span class="comment">//    root-&gt;key = temp-&gt;key;//将待删除节点的左子树中的最大节点的值赋给待删除节点</span></span><br><span class="line">        <span class="comment">//    DeleteBST(root-&gt;left, temp-&gt;key);//删除左子树中的最大节点</span></span><br><span class="line">        <span class="comment">//}</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//删除成功</span></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印树状二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintTree_T</span><span class="params">(BST root, <span class="type">const</span> <span class="type">char</span>* prefix, <span class="type">int</span> isLeft)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, prefix);</span><br><span class="line">    <span class="built_in">printf</span>(isLeft ? <span class="string">"├── "</span> : <span class="string">"└── "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, root-&gt;key);</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> newPrefix[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(newPrefix, <span class="built_in">sizeof</span>(newPrefix), <span class="string">"%s%s"</span>, prefix, isLeft ? <span class="string">"│   "</span> : <span class="string">"    "</span>);</span><br><span class="line">    <span class="built_in">PrintTree_T</span>(root-&gt;right, newPrefix, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">PrintTree_T</span>(root-&gt;left, newPrefix, <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉排序树的中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderTraversal_T</span><span class="params">(BST root, RList&amp; list)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">InorderTraversal_T</span>(root-&gt;left, list);</span><br><span class="line">    list.data[list.length++] = root-&gt;key;</span><br><span class="line">    <span class="built_in">InorderTraversal_T</span>(root-&gt;right, list);</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    RList random_list;</span><br><span class="line">    <span class="built_in">GenerateRandomList_T</span>(random_list);</span><br><span class="line"></span><br><span class="line">    KeyType str[MAX_SIZE];</span><br><span class="line">    <span class="built_in">memcpy</span>(str, random_list.data, <span class="built_in">sizeof</span>(KeyType) * random_list.length);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAX_SIZE; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, str[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    BST root;<span class="comment">//创建树根  </span></span><br><span class="line">    <span class="built_in">CreateBST</span>(root, str, MAX_SIZE);</span><br><span class="line">    <span class="comment">// 打印树状结构</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树状打印结果:\n"</span>);</span><br><span class="line">    <span class="built_in">PrintTree_T</span>(root, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    RList inorder_list;</span><br><span class="line">    inorder_list.length = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">InorderTraversal_T</span>(root, inorder_list);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"root中序遍历结果:\n"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder_list.length; i++)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, inorder_list.data[i]);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> s_bst;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入查找的节点: "</span>);</span><br><span class="line">    <span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;s_bst);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Search_BST</span>(root, s_bst);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> d_bst;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入删除的节点: "</span>);</span><br><span class="line">    <span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;d_bst);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeleteBST</span>(root, d_bst);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除节点后树状打印结果:\n"</span>);</span><br><span class="line">    <span class="built_in">PrintTree_T</span>(root, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h3><p>冒泡排序是一种基础的排序算法，通过多次比较和交换相邻元素，将数组中最大（或最小）的元素逐步“冒泡”到数组的一端，直至整个数组有序</p>
<h4 id="1-外层循环"><a href="#1-外层循环" class="headerlink" title="1. 外层循环"></a>1. 外层循环</h4><ul>
<li>控制需要进行排序的范围（即已排序部分的长度）</li>
<li>每循环一次就会有一个最小的数冒泡到数组最右边,循环到index-1时仅剩最后两个元素,他们比较完成时数组就有序了,故最多需要 <code>n-1</code> 次（对于长度为 <code>n</code> 的数组）</li>
</ul>
<h4 id="2-内层循环"><a href="#2-内层循环" class="headerlink" title="2. 内层循环"></a><strong>2. 内层循环</strong></h4><ul>
<li>完成一次冒泡操作，将当前范围内的最小元素移动到数组开头</li>
<li>由于从末尾取数向前比较,因此只需比较<code>n-1</code>次,故循环<code>n-1</code>次</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//交换两个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> index = n - <span class="number">1</span>;<span class="comment">//设置数组最后一个元素的索引</span></span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; index ;i++) <span class="comment">//每循环一次就会有一个最大的数冒泡到数组最右边,循环到index-1时仅剩最后两个元素,他们比较完成时数组就有序了</span></span><br><span class="line">	{</span><br><span class="line">		flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = index ;j &gt; <span class="number">0</span>; j--)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) <span class="comment">//改变符号即可实现倒叙</span></span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">swap</span>(arr[j], arr[j - <span class="number">1</span>]);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (!flag) <span class="comment">//如果没有发生交换,说明数组已经有序,可以提前结束循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h3 id="插入排序-Insert-Sort"><a href="#插入排序-Insert-Sort" class="headerlink" title="插入排序(Insert Sort)"></a>插入排序(Insert Sort)</h3><p><strong>初始化：</strong></p>
<ul>
<li>从数组的第二个元素开始，因为一个元素自燃有序。</li>
<li>每次取出一个新的元素，插入到已经排序好的部分中。</li>
</ul>
<p><strong>外层循环（逐步扩展有序部分）：</strong></p>
<ul>
<li><code>i</code> 从 1 到 <code>n-1</code>，<code>i</code> 表示当前待插入元素的位置，逐步扩展已排序部分。</li>
<li><code>insertValue = arr[i]</code>，将当前待插入的元素存储在 <code>insertValue</code> 中。</li>
</ul>
<p><strong>内层循环（查找插入位置）：</strong></p>
<ul>
<li><p>内层循环通过 <code>j</code> 向前查找 <code>insertValue</code> 应插入的位置。</p>
</li>
<li><p>如果 <code>arr[j]</code> 大于 <code>insertValue</code>，则将 <code>arr[j]</code> 后移一位，即 <code>arr[j + 1] = arr[j]</code>。</p>
</li>
<li><p>循环会持续进行，直到找到一个不大于 <code>insertValue</code> 的位置，或者已经到达数组的起始位置。</p>
</li>
<li><p><code>j&gt;=0 </code>确保了会对第一个元素进行判别,</p>
<p>如果比第一个元素小,此时j=-1,在插入值进行覆盖操作时会覆盖在<code>arr[0]</code>的位置</p>
</li>
</ul>
<p><strong>插入元素：</strong></p>
<ul>
<li>插入值前的数组元素在大于插入值的前提下向后覆盖,直到不大于插入值时退出循环并将插入值覆盖在<code>j+1</code>处,因为每次循环覆盖后<code>j</code>先前移并指向未曾判别的元素,而<code>j</code>到了小于插入值元素时才会触发循环中断,此时目标位置在<code>j</code>前一位</li>
<li>插入 <code>insertValue</code>，即 <code>arr[j + 1] = insertValue</code>。</li>
</ul>
<p><strong>重复过程：</strong></p>
<ul>
<li>外层循环继续，直到所有元素都插入到合适的位置。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; n ;i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> insertValue = arr[i]; <span class="comment">//每次从未排序的数组中取出第一个元素</span></span><br><span class="line">		<span class="keyword">for</span> (j = i - <span class="number">1</span>; arr[j] &gt; insertValue &amp;&amp; j &gt;= <span class="number">0</span>; j--)  <span class="comment">//</span></span><br><span class="line">		{</span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[j]; <span class="comment">//将大于insertValue的元素后移一位</span></span><br><span class="line">		}</span><br><span class="line">		arr[j + <span class="number">1</span>] = insertValue; <span class="comment">//将insertValue插入到正确的位置</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h3><h4 id="1-选择基准元素（Pivot）"><a href="#1-选择基准元素（Pivot）" class="headerlink" title="1. 选择基准元素（Pivot）"></a>1. <strong>选择基准元素（Pivot）</strong></h4><ul>
<li>你在 <code>Partition</code> 函数中选择数组的第一个元素 <code>A[left]</code> 作为基准元素。你也可以选择其他策略来选择基准元素（例如随机选择或者选择中位数等）。</li>
</ul>
<h4 id="2-分区操作"><a href="#2-分区操作" class="headerlink" title="2. 分区操作"></a>2. <strong>分区操作</strong></h4><p><code>Partition</code>函数的目标是将数组分成两部分，使得：</p>
<ul>
<li><p>左侧部分的所有元素都小于等于基准元素。</p>
</li>
<li><p>右侧部分的所有元素都大于等于基准元素。</p>
</li>
<li><p>具体过程：</p>
<ul>
<li>设置 <code>pivot</code> 为 <code>A[left]</code>（即基准元素）。</li>
<li>使用两个指针：<code>left</code> 和 <code>right</code>，从两端开始，逐渐向中间逼近。</li>
<li>移动 <code>right</code> 指针，直到找到一个小于 <code>pivot</code> 的元素。</li>
<li>移动 <code>left</code> 指针，直到找到一个大于 <code>pivot</code> 的元素。</li>
<li>如果 <code>left &lt; right</code>，交换这两个元素。</li>
<li>重复以上过程，直到 <code>left == right</code>，此时基准元素的位置已经确定，返回该位置。</li>
</ul>
<p>在循环流程中,right值会最先替换掉第一个left值,在这之后是left值替换right值,,再次循环到right值判断时替换的一定是上一次总循环中被选定的left值,,再次循环到left值判断时替换的一定是上一次总循环中被选定的right值,</p>
<p>循环到left = right 时 left和right指向的值一定是上一次总循环中选定的left/right值,也意味着它在当前数组总存在复制体,此时用pivot对齐进行替换</p>
</li>
</ul>
<h4 id="3-递归排序左右子数组"><a href="#3-递归排序左右子数组" class="headerlink" title="3. 递归排序左右子数组"></a>3. <strong>递归排序左右子数组</strong></h4><p>  <code>QuickSort</code>函数会对基准元素两侧的子数组递归地进行排序。</p>
<ul>
<li>在 <code>Partition</code> 完成后，返回基准元素的索引 <code>pivot</code>，此时 <code>arr[pivot]</code> 就是排好序的元素。</li>
<li>然后，分别对基准元素左边（<code>arr[left, pivot-1]</code>）和右边（<code>arr[pivot+1, right]</code>）的子数组递归调用 <code>QuickSort</code>。</li>
</ul>
<h4 id="4-递归终止条件"><a href="#4-递归终止条件" class="headerlink" title="4. 递归终止条件"></a>4. <strong>递归终止条件</strong></h4><ul>
<li>当子数组的大小小于或等于 1 时，递归终止，因为此时数组已经有序。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//快速排序的分区函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> pivot = A[left];<span class="comment">//选取第一个元素作为pivot</span></span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; A[right] &gt;= pivot)</span><br><span class="line">			right--;</span><br><span class="line">		A[left] = A[right];</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; A[left] &lt;= pivot)</span><br><span class="line">			left++;</span><br><span class="line">		A[right] = A[left];</span><br><span class="line">	}</span><br><span class="line">	A[left] = pivot;</span><br><span class="line">	<span class="keyword">return</span> right; <span class="comment">//返回pivot的位置 此时lfet=right,返回哪个都行	</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (left &lt; right)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> pivot = <span class="built_in">Partition</span>(arr, left, right); <span class="comment">//arr代表数组的首地址,即&amp;arr[0]</span></span><br><span class="line">		<span class="built_in">QuickSort</span>(arr, left, pivot - <span class="number">1</span>); <span class="comment">//递归左边</span></span><br><span class="line">		<span class="built_in">QuickSort</span>(arr, pivot + <span class="number">1</span>, right); <span class="comment">//递归右边</span></span><br><span class="line">		<span class="comment">//经过左右不断拆分递归后,最终数组会被细分为只有一个元素的数组,此时left=right,此时数组已经有序</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h3 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序(Selection Sort)"></a>选择排序(Selection Sort)</h3><h4 id="1-初始化变量"><a href="#1-初始化变量" class="headerlink" title="1. 初始化变量"></a>1. <strong>初始化变量</strong></h4><ul>
<li>使用 <code>minIndex</code> 变量记录当前未排序部分中最小元素的索引。</li>
<li>外层循环 <code>i</code> 表示当前处理的轮次，也是已排序部分的末尾索引。</li>
</ul>
<h4 id="2-寻找最小元素"><a href="#2-寻找最小元素" class="headerlink" title="2. 寻找最小元素"></a>2. <strong>寻找最小元素</strong></h4><ul>
<li>内层循环从 <code>i+1</code> 开始遍历未排序部分，找到其中最小的元素。</li>
<li>如果找到比当前记录的最小值还小的元素，则更新 <code>minIndex</code>。</li>
<li>从第一个元素开始向后遍历寻找最小的元素,将其与第一个元素替换,之后从第二个元素开始遍历寻找最小元素,将其与第二个元素替换,如此往复,循环完成倒数第二个元素时数组依然有序</li>
</ul>
<h4 id="3-交换元素"><a href="#3-交换元素" class="headerlink" title="3. 交换元素"></a>3. <strong>交换元素</strong></h4><ul>
<li>如果 <code>minIndex</code> 不等于 <code>i</code>，说明找到一个新的最小值。</li>
<li>交换 <code>arr[i]</code> 和 <code>arr[minIndex]</code>，将最小值放到已排序部分的末尾。</li>
</ul>
<h4 id="4-重复上述过程"><a href="#4-重复上述过程" class="headerlink" title="4. 重复上述过程"></a>4. <strong>重复上述过程</strong></h4><ul>
<li>每一轮结束后，未排序部分的长度减少 1。</li>
<li>外层循环继续，直到数组完全排序。</li>
<li>sp : 倒数第二个元素在向后寻找最小元素时已经与最后一个元素进行了比较,故无需对最后一个而元素进行排序(<del>就算想排也会出现数组索引溢出的bug</del>)</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> i, j, minIndex;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		minIndex = i;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[minIndex])</span><br><span class="line">			{</span><br><span class="line">				minIndex = j; <span class="comment">//找到最小的数的索引并将其索引赋值给minIndex</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (minIndex != i) <span class="comment">//在未找到新的最小数的情况下,i和minIndex相等,此时不需要交换</span></span><br><span class="line">		{</span><br><span class="line">			 <span class="built_in">swap</span>(arr[i], arr[minIndex]); <span class="comment">//交换最小数和i</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h3 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序(Heap Sort)"></a>堆排序(Heap Sort)</h3><h4 id="1-建立最大堆"><a href="#1-建立最大堆" class="headerlink" title="1. 建立最大堆"></a>1. <strong>建立最大堆</strong></h4><ul>
<li><strong>从最后一个非叶子节点开始</strong>，逐步调整每个节点使其所在子树成为最大堆。</li>
<li>遍历从 <code>All_index / 2</code> 到 <code>0</code> 的所有节点，调用 <code>Heapify</code> 函数调整堆。</li>
</ul>
<h4 id="2-交换堆顶元素和最后一个元素"><a href="#2-交换堆顶元素和最后一个元素" class="headerlink" title="2. 交换堆顶元素和最后一个元素"></a>2. <strong>交换堆顶元素和最后一个元素</strong></h4><ul>
<li>最大堆的堆顶元素是当前堆的最大值，将堆顶与堆的最后一个元素交换。</li>
<li>交换后，当前堆的最后一个元素已经排序，将堆的范围缩小</li>
</ul>
<h4 id="3-重新调整堆"><a href="#3-重新调整堆" class="headerlink" title="3. 重新调整堆"></a>3. <strong>重新调整堆</strong></h4><ul>
<li>调整堆的范围后，从堆顶开始调用 <code>Heapify</code> 函数，重新调整堆使其成为最大堆。</li>
</ul>
<h4 id="4-重复步骤-2-和-3"><a href="#4-重复步骤-2-和-3" class="headerlink" title="4. 重复步骤 2 和 3"></a>4. <strong>重复步骤 2 和 3</strong></h4><ul>
<li>不断缩小堆的范围，将堆顶元素交换到数组末尾并调整剩余堆，直到所有元素排序完成。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调整队列使其成为大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> Dad_index, <span class="type">int</span> Last_index)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> dad = Dad_index; <span class="comment">//父节点的索引,也是局部最大值索引</span></span><br><span class="line">	<span class="type">int</span> son = <span class="number">2</span> * dad + <span class="number">1</span>; <span class="comment">//左子节点的索引</span></span><br><span class="line">	<span class="keyword">while</span> (son &lt;= Last_index)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (son + <span class="number">1</span> &lt;= Last_index &amp;&amp; arr[son + <span class="number">1</span>] &gt; arr[son]) <span class="comment">//如果有右子节点且右子节点大于左子节点,则son+1为最大子节点</span></span><br><span class="line">		{  <span class="comment">//son + 1 &lt;= Last_index为了避免数组越界</span></span><br><span class="line">			son++; <span class="comment">//索引后移指向最大子节点</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (arr[son] &gt; arr[dad])</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">swap</span>(arr[son], arr[dad]); <span class="comment">//如果左子节点大于父节点,则交换两者</span></span><br><span class="line">			dad = son; <span class="comment">//dad指向新的父节点</span></span><br><span class="line">			son = <span class="number">2</span> * dad + <span class="number">1</span>; <span class="comment">//son指向新的左子节点</span></span><br><span class="line">			<span class="comment">//dad 和 son 都指向新的父节点和左子节点,继续循环可将因本次调整而破坏的最大堆子树调整为最大堆</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//如果左子节点小于等于父节点,则说明子树已经是最大堆,结束循环</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> All_index)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = All_index / <span class="number">2</span> ; i &gt;= <span class="number">0</span>; i--) <span class="comment">//建立最大堆</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">Heapify</span>(arr, i, All_index); <span class="comment">//将以arr[i]为根节点的子树调整为最大堆</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = All_index; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">Heapify</span>(arr,<span class="number">0</span>,i); <span class="comment">//将Dad_index赋值为0时,Heapify每次循环会将总体最大的元素放到堆顶</span></span><br><span class="line">		<span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]); <span class="comment">//将堆顶元素和最后一个元素交换</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序(Merge Sort)"></a>归并排序(Merge Sort)</h3><h4 id="1-分割阶段（分治过程）"><a href="#1-分割阶段（分治过程）" class="headerlink" title="1. 分割阶段（分治过程）"></a>1. <strong>分割阶段（分治过程）</strong></h4><ul>
<li><strong>递归拆分</strong>：将数组递归地分割成两半，每次通过计算中间位置 <code>mid = (left + right) / 2</code>，将数组分为两个子数组。</li>
<li><strong>递归条件</strong>：当 <code>left &lt; right</code> 时，继续分割，否则停止递归。</li>
</ul>
<p><strong>步骤：</strong></p>
<ul>
<li>调用 <code>MergeSort(arr, left, mid)</code>，递归处理数组的左半部分。</li>
<li>调用 <code>MergeSort(arr, mid + 1, right)</code>，递归处理数组的右半部分。</li>
<li>递归的终止条件是子数组大小为1，即当 <code>left == right</code> 时，子数组只有一个元素，此时数组本身已经是有序的。</li>
</ul>
<h4 id="2-合并阶段"><a href="#2-合并阶段" class="headerlink" title="2. 合并阶段"></a>2. <strong>合并阶段</strong></h4><ul>
<li><strong>合并两个有序子数组</strong>：当两个子数组都已经排好序时，将它们合并成一个有序数组。合并时采用的是<strong>归并算法</strong>，即通过逐一比较两个子数组的元素，将较小的元素放入原数组，最终形成一个有序数组。</li>
</ul>
<p><strong>步骤：</strong></p>
<ul>
<li>将待合并的两个子数组的数据先复制到一个临时数组 <code>temp[]</code> 中。</li>
<li>使用三个指针：<ul>
<li><code>One_current</code> 指向左子数组的当前元素，</li>
<li><code>Other_current</code> 指向右子数组的当前元素，</li>
<li><code>Copy_current</code> 指向合并后的数组的当前插入位置。</li>
</ul>
</li>
<li>比较左子数组和右子数组当前指针所指向的元素，将较小的元素放入原数组，更新相应指针。</li>
<li>如果一边的子数组已经合并完，而另一边还有剩余元素，直接将剩余的元素复制到原数组。</li>
</ul>
<h4 id="3-细节操作"><a href="#3-细节操作" class="headerlink" title="3. 细节操作"></a>3. <strong>细节操作</strong></h4><ul>
<li><strong>复制到临时数组</strong>：在合并前，先将当前需要合并的子数组部分复制到临时数组 <code>temp[]</code> 中。</li>
<li><strong>剩余元素处理</strong>：合并过程中可能会有剩余的元素没有被比较，此时直接将剩余元素从 <code>temp[]</code> 复制到原数组中，因为这些剩余元素本身是有序的。</li>
</ul>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//合并两个有序数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> temp[MAX_SIZE]; <span class="comment">//定义一个临时数组 </span></span><br><span class="line">	<span class="comment">//static修饰符使得temp可被重复调用,同时其在被调用时初始化,函数结束时销毁,避免了重复申请释放内存</span></span><br><span class="line">	<span class="type">int</span> One_current , Other_current , Copy_current;<span class="comment">//One_current表示一个数组的起始索引,Other_current表示另一个数组的起始索引,Copy_current表示正在合并的数组元素的索引</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将待合并的数组复制到临时数组</span></span><br><span class="line">	<span class="keyword">for</span> (One_current = left; One_current &lt;= right; One_current++)</span><br><span class="line">	{</span><br><span class="line">		temp[One_current] = arr[One_current]; <span class="comment">//将待合并的数组复制到临时数组		</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//比较两个数组的元素,将较小的元素放入原数组,每次将较小的元素放入原数组后将temp数组索引后移,实现合并</span></span><br><span class="line">	<span class="keyword">for</span> (One_current = left, Other_current = mid + <span class="number">1</span>, Copy_current = One_current; One_current &lt;= mid &amp;&amp; Other_current &lt;= right; Copy_current++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (temp[One_current] &lt;= temp[Other_current])</span><br><span class="line">		{</span><br><span class="line">			arr[Copy_current] = temp[One_current++]; <span class="comment">//将较小的元素放入原数组然后temp数组索引后移</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			arr[Copy_current] = temp[Other_current++]; <span class="comment">//将较小的元素放入原数组然后temp数组索引后移</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//当两个子数组元素数量不同时会有剩余的元素无法与零一数组的元素做比较并入原数组,此时将剩余元素本身就有序,故直接复制到原数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(One_current &lt;= mid) arr[Copy_current++] = temp[One_current++]; <span class="comment">//将剩余的元素复制到原数组,第一个数组更长时触发</span></span><br><span class="line">	<span class="keyword">while</span>(Other_current &lt;= right) arr[Copy_current++] = temp[Other_current++]; <span class="comment">//将剩余的元素复制到原数组,第二个数组更长时触发</span></span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (left &lt; right)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">MergeSort</span>(arr, left, mid); <span class="comment">//递归左边</span></span><br><span class="line">		<span class="built_in">MergeSort</span>(arr, mid + <span class="number">1</span>, right); <span class="comment">//递归右边</span></span><br><span class="line">		<span class="comment">//MergeSort会将数组递归拆分到仅有一个元素的数组,此时left=right,此时数组已经有序</span></span><br><span class="line">		<span class="built_in">Merge</span>(arr, left, mid, right); <span class="comment">//合并左右两边的有序数组</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>个别排序算法过于抽象,因此需要图像辅助理解,脑内无法理清流程时去文章开头找到算法辅助网站去看一下流程吧</p>
<h4 id="各类排序方法的总体代码"><a href="#各类排序方法的总体代码" class="headerlink" title="各类排序方法的总体代码"></a>各类排序方法的总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>Different_Kands_of_Sort_Fuction </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">"SortTest_Header.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换两个数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> temp = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = temp;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> index = n - <span class="number">1</span>;<span class="comment">//设置数组最后一个元素的索引</span></span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; index ;i++) <span class="comment">//每循环一次就会有一个最大的数冒泡到数组最右边,循环到index-1时仅剩最后两个元素,他们比较完成时数组就有序了</span></span><br><span class="line">	{</span><br><span class="line">		flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (j = index ;j &gt; <span class="number">0</span>; j--)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>])</span><br><span class="line">			{</span><br><span class="line">				<span class="built_in">swap</span>(arr[j], arr[j - <span class="number">1</span>]);</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (!flag) <span class="comment">//如果没有发生交换,说明数组已经有序,可以提前结束循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序的分区函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Partition</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> pivot = A[left];<span class="comment">//选取第一个元素作为pivot</span></span><br><span class="line">	<span class="keyword">while</span> (left &lt; right)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; A[right] &gt;= pivot)</span><br><span class="line">			right--;</span><br><span class="line">		A[left] = A[right];</span><br><span class="line">		<span class="keyword">while</span> (left &lt; right &amp;&amp; A[left] &lt;= pivot)</span><br><span class="line">			left++;</span><br><span class="line">		A[right] = A[left];</span><br><span class="line">	}</span><br><span class="line">	A[left] = pivot;</span><br><span class="line">	<span class="keyword">return</span> right; <span class="comment">//返回pivot的位置 此时lfet=right,返回哪个都行	</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//快速排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (left &lt; right)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> pivot = <span class="built_in">Partition</span>(arr, left, right); <span class="comment">//arr代表数组的首地址,即&amp;arr[0]</span></span><br><span class="line">		<span class="built_in">QuickSort</span>(arr, left, pivot - <span class="number">1</span>); <span class="comment">//递归左边</span></span><br><span class="line">		<span class="built_in">QuickSort</span>(arr, pivot + <span class="number">1</span>, right); <span class="comment">//递归右边</span></span><br><span class="line">		<span class="comment">//经过左右不断拆分递归后,最终数组会被细分为只有一个元素的数组,此时left=right,此时数组已经有序</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; n ;i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> insertValue = arr[i]; <span class="comment">//每次从未排序的数组中取出第一个元素</span></span><br><span class="line">		<span class="keyword">for</span> (j = i - <span class="number">1</span>; arr[j] &gt; insertValue &amp;&amp; j &gt;= <span class="number">0</span>; j--)  <span class="comment">//</span></span><br><span class="line">		{</span><br><span class="line">			arr[j + <span class="number">1</span>] = arr[j]; <span class="comment">//将大于insertValue的元素后移一位</span></span><br><span class="line">		}</span><br><span class="line">		arr[j + <span class="number">1</span>] = insertValue; <span class="comment">//将insertValue插入到正确的位置</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//调整队列使其成为大根堆</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heapify</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> Dad_index, <span class="type">int</span> Last_index)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> dad = Dad_index; <span class="comment">//父节点的索引,也是局部最大值索引</span></span><br><span class="line">	<span class="type">int</span> son = <span class="number">2</span> * dad + <span class="number">1</span>; <span class="comment">//左子节点的索引</span></span><br><span class="line">	<span class="keyword">while</span> (son &lt;= Last_index)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (son + <span class="number">1</span> &lt;= Last_index &amp;&amp; arr[son + <span class="number">1</span>] &gt; arr[son]) <span class="comment">//如果有右子节点且右子节点大于左子节点,则son+1为最大子节点</span></span><br><span class="line">		{  <span class="comment">//son + 1 &lt;= Last_index为了避免数组越界</span></span><br><span class="line">			son++; <span class="comment">//索引后移指向最大子节点</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (arr[son] &gt; arr[dad])</span><br><span class="line">		{</span><br><span class="line">			<span class="built_in">swap</span>(arr[son], arr[dad]); <span class="comment">//如果左子节点大于父节点,则交换两者</span></span><br><span class="line">			dad = son; <span class="comment">//dad指向新的父节点</span></span><br><span class="line">			son = <span class="number">2</span> * dad + <span class="number">1</span>; <span class="comment">//son指向新的左子节点</span></span><br><span class="line">			<span class="comment">//dad 和 son 都指向新的父节点和左子节点,继续循环可将因本次调整而破坏的最大堆子树调整为最大堆</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">//如果左子节点小于等于父节点,则说明子树已经是最大堆,结束循环</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HeapSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> All_index)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = All_index / <span class="number">2</span> ; i &gt;= <span class="number">0</span>; i--) <span class="comment">//建立最大堆</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">Heapify</span>(arr, i, All_index); <span class="comment">//将以arr[i]为根节点的子树调整为最大堆</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = All_index; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">Heapify</span>(arr,<span class="number">0</span>,i); <span class="comment">//将Dad_index赋值为0时,Heapify每次循环会将总体最大的元素放到堆顶</span></span><br><span class="line">		<span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]); <span class="comment">//将堆顶元素和最后一个元素交换</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//合并两个有序数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> temp[MAX_SIZE]; <span class="comment">//定义一个临时数组 </span></span><br><span class="line">	<span class="comment">//static修饰符使得temp可被重复调用,同时其在被调用时初始化,函数结束时销毁,避免了重复申请释放内存</span></span><br><span class="line">	<span class="type">int</span> One_current , Other_current , Copy_current;<span class="comment">//One_current表示一个数组的起始索引,Other_current表示另一个数组的起始索引,Copy_current表示正在合并的数组元素的索引</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//将待合并的数组复制到临时数组</span></span><br><span class="line">	<span class="keyword">for</span> (One_current = left; One_current &lt;= right; One_current++)</span><br><span class="line">	{</span><br><span class="line">		temp[One_current] = arr[One_current]; <span class="comment">//将待合并的数组复制到临时数组		</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">//比较两个数组的元素,将较小的元素放入原数组,每次将较小的元素放入原数组后将temp数组索引后移,实现合并</span></span><br><span class="line">	<span class="keyword">for</span> (One_current = left, Other_current = mid + <span class="number">1</span>, Copy_current = One_current; One_current &lt;= mid &amp;&amp; Other_current &lt;= right; Copy_current++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (temp[One_current] &lt;= temp[Other_current])</span><br><span class="line">		{</span><br><span class="line">			arr[Copy_current] = temp[One_current++]; <span class="comment">//将较小的元素放入原数组然后temp数组索引后移</span></span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		{</span><br><span class="line">			arr[Copy_current] = temp[Other_current++]; <span class="comment">//将较小的元素放入原数组然后temp数组索引后移</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">	<span class="comment">//当两个子数组元素数量不同时会有剩余的元素无法与零一数组的元素做比较并入原数组,此时将剩余元素本身就有序,故直接复制到原数组</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span>(One_current &lt;= mid) arr[Copy_current++] = temp[One_current++]; <span class="comment">//将剩余的元素复制到原数组,第一个数组更长时触发</span></span><br><span class="line">	<span class="keyword">while</span>(Other_current &lt;= right) arr[Copy_current++] = temp[Other_current++]; <span class="comment">//将剩余的元素复制到原数组,第二个数组更长时触发</span></span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> left, <span class="type">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (left &lt; right)</span><br><span class="line">	{</span><br><span class="line">		<span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">		<span class="built_in">MergeSort</span>(arr, left, mid); <span class="comment">//递归左边</span></span><br><span class="line">		<span class="built_in">MergeSort</span>(arr, mid + <span class="number">1</span>, right); <span class="comment">//递归右边</span></span><br><span class="line">		<span class="comment">//MergeSort会将数组递归拆分到仅有一个元素的数组,此时left=right,此时数组已经有序</span></span><br><span class="line">		<span class="built_in">Merge</span>(arr, left, mid, right); <span class="comment">//合并左右两边的有序数组</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> i, j, minIndex;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		minIndex = i;</span><br><span class="line">		<span class="keyword">for</span> (j = i + <span class="number">1</span>;j&lt;n;j++)</span><br><span class="line">		{</span><br><span class="line">			<span class="keyword">if</span> (arr[j] &lt; arr[minIndex])</span><br><span class="line">			{</span><br><span class="line">				minIndex = j; <span class="comment">//找到最小的数的索引并将其索引赋值给minIndex</span></span><br><span class="line">			}</span><br><span class="line">		}</span><br><span class="line">		<span class="keyword">if</span> (minIndex != i) <span class="comment">//在未找到新的最小数的情况下,i和minIndex相等,此时不需要交换</span></span><br><span class="line">		{</span><br><span class="line">			 <span class="built_in">swap</span>(arr[i], arr[minIndex]); <span class="comment">//交换最小数和i</span></span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	RandomList random_list;</span><br><span class="line">	<span class="built_in">CreatRandomList_head</span>(random_list);</span><br><span class="line">	<span class="type">int</span> str[MAX_SIZE];</span><br><span class="line">	<span class="built_in">memcpy</span>(str, random_list.data, <span class="built_in">sizeof</span>(<span class="type">int</span>) * random_list.length);<span class="comment">//拷贝数组</span></span><br><span class="line">	<span class="type">int</span> n = random_list.length;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//BubbleSort(str, n);</span></span><br><span class="line">	<span class="comment">//QuickSort(str, 0, n - 1);</span></span><br><span class="line">	<span class="comment">//InsertSort(str, n);</span></span><br><span class="line">	<span class="comment">//HeapSort(str, n - 1);</span></span><br><span class="line">	<span class="built_in">MergeSort</span>(str, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">	<span class="comment">//SelectionSort(str, n);		</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//printf("n=%d\n",n);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">PrintList_head</span>(str);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//SP : 数组名本身就是一个指针，所以在传入参数时不需要&amp;符号也能实现对数组的操作。</span></span><br></pre></td></tr></table></figure></div>
              </div>
            </details>   

]]></content>
      <categories>
        <category>Data_structures</category>
      </categories>
      <tags>
        <tag>Data_s</tag>
      </tags>
  </entry>
  <entry>
    <title>PythonNotes</title>
    <url>/2024/09/29/PythonNotes/</url>
    <content><![CDATA[<p>Python Notes _Base Grammars </p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p>P(屁) y(眼) t(通) hon(红)<br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/PythonNotes/xuehuan_cry.png"
                     
                ></p>
<h3 id="标准代码架构"><a href="#标准代码架构" class="headerlink" title="标准代码架构"></a>标准代码架构</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">find7</span>():  <span class="comment">#含参fuction</span></span><br><span class="line">    num_I = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> num_I&lt;= <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">if</span> num_I % <span class="number">7</span> == <span class="number">0</span> <span class="keyword">or</span> <span class="string">&#x27;7&#x27;</span> <span class="keyword">in</span> <span class="built_in">str</span>(num_I):</span><br><span class="line">            num_yv = num_I</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;num_yv&#125;</span>&#x27;</span>)</span><br><span class="line">            num_I += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num_I += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():  <span class="comment">#主函数执行fuction调用</span></span><br><span class="line">    find7()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:  <span class="comment">#启动语句</span></span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></div>
<p>优秀的代码架构是后期修bug的救命稻草</p>
<h3 id="数据转换-数据计算"><a href="#数据转换-数据计算" class="headerlink" title="数据转换&amp;数据计算"></a>数据转换&amp;数据计算</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bin</span>(x) <span class="comment">#转为2进制 </span></span><br><span class="line"><span class="built_in">oct</span>(x) <span class="comment">#转为8进制</span></span><br><span class="line"><span class="built_in">int</span>(x) <span class="comment">#转为10进制,整数  常用 y = int(input(&#x27;啊吧啊吧&#x27;))</span></span><br><span class="line"><span class="built_in">hex</span>(x) <span class="comment">#转为16进制</span></span><br><span class="line"><span class="built_in">float</span>(x) <span class="comment">#转为浮点数</span></span><br><span class="line"><span class="built_in">complex</span>(x) <span class="comment">#转为复数</span></span><br><span class="line">_________________________</span><br><span class="line">+,-,*,/</span><br><span class="line">% <span class="comment">#取余</span></span><br><span class="line">// <span class="comment">#整除</span></span><br><span class="line">** <span class="comment">#幂运算</span></span><br><span class="line">__________________________</span><br><span class="line">num += <span class="number">2</span> <span class="comment">#表示num = num + 2</span></span><br><span class="line">-=,*=,/=,//=,%=,**=</span><br><span class="line">__________________________</span><br></pre></td></tr></table></figure></div>

<p>在实际应用中二,八,十六进制数的显示方式分别为 : </p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 十进制转换为其他进制</span></span><br><span class="line">num = <span class="number">26</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 十进制转为二进制</span></span><br><span class="line">binary_num = <span class="built_in">bin</span>(num)  <span class="comment"># 输出为 &#x27;0b11010&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;num&#125;</span> 的二进制表示为: <span class="subst">&#123;binary_num&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 十进制转为八进制</span></span><br><span class="line">octal_num = <span class="built_in">oct</span>(num)  <span class="comment"># 输出为 &#x27;0o32&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;num&#125;</span> 的八进制表示为: <span class="subst">&#123;octal_num&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 十进制转为十六进制</span></span><br><span class="line">hex_num = <span class="built_in">hex</span>(num)  <span class="comment"># 输出为 &#x27;0x1a&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;num&#125;</span> 的十六进制表示为: <span class="subst">&#123;hex_num&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure></div>

<p>带有 <code>0x</code> 前缀的数字代表十六进制数，<code>0b</code> 前缀代表二进制数，<code>0o</code> 代表八进制数。</p>
<h3 id="逻辑-逻辑运算符"><a href="#逻辑-逻辑运算符" class="headerlink" title="逻辑&amp;逻辑运算符"></a>逻辑&amp;逻辑运算符</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> x &lt; y :</span><br><span class="line">	<span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">elif</span> x = y:</span><br><span class="line">	<span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">	<span class="built_in">print</span>(y)</span><br><span class="line">_______________________</span><br><span class="line"><span class="keyword">while</span> x &lt; y :</span><br><span class="line">	<span class="built_in">print</span>(x)</span><br><span class="line">______________________</span><br><span class="line"><span class="comment"># if 和 while 的判断条件输出的是bool值,因此可用 while True : 来实现无线循环</span></span><br><span class="line">判断条件:</span><br><span class="line">==,!=,&gt;,&lt;,&gt;=,&lt;=</span><br><span class="line">x <span class="keyword">and</span> y <span class="comment">#x和y均为true时输出y</span></span><br><span class="line">x <span class="keyword">or</span> y <span class="comment">#x和y均为true时输出x</span></span><br><span class="line"><span class="keyword">not</span> x  <span class="comment">#x为true时输出false</span></span><br><span class="line">x <span class="keyword">in</span> [<span class="string">&#x27;商业贷款&#x27;</span>, <span class="string">&#x27;公积金贷款&#x27;</span>, <span class="string">&#x27;组合贷款&#x27;</span>]:</span><br><span class="line">x <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;商业贷款&#x27;</span>, <span class="string">&#x27;公积金贷款&#x27;</span>, <span class="string">&#x27;组合贷款&#x27;</span>]: <span class="comment">#用于判断多个条件中是否含有其中一个</span></span><br><span class="line"></span><br><span class="line">_____________________</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rang(<span class="number">5</span>) : <span class="comment">#循环遍历数组里的元素</span></span><br><span class="line">	<span class="built_in">print</span>(i)</span><br><span class="line">________________________</span><br><span class="line"><span class="keyword">break</span> <span class="comment">#结束循环,执行下一段代码</span></span><br><span class="line"><span class="keyword">continue</span> <span class="comment">#跳过本次循环,执行下一次循环</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>好啊</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;啊吧啊吧&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;贷款年限：<span class="subst">&#123;years&#125;</span> 年&quot;</span>) <span class="comment">#f&#x27;&#123;x&#125;&#x27;用于在字符串中输出变量x</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;啊吧啊吧&#x27;</span>\n) <span class="comment">#\n为换行符</span></span><br><span class="line">\b,退格  \n,换行  \v,纵向制表 \t,横向制表 \r,回车</span><br><span class="line">________________________________________________</span><br><span class="line"><span class="comment"># 格式化字符串的输出方式</span></span><br><span class="line">value = <span class="number">10</span></span><br><span class="line">string_x = <span class="string">&#x27;我今年%d岁&#x27;</span> <span class="comment">#字符串中变量用%d格式化为整数</span></span><br><span class="line"><span class="built_in">print</span>(string_x % value) <span class="comment">#输出时按照 字符串%参数 的样式书写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#数据格式化符</span></span><br><span class="line">%c <span class="comment">#格式化为字符</span></span><br><span class="line">%s <span class="comment">#格式化为字符串</span></span><br><span class="line">%d <span class="comment">#格式化为整数</span></span><br><span class="line">%u <span class="comment">#格式化为无符号整型</span></span><br><span class="line">%o <span class="comment">#格式化为八进制数</span></span><br><span class="line">%x <span class="comment">#格式化为十六进制数</span></span><br><span class="line">%f <span class="comment">#格式化为浮点数</span></span><br><span class="line">________________________________________________</span><br><span class="line">str_x.find(<span class="string">&#x27;a&#x27;</span>,<span class="number">0</span>,<span class="number">5</span>) <span class="comment">#目标字符串.find(&#x27;指定查出找的字符&#x27;,起始索引,结束索引)</span></span><br><span class="line"><span class="comment">#输出指定字符在字符串中的索引序号</span></span><br><span class="line">_________________________________________________</span><br><span class="line">str_x.replace(<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="number">3</span>) <span class="comment">#目标字符串.replace(&#x27;指定字符&#x27;,&#x27;新字符&#x27;,替换次数(默认全部替换)) </span></span><br><span class="line"><span class="comment">#替换字符</span></span><br><span class="line">_________________________________________________</span><br><span class="line">str_x.split(<span class="string">&#x27;/&#x27;</span>,<span class="number">3</span>) <span class="comment">#目标字符串.split(&#x27;分割符号(默认为空格)&#x27;,分割次数(默认全部))</span></span><br><span class="line"><span class="comment">#分割字符串</span></span><br><span class="line">__________________________________________________</span><br><span class="line">str_x.jion(<span class="string">&#x27;a&#x27;</span>) <span class="comment">#目标字符串.join(&#x27;连接字符串的字符&#x27;)</span></span><br><span class="line">__________________________________________________</span><br><span class="line">str_x = <span class="string">&#x27;aabb&#x27;</span></span><br><span class="line">str_y = <span class="string">&#x27;bbcc&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str_x + str_y) <span class="comment">#+号课实现字符串首尾拼接</span></span><br><span class="line">__________________________________________________</span><br><span class="line">.strip(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#移除首尾指定字符</span></span><br><span class="line">.lstrip(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#移除右端指定字符(left strip)</span></span><br><span class="line">.rstrip(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#移除左端指定字符(right strip)</span></span><br><span class="line">.upper()<span class="comment">#字符串全转换为大写字母</span></span><br><span class="line">.lower()<span class="comment">#字符串全转换为小写字母</span></span><br><span class="line">.capitalize()<span class="comment">#字符串中第一个字母大写</span></span><br><span class="line">.title()<span class="comment">#字符串每个单词字母大写</span></span><br><span class="line">.center(<span class="number">13</span>,<span class="string">&#x27;_&#x27;</span>)<span class="comment">#字符串居中  #目标字符串.center(字符串总长度,补齐两端的符号)</span></span><br><span class="line">.ljust(<span class="number">13</span>,<span class="string">&#x27;_&#x27;</span>)<span class="comment">#字符串向左对齐 #目标字符串.ljust(字符串总长度,补齐右端的符号)</span></span><br><span class="line">.rjust(<span class="number">13</span>,<span class="string">&#x27;_&#x27;</span>)<span class="comment">#字符串向左对齐 #目标字符串.rjust(字符串总长度,补齐左端的符号)</span></span><br><span class="line">__________________________________________________</span><br><span class="line"><span class="comment">#在字符串操作中总有将指定字符进行参数化,以实现模块化修改</span></span><br><span class="line">string_x = <span class="string">&#x27;okjuhtabab&#x27;</span></span><br><span class="line">find_y = <span class="string">&#x27;o&#x27;</span></span><br><span class="line">res_1 = string_x.find(find_y,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">print</span>(res_1)</span><br><span class="line">__________________________________________________</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>好好好</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">list_x = [<span class="number">1</span>,<span class="string">&#x27;p&#x27;</span>,<span class="number">6</span>,<span class="string">&#x27;o&#x27;</span>]<span class="comment">#手动创建</span></span><br><span class="line">list_x =<span class="built_in">list</span>(<span class="number">1</span>,<span class="string">&#x27;p&#x27;</span>,<span class="number">6</span>,<span class="string">&#x27;o&#x27;</span>,<span class="number">6</span>)<span class="comment">#list()方法创建</span></span><br><span class="line"><span class="comment">#同一元素可重复</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#以切片索引的方式访问和调用列表中的元素</span></span><br><span class="line"><span class="built_in">print</span>(list_x[<span class="number">1</span>:<span class="number">4</span>:<span class="number">3</span>])<span class="comment">#目标列表[起始索引:结束索引:步长]</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#添加末尾元素</span></span><br><span class="line">list_x.append(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#目标列表.append(元素or参数)</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#末尾接新列表</span></span><br><span class="line">list_x.extend(list_y)<span class="comment">#目标列表.append(新列表)</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#指定索引插入元素</span></span><br><span class="line">list_x.insert(<span class="number">2</span>,<span class="string">&#x27;a&#x27;</span>)<span class="comment">#目标列表.insert(索引序号，新元素)</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#按特定顺序排列</span></span><br><span class="line">list_x.sort()<span class="comment">#目标列表.sort(key排序规则，布尔值（True为降序False为升序）)  </span></span><br><span class="line"><span class="comment">#在（）为空时，默认为字符串以大写字母有限的正序排列，数字升序排列</span></span><br><span class="line"><span class="comment">#string和数字无法进行sort排列</span></span><br><span class="line"><span class="comment">#常用的key：</span></span><br><span class="line">.sort(key=<span class="built_in">len</span>)  <span class="comment"># 按字符串长度排序</span></span><br><span class="line">.sort(key=<span class="built_in">str</span>.lower)  <span class="comment"># 忽略大小写进行排序</span></span><br><span class="line">.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>]) <span class="comment">#自定义排序规则  #按第二个元素（字符串）排序，x:x[元素内索引号]</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#升序排列列表元素并赋值到新列表，原列表排序不变</span></span><br><span class="line">list_y = <span class="built_in">sorted</span>(list_x)<span class="comment">#新列表 = sorted(原列表)</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#反转列表排序</span></span><br><span class="line">list_x.reverse()</span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#按索引删除元素.s</span></span><br><span class="line"><span class="keyword">del</span> list_x[<span class="number">1</span>] <span class="comment">#del 目标列表[索引]  </span></span><br><span class="line"><span class="comment">#当为 del list_x 是为删除整个列表，此时list_x的定义也会消失</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#按索引删除元素.f</span></span><br><span class="line">list_x.pop(<span class="number">4</span>) <span class="comment">#目标列表.pop(索引序号) #当()为空是为删除最后一个元素</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#清空列表，列表定义依然存在</span></span><br><span class="line">list_x.clear()</span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#按值删除元素,若列表又多个同一元素仅删除匹配到的第一个元素</span></span><br><span class="line">list_x.remove(<span class="string">&#x27;a&#x27;</span>) <span class="comment">#目标列表.remove(目标值）</span></span><br><span class="line">_________________________________________</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>好得很呐</p>
<h3 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">tuple_x = (<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">6</span>)</span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#元组可称为列表中的元素</span></span><br><span class="line">list_x = [(<span class="number">3</span>,<span class="string">&#x27;o&#x27;</span>)(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;g&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;i&#x27;</span>)]</span><br><span class="line"><span class="comment">#在使用元组式列表时元组同索引的数据类型必须相同，否则无法进行排序</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#按索引切片访问元组</span></span><br><span class="line"><span class="built_in">print</span>(tuple_x[<span class="number">2</span>:<span class="number">5</span>:<span class="number">2</span>])<span class="comment">#目标元组[起始索引:结束索引:步长]</span></span><br><span class="line">_________________________________________</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>好的不得了</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">set_x = &#123;<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">6</span>&#125;</span><br><span class="line">set_x = &#123;(<span class="number">3</span>,<span class="string">&#x27;o&#x27;</span>)(<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>),(<span class="number">8</span>,<span class="string">&#x27;g&#x27;</span>)&#125;</span><br><span class="line">set_x = &#123;[<span class="number">1</span>,<span class="string">&#x27;p&#x27;</span>,<span class="number">6</span>,<span class="string">&#x27;o&#x27;</span>],[<span class="number">6</span>,<span class="string">&#x27;i&#x27;</span>,<span class="number">9</span>,<span class="number">8</span>]&#125;</span><br><span class="line"><span class="comment">#集合中的元素具有唯一性</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#集合可包含列表、元组  #其本身为可变类型</span></span><br><span class="line">set_x = &#123;<span class="number">1</span>,<span class="string">&#x27;a&#x27;</span>,<span class="number">6</span>,(<span class="number">3</span>,<span class="string">&#x27;o&#x27;</span>),[<span class="number">1</span>,<span class="string">&#x27;p&#x27;</span>,(<span class="number">2</span>,<span class="string">&#x27;i&#x27;</span>)]&#125;</span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#set()传入元素</span></span><br><span class="line">set_x = <span class="built_in">set</span>([<span class="number">6</span>,(<span class="number">3</span>,<span class="string">&#x27;o&#x27;</span>),<span class="number">1</span>,<span class="string">&#x27;p&#x27;</span>,<span class="built_in">range</span>(<span class="number">5</span>)])</span><br><span class="line"><span class="comment">#set仅支持单次传入一种类型的数据，当需要传入不同类型数据时可将他们放入列表中，再进行传入</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#添加元素</span></span><br><span class="line">set_x.add(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#目标集合.add(元素)</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#按值删除元素，当元素不存在时输出KeyError</span></span><br><span class="line">set_x.remove(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#目标集合.remove(元素)</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">##按值删除元素，当元素不存在时不做操作</span></span><br><span class="line">set_x.discard(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#目标集合.discord(元素)</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#随机返回一个元素，并删除再集合中该元素</span></span><br><span class="line">y = set_x.pop()<span class="comment">#目标集合.pop(元素)</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#清空集合,定义依然存在</span></span><br><span class="line">set_x.clear()</span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#复制集合</span></span><br><span class="line">set_y = set_x.copy()</span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#判断两个集合中是否有相同的元素，有相同元素输出False,无相同元素输出True</span></span><br><span class="line">set_x.isdisjoint(set_y)<span class="comment">#目标集合.isdisjiont(另一集合)</span></span><br><span class="line">_________________________________________</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>这也太好了吧</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">dictionary_x = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;k&#x27;</span>:<span class="string">&#x27;p&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;o&#x27;</span>，<span class="string">&#x27;l&#x27;</span>:<span class="number">1</span>&#125;<span class="comment"># &#123;key:value&#125;</span></span><br><span class="line"><span class="comment">#字典元素无序，key 唯一 ,value 可有多个重复</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#按key值访问字典元素</span></span><br><span class="line"><span class="built_in">print</span>(dictionary_x.get(<span class="string">&#x27;a&#x27;</span>))<span class="comment">#目标字典.get(key值)</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#仅访问所有key值</span></span><br><span class="line"><span class="built_in">print</span>(dictionary_x.key())<span class="comment">#目标字典.key()</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#仅访问所有values值</span></span><br><span class="line"><span class="built_in">print</span>(dictionary_x.values())<span class="comment">#目标字典.values()</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#仅访问所有items值</span></span><br><span class="line"><span class="built_in">print</span>(dictionary_x.items())<span class="comment">#目标字典.items()</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#根据key值修改value，当key值不在字典中，则视为添加新key</span></span><br><span class="line">dictionary_x[<span class="string">&#x27;a&#x27;</span>] = <span class="number">8</span> <span class="comment">#目标字典[key值] = value</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#使用update修改value</span></span><br><span class="line">dictionary_x.update(<span class="string">&#x27;a&#x27;</span>=<span class="number">8</span>)<span class="comment">#目标字典.update(key值 = value)</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#按key值删除元素</span></span><br><span class="line">dictionary_x.pop(<span class="string">&#x27;a&#x27;</span>)<span class="comment">#目标字典.pop(key值)</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#随机删除元素</span></span><br><span class="line">dictionary_x.popitem()<span class="comment">#目标字典.popitem()</span></span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment">#清空z字典,定义依然存在</span></span><br><span class="line">dictionary_x.clear()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<p>好好好</p>
<h3 id="组合数据类型应用运算符"><a href="#组合数据类型应用运算符" class="headerlink" title="组合数据类型应用运算符"></a>组合数据类型应用运算符</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串，列表，元组，字典均可使用 + 来进行同类型元素合并</span></span><br><span class="line">dictionary_z = dictionary_x + dictionary_y</span><br><span class="line">list_z = list_x + list_y</span><br><span class="line">_________________________________________</span><br><span class="line"><span class="comment"># * 实现表内元素自行复制</span></span><br><span class="line">list_z = list_x * <span class="number">3</span></span><br><span class="line"><span class="comment">#判断元素是否在表内,返回值为bool</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">in</span> list_x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;a&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> list_x)</span><br></pre></td></tr></table></figure></div>

<p>没见过这么好的</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fuction_x</span>(<span class="params">a,b</span>): </span><br><span class="line">	result = a + b </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fuction_y</span>(<span class="params">a,b,/,c</span>):</span><br><span class="line">    	y = c + d</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>简直令人惊叹不已</p>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fuction_x</span>(<span class="params">a,b</span>): <span class="comment">#a和b称为形参,在调用函数时可通过对应位置进行传参</span></span><br><span class="line">	result = a + b</span><br><span class="line">_____________________________________________________    </span><br><span class="line"><span class="comment">#位置参数传递</span></span><br><span class="line">fuction_x(<span class="number">2</span>,<span class="number">3</span>) <span class="comment">#2和3称为实参,实际传入fuction_x中的参数</span></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#关键字参数传递</span></span><br><span class="line">fuction_x(a=<span class="number">2</span>,b=<span class="number">3</span>) <span class="comment">#在参数数量过多时,关键字参数传递更为优秀</span></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#传递限制</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuction_x</span>(<span class="params">a,b,/,c,d</span>): <span class="comment"># /前的参数仅能接受位置传递,/后的参数二者均可</span></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#参数混合传递</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuction_x</span>(<span class="params">a,b,*c,**d</span>):</span><br><span class="line">	<span class="built_in">print</span>(a,b,*c,d) <span class="comment">#print不接受字典形式的参数,因此应写为d而不是**d</span></span><br><span class="line">fuction_x(<span class="number">1</span>,<span class="string">&#x27;o&#x27;</span>,(<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>),p=<span class="number">2</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>让人心潮澎湃的好啊</p>
<h3 id="参数打包-解包"><a href="#参数打包-解包" class="headerlink" title="参数打包&#x2F;解包"></a>参数打包&#x2F;解包</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#参数打包</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuction_x</span>(<span class="params">*a</span>): <span class="comment"># *a为以元组形式接受参数</span></span><br><span class="line">fuction_x(<span class="number">11</span>,<span class="number">23</span>,<span class="number">56</span>,<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuction_x</span>(<span class="params">**b</span>): <span class="comment">#**b为以字典形式接受参数</span></span><br><span class="line">fuction_x(a=<span class="number">11</span>,b=<span class="number">22</span>,c=<span class="number">90</span>) <span class="comment">#在字典传递参数时应遵循 key=value 的形式,字符串不用引号</span></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#参数解包,用于组合数据向多个单数据接口传输</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuction_x</span>(<span class="params">a,b,c,d,e</span>):</span><br><span class="line">parameter_x = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">fuction_x(*parameter_x) <span class="comment">#parameter_x被解包成多个单数据,并按照索引传fuction_x</span></span><br><span class="line"><span class="comment">#当组合数据与单数据接口数不对应时会报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuction_x</span>(<span class="params">a,b,c,d,e</span>):</span><br><span class="line">parameter_x = &#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;k&#x27;</span>:<span class="string">&#x27;p&#x27;</span>,<span class="number">2</span>:<span class="string">&#x27;o&#x27;</span>,<span class="number">5</span>:<span class="string">&#x27;n&#x27;</span>&#125;</span><br><span class="line">fuction_x(**parameter_x) <span class="comment">#解包字典后传入的是value值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>实在是太令人满意了呀</p>
<h3 id="参数返回值"><a href="#参数返回值" class="headerlink" title="参数返回值"></a>参数返回值</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fuction_x</span>(<span class="params">a,b</span>):</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="keyword">return</span> c <span class="comment">#return将值返回到主程序中,同时程序回到函数被调用的时候继续执行</span></span><br><span class="line"><span class="built_in">print</span>(fuction_x(<span class="number">1</span>,<span class="number">2</span>)) <span class="comment">#此时fuction_x(1,2)实际被替换成了c的值</span></span><br><span class="line"><span class="comment">#当return多个值的时候将返回元组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>真是无可挑剔的完美体验</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#局部变量</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuction_x</span>():</span><br><span class="line">    a = <span class="number">5</span> <span class="comment">#对于变量a,只能在函数内调用,函数外无a的定义</span></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#全局变量 #global 变量</span></span><br><span class="line">a = <span class="number">1</span> </span><br><span class="line">b = <span class="number">3</span> <span class="comment">#在函数外定义变量之后可被全局调用</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuction_x</span>():</span><br><span class="line">    <span class="keyword">global</span> a <span class="comment">#声明a为全局变量,实现函数内外a值互通</span></span><br><span class="line">    b += <span class="number">1</span> <span class="comment">#在b进行迭代时,外部定义将被覆盖,此时a又变成了局部变量,此步会报错,需像a一样声明全局变量</span></span><br><span class="line">	a += <span class="number">2</span></span><br><span class="line">    c = a + b </span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#嵌套函数变量 #nonlocal 变量        </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fuction_x</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fuction_y</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> a <span class="comment">#声明局部作用变量a,使得fuction_x可以调用a,同时不溢出整个函数</span></span><br><span class="line">        a = <span class="number">2</span></span><br><span class="line">    fuction_y()</span><br><span class="line">    b = a + <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(b)</span><br><span class="line"></span><br><span class="line">fuction_x()</span><br></pre></td></tr></table></figure></div>



<h3 id="递归-匿名函数"><a href="#递归-匿名函数" class="headerlink" title="递归&#x2F;匿名函数"></a>递归&#x2F;匿名函数</h3><p>这个学起来有点费劲,回头再补</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line">啊吧 啊吧 啊吧</span><br></pre></td></tr></table></figure></div>





<h2 id="文件-数据-操作"><a href="#文件-数据-操作" class="headerlink" title="文件&#x2F;数据 操作"></a>文件&#x2F;数据 操作</h2><h3 id="标准文件访问方法"><a href="#标准文件访问方法" class="headerlink" title="标准文件访问方法"></a>标准文件访问方法</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开文本文件</span></span><br><span class="line">file_path = <span class="string">&#x27;F:\\mulyilytest\\pytest.txt&#x27;</span> <span class="comment">#文件地址参数化 #地址区分符号用\\</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file_01: <span class="comment">#as后命名文件在代码中的参数名</span></span><br><span class="line">    content = file.read()  <span class="comment">#读取文件内容并参数化</span></span><br></pre></td></tr></table></figure></div>

<h3 id="文本文件操作"><a href="#文本文件操作" class="headerlink" title="文本文件操作"></a>文本文件操作</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#打开文件</span></span><br><span class="line">flie_01 = <span class="built_in">open</span>(<span class="string">&#x27;F:\\genshinUsercount.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>)<span class="comment">#open(&#x27;路径&#x27;,&#x27;打开模式&#x27;,&#x27;编码格式&#x27;)#常用的编码格式 : ascii , utf-8 , Unicode , gbk</span></span><br><span class="line"></span><br><span class="line">r/rb <span class="comment">#以只读方式打开</span></span><br><span class="line">w/wb <span class="comment">#以只写方式打开,若文件不存在则创建新文件,此模式下执行写入会覆盖原来数据</span></span><br><span class="line">a/ab <span class="comment">#以追加方式打开,若文件不存在则创建新文件</span></span><br><span class="line"></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#关闭文件</span></span><br><span class="line">file_01.close()</span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#文件操作前置语句</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> file_01:  </span><br><span class="line"><span class="comment">#with open() as filename : #as后命名文件在代码中的参数名</span></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#读取文件内容</span></span><br><span class="line"><span class="built_in">print</span>(file_01.read(<span class="number">2</span>)) <span class="comment">#file_01.read(字节索引) #当索引为空或-1是为全读</span></span><br><span class="line">content = file_01.read()</span><br><span class="line"></span><br><span class="line">file_01.readline() <span class="comment">#读取指定文件的一行数据,当二次调用.readline()时会读取下一行数据</span></span><br><span class="line"></span><br><span class="line">file_01.readlines(<span class="number">5</span>) <span class="comment">#读取指定文件的多行数据,当索引为空或-1是为全读</span></span><br><span class="line"></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#文件写入</span></span><br><span class="line">file_01.write(<span class="string">&#x27;abcd114514&#x27;</span>) <span class="comment">#在文件末尾写入数据,无法换行</span></span><br><span class="line"></span><br><span class="line">file_01.writelines(<span class="string">&#x27;abcd114514 \n 啊实打实打算&#x27;</span>) <span class="comment">#可用\n进行换行</span></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#获取当前读写索引</span></span><br><span class="line">file_01.tell() <span class="comment">#文件每次被读写一个位置之后会接着上一个位置往下进行读写,此方法可产看当前读写位置索引</span></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#读写索引控制</span></span><br><span class="line">file_01.seek(<span class="number">5</span>,<span class="number">0</span>) <span class="comment">#.seek(位置索引偏移量,指定位置索引) </span></span><br><span class="line"><span class="comment">#指定位置索引值为 0时为文章开头 1时为当前位置 2时为文章结尾</span></span><br><span class="line">_____________________________________________________</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


<h3 id="文件与目录-文件夹-管理"><a href="#文件与目录-文件夹-管理" class="headerlink" title="文件与目录(文件夹)管理"></a>文件与目录(文件夹)管理</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#文件管理需调用os模块</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#删除文件</span></span><br><span class="line">os.remove(<span class="string">&#x27;F:\\mulyilytest\\python_test.txt&#x27;</span>)</span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#文件重命名</span></span><br><span class="line">os.rename(<span class="string">&#x27;F:\\mulyilytest\\pytest.txt&#x27;</span>,<span class="string">&#x27;F:\\mulyilytest\\python_test.txt&#x27;</span>) <span class="comment">#os.rename(旧地址和名字,新) #通常将地址和名字参数化</span></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#创建/删除目录(文件夹)</span></span><br><span class="line">os.mkdir(<span class="string">&#x27;F:\\mulyilytest\\pytteesstt&#x27;</span>) <span class="comment">#创建目录makedirectory</span></span><br><span class="line">os.rmdir(<span class="string">&#x27;F:\\mulyilytest\\pytteesstt&#x27;</span>) <span class="comment">#删除目录removedirectory</span></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#获取当前目录</span></span><br><span class="line">os.getcwd()</span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#更改默认目录</span></span><br><span class="line">os.chdir(<span class="string">&#x27;F:\\mulyilytest&#x27;</span>)</span><br><span class="line"><span class="comment">#os在没有指定路径时会自动在默认中寻找文件,修改默认目录后可不在重复书写路经</span></span><br><span class="line"></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#获取文件名列表</span></span><br><span class="line">os.listdir(<span class="string">&#x27;./&#x27;</span>) <span class="comment">#输出的是列表类型数据 # ./ 表示当前工作目录</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure></div>

<h3 id="数据维度与数据格式化"><a href="#数据维度与数据格式化" class="headerlink" title="数据维度与数据格式化"></a>数据维度与数据格式化</h3><p>在代码输出栏里绘表???神金</p>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cls_x</span>:  <span class="comment"># 创建类; class 类名称</span></span><br><span class="line">    name_a = <span class="number">66</span>  <span class="comment"># 类属性; 属性名 = 属性值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fuc_x</span>(<span class="params">self,value</span>):  <span class="comment"># 实例方法; def 方法名(self);</span></span><br><span class="line">        <span class="comment"># 实例方法的第一个参数总是 self，它指向调用这个方法的具体实例对象</span></span><br><span class="line">        <span class="variable language_">self</span>.value = value  <span class="comment">#实例属性value,可接受外部传参</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.value)</span><br><span class="line">        instan_x = cls_x()  <span class="comment"># 创建类的实例</span></span><br><span class="line">        <span class="built_in">print</span>(instan_x.name_a)  <span class="comment"># 实例访问类属性；输出类属性</span></span><br><span class="line"></span><br><span class="line">        instan_x.name_a = <span class="number">1</span> <span class="comment">#通过实例访问类属性并修改</span></span><br><span class="line">        <span class="built_in">print</span>(instan_x.name_a) <span class="comment">#通过实例修改类属性后实例会在内存中创建一个专属于instan_x的name_a参数,不会对clas_x的name_a产生影响</span></span><br><span class="line">        <span class="built_in">print</span>(cls_x.name_a) <span class="comment">#通过类访问属性发现值并未改变</span></span><br><span class="line"></span><br><span class="line">        instan_x.str_new = <span class="string">&#x27;好i好i好i&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(instan_x.str_new)</span><br><span class="line">        <span class="comment">#print(cls_x.str_new) #类无法调用通过实例创建的新属性</span></span><br><span class="line"></span><br><span class="line">        cls_x.str_new01 = <span class="string">&#x27;n牛牛牛&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(instan_x.str_new01)</span><br><span class="line">        <span class="built_in">print</span>(cls_x.str_new01) <span class="comment">#通过类创建的新属性,类和实例均可调用</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-----------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        cls_x.name_a = <span class="number">9</span> <span class="comment">#通过类访问类属性并修改</span></span><br><span class="line">        <span class="built_in">print</span>(instan_x.name_a) <span class="comment">#通过类修改类属性后不影响实例属性</span></span><br><span class="line">        <span class="built_in">print</span>(cls_x.name_a)</span><br><span class="line">        <span class="comment">#类和实例的属性关系课理解为UE中母材质和材质实例的关系</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod </span><span class="comment"># 类方法修饰符</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fuc_y</span>(<span class="params">cls</span>): <span class="comment">#类方法;; def 方法名(cls);</span></span><br><span class="line">        <span class="comment"># 类方法的第一个参数是 cls，它指向类本身，而不是具体的实例</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;bbbb&#x27;</span>)</span><br><span class="line">        instan_y = cls_x()</span><br><span class="line">        <span class="built_in">print</span>(instan_y.name_a)</span><br><span class="line"></span><br><span class="line">        instan_y.str_new = <span class="string">&#x27;好i好i好i&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(instan_y.str_new)</span><br><span class="line">        <span class="comment">#print(cls_x.str_new) #类无法调用通过实例创建的新属性</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod  </span><span class="comment"># 类方法修饰符</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fuc_z</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">111</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类的实例</span></span><br><span class="line">instance = cls_x()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用实例方法并向其传参;</span></span><br><span class="line">instance.fuc_x(<span class="number">233</span>) <span class="comment">#调用实例方法必须先将类实例化,然后才能调用,该参数传给value而非self</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cls_x.fuc_y() <span class="comment">#调用类方法,类方法可直接通过类调用</span></span><br><span class="line"></span><br><span class="line">cls_x.fuc_z() <span class="comment">#调用静态方法,类方法可直接通过类调用</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>


<h3 id="类创建"><a href="#类创建" class="headerlink" title="类创建"></a>类创建</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cls_x</span>:  <span class="comment"># 创建类; class 类名称</span></span><br><span class="line">    name_a = <span class="number">66</span>  <span class="comment"># 类属性; 属性名 = 属性值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fuc_x</span>(<span class="params">self,value</span>):  <span class="comment"># 实例方法; def 方法名(self);</span></span><br><span class="line">        <span class="variable language_">self</span>.value = value  <span class="comment">#实例属性value,可接受外部传参</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.value)</span><br></pre></td></tr></table></figure></div>

<h3 id="类成员"><a href="#类成员" class="headerlink" title="类成员"></a>类成员</h3><p>类和实例的属性关系课理解为UE中母材质和材质实例的关系</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#类/实例属性</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cls_x</span>:  <span class="comment"># 创建类; class 类名称</span></span><br><span class="line">    name_a = <span class="number">66</span>  <span class="comment"># 类属性; 属性名 = 属性值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fuc_x</span>(<span class="params">self,value</span>):  <span class="comment"># 实例方法; def 方法名(self);</span></span><br><span class="line">        <span class="comment"># 实例方法的第一个参数总是 self，它指向调用这个方法的具体实例对象</span></span><br><span class="line">        <span class="variable language_">self</span>.value = value  <span class="comment">#实例属性value,可接受外部传参</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.value)</span><br><span class="line">        instan_x = cls_x()  <span class="comment"># 创建类的实例</span></span><br><span class="line">        <span class="built_in">print</span>(instan_x.name_a)  <span class="comment"># 实例访问类属性；输出类属性</span></span><br><span class="line"></span><br><span class="line">        instan_x.name_a = <span class="number">1</span> <span class="comment">#通过实例访问类属性并修改</span></span><br><span class="line">        <span class="built_in">print</span>(instan_x.name_a) <span class="comment">#通过实例修改类属性后实例会在内存中创建一个专属于instan_x的name_a参数,不会对clas_x的name_a产生影响</span></span><br><span class="line">        <span class="built_in">print</span>(cls_x.name_a) <span class="comment">#通过类访问属性发现值并未改变</span></span><br><span class="line"></span><br><span class="line">        instan_x.str_new = <span class="string">&#x27;好i好i好i&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(instan_x.str_new)</span><br><span class="line">        <span class="comment">#print(cls_x.str_new) #类无法调用通过实例创建的新属性</span></span><br><span class="line"></span><br><span class="line">        cls_x.str_new01 = <span class="string">&#x27;n牛牛牛&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(instan_x.str_new01)</span><br><span class="line">        <span class="built_in">print</span>(cls_x.str_new01) <span class="comment">#通过类创建的新属性,类和实例均可调用</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;-----------------------------------------&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        cls_x.name_a = <span class="number">9</span> <span class="comment">#通过类访问类属性并修改</span></span><br><span class="line">        <span class="built_in">print</span>(instan_x.name_a) <span class="comment">#通过类修改类属性后不影响实例属性</span></span><br><span class="line">        <span class="built_in">print</span>(cls_x.name_a)</span><br></pre></td></tr></table></figure></div>

<p>关于对象:实例和对象本质是一个东西,均为类的继承体</p>
<h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cls_x</span>:  <span class="comment"># 创建类; class 类名称</span></span><br><span class="line">    name_a = <span class="number">66</span></span><br><span class="line"><span class="comment"># 实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fuc_x</span>(<span class="params">self</span>):  <span class="comment"># 实例方法; def 方法名(self);slef代表函数本身</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;aaaa&#x27;</span>)</span><br><span class="line"><span class="comment">#调用:</span></span><br><span class="line"><span class="comment"># 创建类的实例</span></span><br><span class="line">instance = cls_x()</span><br><span class="line"><span class="comment"># 调用实例方法并向其传参;</span></span><br><span class="line">instance.fuc_x(<span class="number">233</span>) <span class="comment">#调用实例方法必须先将类实例化,然后才能调用,该参数传给value而非self       </span></span><br></pre></td></tr></table></figure></div>

<p>两种方法中属性修改和继承关系是相同的</p>
<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cls_x</span>:  </span><br><span class="line">    name_a = <span class="number">6</span></span><br><span class="line"><span class="comment">#类方法       </span></span><br><span class="line"><span class="meta">    @classmethod </span><span class="comment"># 类方法修饰符</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fuc_y</span>(<span class="params">cls</span>): <span class="comment">#类方法;; def 方法名(cls);cls代表类本身</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;bbbb&#x27;</span>)    </span><br><span class="line"> <span class="comment">#调用:       </span></span><br><span class="line"> cls_x.fuc_y() <span class="comment">#调用类方法,类方法可直接通过类调用 </span></span><br></pre></td></tr></table></figure></div>

<h4 id="类方法-vs-实例方法的区别"><a href="#类方法-vs-实例方法的区别" class="headerlink" title="类方法 vs 实例方法的区别"></a>类方法 vs 实例方法的区别</h4><table>
<thead>
<tr>
<th>特性</th>
<th>实例方法</th>
<th>类方法</th>
</tr>
</thead>
<tbody><tr>
<td>绑定对象</td>
<td>实例（<code>self</code> 指向实例对象）</td>
<td>类（<code>cls</code> 指向类本身）</td>
</tr>
<tr>
<td>装饰器</td>
<td>无特殊装饰器</td>
<td><code>@classmethod</code></td>
</tr>
<tr>
<td>调用方式</td>
<td>通过实例调用</td>
<td>通过类或实例调用</td>
</tr>
<tr>
<td>访问权限</td>
<td>可以访问和修改实例属性和方法</td>
<td>不能访问实例属性，但可访问类属性</td>
</tr>
<tr>
<td>常见用途</td>
<td>操作对象实例，修改实例状态</td>
<td>操作类的状态，通常用于工厂方法</td>
</tr>
</tbody></table>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cls_x</span>:  </span><br><span class="line">    name_a = <span class="number">6</span></span><br><span class="line"><span class="comment">#静态法</span></span><br><span class="line"><span class="meta">    @staticmethod  </span><span class="comment"># 类方法修饰符</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fuc_z</span>():</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">111</span>)</span><br><span class="line"><span class="comment">#调用:</span></span><br><span class="line">cls_x.fuc_z() <span class="comment">#调用静态方法,类方法可直接通过类调用</span></span><br><span class="line">        </span><br></pre></td></tr></table></figure></div>



<h4 id="类方法-vs-静态方法的区别"><a href="#类方法-vs-静态方法的区别" class="headerlink" title="类方法 vs 静态方法的区别"></a>类方法 vs 静态方法的区别</h4><table>
<thead>
<tr>
<th>特性</th>
<th>类方法</th>
<th>静态方法</th>
</tr>
</thead>
<tbody><tr>
<td>绑定对象</td>
<td>类（<code>cls</code> 指向类本身）</td>
<td>无绑定对象</td>
</tr>
<tr>
<td>装饰器</td>
<td><code>@classmethod</code></td>
<td><code>@staticmethod</code></td>
</tr>
<tr>
<td>调用方式</td>
<td>通过类或实例调用</td>
<td>通过类或实例调用</td>
</tr>
<tr>
<td>访问权限</td>
<td>可以访问类属性，不能访问实例属性</td>
<td>不能访问实例或类的任何属性</td>
</tr>
<tr>
<td>常见用途</td>
<td>操作类的状态，创建类方法</td>
<td>定义功能函数，逻辑上和类有关</td>
</tr>
</tbody></table>
<h3 id="私有成员"><a href="#私有成员" class="headerlink" title="私有成员"></a>私有成员</h3><div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cls_x</span> :</span><br><span class="line">    __attribute = <span class="number">8</span>  <span class="comment">#__参数名 = 值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__fuction_1</span>(<span class="params">self</span>): <span class="comment">#__方法名()</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">instanse_x = cls_x()</span><br><span class="line"><span class="comment"># instanse_x.__fuction_1() #无法从外部访问私有方法</span></span><br><span class="line"><span class="comment"># print(instanse_x.__attribute) #无法从外部访问私有参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然私有成员不能直接访问，但可以通过名称改编来访问</span></span><br><span class="line"><span class="built_in">print</span>(instanse_x._cls_x__attribute) <span class="comment">#实例名._类名__属性名</span></span><br></pre></td></tr></table></figure></div>

<p>关于私有成员调用,看封装模块的代码</p>
<h3 id="受保护成员"><a href="#受保护成员" class="headerlink" title="受保护成员"></a>受保护成员</h3><p>除了公有和私有成员，还有一种称为**受保护成员（Protected Members）**的概念，尽管 Python 本身没有严格的受保护机制,用处不大</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">cls_x</span> :</span><br><span class="line">    _attribute = <span class="number">8</span>  <span class="comment">#受保护参数 #_参数名 = 值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__fuction_1</span>(<span class="params">self</span>): <span class="comment">#__方法名(self):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line"></span><br><span class="line">instanse_x = cls_x()</span><br><span class="line"><span class="comment"># instanse_x.__fuction_1() #无法从外部访问私有方法</span></span><br><span class="line"><span class="comment"># print(instanse_x.__attribute) #无法从外部访问私有参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 虽然私有成员不能直接访问，但可以通过名称改编来访问</span></span><br><span class="line"><span class="built_in">print</span>(instanse_x._cls_x__attribute) <span class="comment">#实例名._类名__属性名</span></span><br></pre></td></tr></table></figure></div>

<h4 id="共有成员-vs-私有成员-vs-受保护成员"><a href="#共有成员-vs-私有成员-vs-受保护成员" class="headerlink" title="共有成员 vs 私有成员 vs 受保护成员"></a>共有成员 vs 私有成员 vs 受保护成员</h4><table>
<thead>
<tr>
<th>特性</th>
<th>共有成员（Public Members）</th>
<th>受保护成员（Protected Members）</th>
<th>私有成员（Private Members）</th>
</tr>
</thead>
<tbody><tr>
<td>前缀</td>
<td>无前缀</td>
<td><code>_</code> 开头</td>
<td><code>__</code> 开头</td>
</tr>
<tr>
<td>访问权限</td>
<td>类内外都可访问</td>
<td>子类可访问，外部不推荐访问</td>
<td>只能在类内部访问（但有例外）</td>
</tr>
<tr>
<td>子类访问</td>
<td>可以访问</td>
<td>可以访问</td>
<td>无法直接访问</td>
</tr>
<tr>
<td>外部访问</td>
<td>可以访问</td>
<td>按照惯例不建议访问</td>
<td>不能直接访问</td>
</tr>
<tr>
<td>使用场景</td>
<td>对外公开的成员</td>
<td>半封装，允许子类继承使用</td>
<td>完全封装，隐藏类的实现细节</td>
</tr>
</tbody></table>
<h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法在创建类的对象时自动调用，用来初始化对象的属性。它是类的实例化过程中执行的第一个方法，常用于设置实例的初始状态。</p>
<p>相当于在类本身上附加一系列属性</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, age</span>): <span class="comment">#构造方法 #__int__(self,属性名):</span></span><br><span class="line">        <span class="variable language_">self</span>.name = name  <span class="comment"># 初始化属性 name</span></span><br><span class="line">        <span class="variable language_">self</span>.age = age  <span class="comment"># 初始化属性 age</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">introduce</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;My name is <span class="subst">&#123;self.name&#125;</span>, and I am <span class="subst">&#123;self.age&#125;</span> years old.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建类的实例</span></span><br><span class="line">person1 = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>) <span class="comment">#当 Person 类被实例化时，__init__ 方法被自动调用，设置了 name 和 age 属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用实例方法</span></span><br><span class="line">person1.introduce()  <span class="comment"># 输出: My name is Alice, and I am 30 years old.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h3 id="析构方法"><a href="#析构方法" class="headerlink" title="析构方法"></a>析构方法</h3><p>Python使用垃圾回收机制（Garbage Collection）来处理内存管理，当对象不再被引用时，它会自动调用 <code>__del__</code> 来进行清理。</p>
<p>值得注意的是，Python 的垃圾回收机制是基于引用计数的。当对象不再有任何引用时，Python 会自动回收内存并调用 <code>__del__</code> 方法。但在实际开发中，除非有明确的资源管理需求，通常不需要定义 <code>__del__</code>。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileManager</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, filename</span>):</span><br><span class="line">        <span class="variable language_">self</span>.file = <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;filename&#125;</span> 文件已打开&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__del__</span>(<span class="params">self</span>): <span class="comment">#析构方法 #__del__(self):</span></span><br><span class="line">        <span class="comment"># 在对象被销毁时关闭文件</span></span><br><span class="line">        <span class="variable language_">self</span>.file.close()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;文件已关闭&quot;</span>)</span><br></pre></td></tr></table></figure></div>

<h4 id="构造方法和析构方法的区别："><a href="#构造方法和析构方法的区别：" class="headerlink" title="构造方法和析构方法的区别："></a>构造方法和析构方法的区别：</h4><table>
<thead>
<tr>
<th>特性</th>
<th>构造方法 (<code>__init__()</code>)</th>
<th>析构方法 (<code>__del__()</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>作用</td>
<td>在对象创建时初始化属性</td>
<td>在对象销毁时清理资源</td>
</tr>
<tr>
<td>调用时机</td>
<td>对象实例化时自动调用</td>
<td>对象销毁时自动调用</td>
</tr>
<tr>
<td>使用场景</td>
<td>设置初始状态、传递参数</td>
<td>释放资源（如文件关闭、网络连接关闭等）</td>
</tr>
<tr>
<td>手动调用</td>
<td>通常不需要手动调用，但可以通过类名直接调用构造方法</td>
<td>不需要手动调用，由 Python 自动管理</td>
</tr>
</tbody></table>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>在 Python 中，封装通常结合<strong>访问器方法</strong>（getter 和 setter）来管理属性的访问与修改。访问器方法用于控制对私有或受保护属性的读取和写入</p>
<p>优秀的封装能大大降低维护难度</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#标准封装</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, brand, price,num</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__brand = brand  <span class="comment">#私有属性</span></span><br><span class="line">        <span class="variable language_">self</span>.__price = price</span><br><span class="line">        <span class="variable language_">self</span>.num = num  <span class="comment">#共有属性</span></span><br><span class="line">        </span><br><span class="line">	<span class="comment"># 标准私有值调用方法</span></span><br><span class="line">    <span class="comment"># getter 方法，用于获取私有属性的值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_price</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.__price  </span><br><span class="line">    </span><br><span class="line">	<span class="comment">#标准属性修改方法</span></span><br><span class="line">    <span class="comment"># setter 方法，用于修改私有属性的值</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_price</span>(<span class="params">self, new_price</span>):</span><br><span class="line">        <span class="keyword">if</span> new_price &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="variable language_">self</span>.__price = new_price * <span class="variable language_">self</span>.num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;Price cannot be negative!&quot;</span>)</span><br><span class="line"></span><br><span class="line">car = Car(<span class="string">&quot;Audi&quot;</span>, <span class="number">40000</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(car.get_price())  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改私有属性的值</span></span><br><span class="line">car.set_price(<span class="number">45000</span>)</span><br><span class="line"><span class="built_in">print</span>(car.get_price()) </span><br></pre></td></tr></table></figure></div>

<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>定义一个子类，使它获得代码中已有类的属性和方法</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#单继承（Single Inheritance）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> makes a sound.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个子类，继承自 Animal</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment">#此时Dog类获得了Animal类的所有属性和方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> barks.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Dog 类的实例</span></span><br><span class="line">dog = Dog(<span class="string">&quot;Buddy&quot;</span>)</span><br><span class="line">dog.speak()  <span class="comment"># 输出: Buddy barks.</span></span><br><span class="line">_____________________________________________________</span><br><span class="line"><span class="comment">#多继承（Multiple Inheritance）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义两个父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> makes a sound.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Runner</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> runs fast.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个子类，同时继承 Animal 和 Runner</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(Animal, Runner):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> barks.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Dog 类的实例</span></span><br><span class="line">dog = Dog(<span class="string">&quot;Buddy&quot;</span>)</span><br><span class="line">dog.speak()  <span class="comment"># 输出: Buddy barks.</span></span><br><span class="line">dog.run()    <span class="comment"># 输出: Buddy runs fast.</span></span><br></pre></td></tr></table></figure></div>

<p><strong>单继承</strong>适用于简单的类层次结构，继承关系明确，易于管理。</p>
<p><strong>多继承</strong>可以带来更强的灵活性和功能组合，但要小心类之间的复杂关系以及可能产生的命名冲突</p>
<h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><p>子类和父类具有同名的方法，子类方法会覆盖父类的实现。</p>
<p>子类可以通过 <code>super()</code> 调用被重写的父类方法。</p>
<p>重写的过程中，子类通常会保留父类的功能并增加新的行为，但也可以完全改变父类的方法逻辑</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 父类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> makes a sound&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, breed</span>): <span class="comment">#重写构造方法,在重写后原父类的属性会被覆盖,需要重新调父类构造方法来初始化属性</span></span><br><span class="line">        <span class="comment"># 调用父类的构造方法，初始化 name 属性</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name) </span><br><span class="line">        <span class="comment"># 初始化子类的属性</span></span><br><span class="line">        <span class="variable language_">self</span>.breed = breed</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>): <span class="comment">#重写父类方法</span></span><br><span class="line">        <span class="built_in">super</span>().speak()  <span class="comment"># 调用父类的 speak 方法  #super().父类方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;self.name&#125;</span> is a <span class="subst">&#123;self.breed&#125;</span> and barks&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">dog = Dog(<span class="string">&quot;Buddy&quot;</span>, <span class="string">&quot;Golden Retriever&quot;</span>)</span><br><span class="line">dog.speak()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># Buddy makes a sound</span></span><br><span class="line"><span class="comment"># Buddy is a Golden Retriever and barks</span></span><br></pre></td></tr></table></figure></div>

<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是面向对象编程中的一个重要概念，指的是不同的对象可以对同一个方法或操作作出不同的响应。换句话说，在多态中，<strong>同样的接口，可以根据对象的类型，执行不同的行为</strong>。</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Animal makes a sound&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment">#子类01</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bark&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):  <span class="comment">#子类02</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">speak</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow&quot;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">#创建多态函数</span></span><br><span class="line"><span class="comment">#animal_sound() 函数接受 Animal 类的对象，并调用 speak() 方法</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">animal_sound</span>(<span class="params">animal</span>):</span><br><span class="line">    <span class="built_in">print</span>(animal.speak())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象</span></span><br><span class="line">dog = Dog()  <span class="comment">#实例化后即作为识别参数进入animal_sound() 函数中来决定执行哪个子类方法</span></span><br><span class="line">cat = Cat()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用相同的函数，传入不同的对象</span></span><br><span class="line">animal_sound(dog)  <span class="comment"># 输出: Bark</span></span><br><span class="line">animal_sound(cat)  <span class="comment"># 输出: Meow</span></span><br></pre></td></tr></table></figure></div>

<h3 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h3><p>在 Python 中，运算符本质上是特殊方法的另一种表示方式。例如，<code>+</code> 运算符对应的特殊方法是 <code>__add__()</code>，<code>-</code> 运算符对应的是 <code>__sub__()</code>，等等。通过重载这些特殊方法，我们可以自定义运算符在自定义对象中的行为。</p>
<p><del>(这B玩意改底层算法逻辑,看着都费劲,还容易和别的底层代码出现奇怪的耦合bug,我的评价是,不学!)</del></p>
<p>想要啥新算法自己写方法或者导库,别整这玩意</p>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="variable language_">self</span>.x = x</span><br><span class="line">        <span class="variable language_">self</span>.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="comment"># 重载 + 运算符，定义向量相加</span></span><br><span class="line">        <span class="keyword">return</span> Vector(<span class="variable language_">self</span>.x + other.x, <span class="variable language_">self</span>.y + other.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__sub__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="comment"># 重载 - 运算符，定义向量相减</span></span><br><span class="line">        <span class="keyword">return</span> Vector(<span class="variable language_">self</span>.x - other.x, <span class="variable language_">self</span>.y - other.y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="comment"># 重载 == 运算符，定义向量相等比较</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.x == other.x <span class="keyword">and</span> <span class="variable language_">self</span>.y == other.y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 重载 str() 函数，使对象可读性更强</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Vector(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建向量对象</span></span><br><span class="line">v1 = Vector(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">v2 = Vector(<span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 + 和 - 运算符进行向量运算</span></span><br><span class="line">v3 = v1 + v2</span><br><span class="line">v4 = v1 - v2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(v3)  <span class="comment"># Vector(7, 10)</span></span><br><span class="line"><span class="built_in">print</span>(v4)  <span class="comment"># Vector(-3, -4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个向量是否相等</span></span><br><span class="line"><span class="built_in">print</span>(v1 == v2)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure></div>

<p>下面是 Python 中一些常见的运算符及其对应的特殊方法：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>特殊方法</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td><code>__add__</code></td>
</tr>
<tr>
<td><code>-</code></td>
<td><code>__sub__</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td><code>__mul__</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td><code>__truediv__</code></td>
</tr>
<tr>
<td><code>//</code></td>
<td><code>__floordiv__</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td><code>__mod__</code></td>
</tr>
<tr>
<td><code>**</code></td>
<td><code>__pow__</code></td>
</tr>
<tr>
<td><code>==</code></td>
<td><code>__eq__</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td><code>__ne__</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td><code>__gt__</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td><code>__lt__</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td><code>__ge__</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td><code>__le__</code></td>
</tr>
</tbody></table>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>出异常问GPT,这玩意总结了也没屌用</p>
<p>这里有个好东西<a class="link"   href="https://github.com/lencx/chatgpt" >ChatGPT桌面版<i class="fa-solid fa-arrow-up-right ml-[0.2em] font-light align-text-top text-[0.7em] link-icon"></i></a></p>
<h2 id="Python常用库"><a href="#Python常用库" class="headerlink" title="Python常用库"></a>Python常用库</h2><a class="button  regular" href='https://www.pythoncheatsheet.org/cheatsheet/basics' title='常用库速查'><i class='fa-solid fa-play-circle'></i> 常用库速查</a>

<a class="button  regular" href='https://pypi.org/' title='官方的包管理库'><i class='fa-solid fa-play-circle'></i> 官方的包管理库</a>

<a class="button  regular" href='https://docs.python.org/3/library/' title='官方提供的标准库文档'><i class='fa-solid fa-play-circle'></i> 官方提供的标准库文档</a>

<a class="button  regular" href='https://awesome-python.com/' title='按用途类型筛选库'><i class='fa-solid fa-play-circle'></i> 按用途类型筛选库</a>]]></content>
      <categories>
        <category>PythonNotes</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>C_Note</title>
    <url>/2024/10/14/C_Note/</url>
    <content><![CDATA[<p>C _Base Grammars </p>
<h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><p><strong>C_Language ?  Cat_Language!!!</strong><br><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/images/C_Note/cat_oilpainting.png"
                     
                ></p>
<details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>标准代码架构 </summary>
              <div class='content'>
              <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">// 标准输入输出头文件，用于使用 printf 和 scanf 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个常量宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];  <span class="comment">// 字符数组，用于存储名字</span></span><br><span class="line">    <span class="type">int</span> age;        <span class="comment">// 整数类型，用于存储年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">greet</span><span class="params">(<span class="keyword">struct</span> Person p)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;          <span class="comment">// 两个整数相加的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modifyValue</span><span class="params">(<span class="type">int</span> *ptr)</span>;     <span class="comment">// 使用指针修改变量值的函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，程序的入口</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 变量声明与初始化</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;  <span class="comment">// 声明一个整型变量并赋值</span></span><br><span class="line">    <span class="type">float</span> radius = <span class="number">5.5</span>;  <span class="comment">// 声明一个浮点型变量并赋值</span></span><br><span class="line">    <span class="type">double</span> area;  <span class="comment">// 声明一个双精度浮点型变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 条件判断语句 if-else</span></span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is greater than 5.\n&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;x is less than or equal to 5.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数组的声明与初始化</span></span><br><span class="line">    <span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;  <span class="comment">// 声明一个整型数组</span></span><br><span class="line">    <span class="type">char</span> message[] = <span class="string">&quot;Hello, World!&quot;</span>;  <span class="comment">// 声明并初始化字符数组（字符串）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用循环遍历数组</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Array elements: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算圆的面积</span></span><br><span class="line">    area = PI * radius * radius;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The area of the circle with radius %.2f is %.2f\n&quot;</span>, radius, area);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用函数</span></span><br><span class="line">    <span class="type">int</span> sum = add(<span class="number">5</span>, <span class="number">7</span>);  <span class="comment">// 调用加法函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The sum of 5 and 7 is %d\n&quot;</span>, sum);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针的使用</span></span><br><span class="line">    <span class="type">int</span> value = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Original value: %d\n&quot;</span>, value);</span><br><span class="line">    modifyValue(&amp;value);  <span class="comment">// 使用指针修改变量的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Modified value: %d\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> <span class="title">person1</span>;</span>  <span class="comment">// 声明一个结构体变量</span></span><br><span class="line">    person1.age = <span class="number">30</span>;       <span class="comment">// 赋值</span></span><br><span class="line">    <span class="built_in">strcpy</span>(person1.name, <span class="string">&quot;Alice&quot;</span>);  <span class="comment">// 使用 strcpy 函数复制字符串</span></span><br><span class="line">    greet(person1);  <span class="comment">// 调用 greet 函数，传递结构体变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针与数组</span></span><br><span class="line">    <span class="type">int</span> *ptr = numbers;  <span class="comment">// 指向数组的指针</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;First element using pointer: %d\n&quot;</span>, *ptr);  <span class="comment">// 通过指针访问数组第一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 主函数返回 0 表示程序正常结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：用于打印欢迎信息</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">greet</span><span class="params">(<span class="keyword">struct</span> Person p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello, %s! You are %d years old.\n&quot;</span>, p.name, p.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：两个整数相加并返回结果</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义：使用指针修改值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">modifyValue</span><span class="params">(<span class="type">int</span> *ptr)</span> &#123;</span><br><span class="line">    *ptr = <span class="number">50</span>;  <span class="comment">// 通过指针修改传入的变量值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量在设置后是不能更改的</p>
<p>C语言中的常量可以根据其类型分为以下几类：</p>
<table>
<thead>
<tr>
<th>常量类型</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><strong>整型常量</strong></td>
<td>表示整数的常量，可以是十进制、八进制、十六进制表示。</td>
<td><code>100</code>, <code>0123</code>(八进制), <code>0x1A</code>(十六进制)</td>
</tr>
<tr>
<td><strong>浮点常量</strong></td>
<td>表示小数的常量，包括科学计数法。</td>
<td><code>3.14</code>, <code>1.0e-2</code></td>
</tr>
<tr>
<td><strong>字符常量</strong></td>
<td>表示单个字符的常量，必须用单引号包围。</td>
<td><code>&#39;A&#39;</code>, <code>&#39;9&#39;</code>, <code>&#39;\n&#39;</code></td>
</tr>
<tr>
<td><strong>字符串常量</strong></td>
<td>表示一串字符的常量，必须用双引号包围。</td>
<td><code>&quot;Hello&quot;</code>, <code>&quot;C语言&quot;</code></td>
</tr>
<tr>
<td><strong>符号常量</strong></td>
<td>用<code>#define</code>或<code>const</code>关键字定义的具有固定值的标识符常量。</td>
<td><code>#define PI 3.14</code></td>
</tr>
</tbody></table>
<h4 id="常量宏"><a href="#常量宏" class="headerlink" title="常量宏"></a>常量宏</h4><p>常量宏通常使用<code>#define</code>指令来定义，在预处理阶段会将宏的名称替换为其定义的值,其本质只是简单的文本替换,因此，宏不会进行类型检查、作用域控制等，容易导致一些难以发现的错误</p>
<p>故此,目前阶段仅将其作为文本替换器使用</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全局常量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符型常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> str_a = <span class="string">&#x27;A&#x27;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> str_a = <span class="string">&#x27;\n&#x27;</span>  <span class="comment">//&#x27;\n&#x27;为转义字符,用于字符串换行  ;  &#x27;\b&#x27;,退格  ;  &#x27;\\&#x27;反斜杠即&#x27;/&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量宏</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Π 3.141  <span class="comment">//#define 常量宏名 常量值</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//符号常量</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI (3+2)  <span class="comment">//#define 常量名 含有符号的数字组合</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>  <span class="comment">//函数需定义为int类型,才能在函数中定义并初始化int变量</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = PI*<span class="number">2</span>;  <span class="comment">//这里实际的运算状况是 3+2*7 相当于直接将PI移过来了</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;i = %d\n&quot;</span>,a);  <span class="comment">//输出7,</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<hr>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><table>
<thead>
<tr>
<th>变量类型</th>
<th>描述</th>
<th>范围(根据实现)</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td>整型变量，用于存储整数。</td>
<td>-32,768 到 32,767 (16位系统)，较常见是32位系统</td>
<td><code>int x = 5;</code></td>
</tr>
<tr>
<td><code>float</code></td>
<td>单精度浮点数，用于存储小数。</td>
<td>约为 ±3.4e–38 到 ±3.4e+38</td>
<td><code>float y = 3.14;</code></td>
</tr>
<tr>
<td><code>double</code></td>
<td>双精度浮点数，表示更大范围和更精确的小数。</td>
<td>±1.7e–308 到 ±1.7e+308</td>
<td><code>double z = 2.71828;</code></td>
</tr>
<tr>
<td><code>char</code></td>
<td>字符变量，存储单个字符（ASCII码）。</td>
<td>-128 到 127</td>
<td><code>char c = &#39;A&#39;;</code></td>
</tr>
<tr>
<td><code>long</code></td>
<td>长整型，存储更大的整数。</td>
<td>-2^31 到 2^31-1 (32位系统)</td>
<td><code>long n = 1000000;</code></td>
</tr>
<tr>
<td><code>short</code></td>
<td>短整型，存储较小的整数。</td>
<td>-32,768 到 32,767</td>
<td><code>short s = 32767;</code></td>
</tr>
<tr>
<td><code>unsigned</code></td>
<td>无符号整型，用于存储非负数。</td>
<td>0 到 65535 (16位系统)</td>
<td><code>unsigned int u = 5;</code></td>
</tr>
</tbody></table>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">5</span>;  <span class="comment">//数据类型 变量名 = 值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//混合运算中的变量强制转换</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">5</span>;</span><br><span class="line">    <span class="type">float</span> f = i/<span class="number">2</span>; <span class="comment">//输出结果为2.000  </span></span><br><span class="line">    <span class="comment">//因为左右操作数均为整形变量,i/2的整形运算结果会省去小数变为2</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> f = (<span class="type">float</span>)i/<span class="number">2</span>; <span class="comment">//(数据类型)变量名  </span></span><br><span class="line">    <span class="comment">//此时结果为2.5,由此也可推断混合运算的运算方法以左操作数为准</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意,在C语言中当变量被定义后它的类型就无法改变了,上文的<code>(float)i</code>应被视为一种将<code>i</code>转换为float形式的新的临时变量的表达式</p>
<p>C语言中的混合运算以<code>float f = i/2;</code>为例,他的结果数据类型和运算数据类型是分开的,流程上来讲是先判断操作数的数据类型,当左右操作数均为整形时执行整形计算,其他情况执行浮点运算,此时得出的结果为int类型数据,随后将结果返回变量<code>f</code>时被转换为float类型</p>
<p>下面是 C 语言中常用的变量类型的表格展示，包括每种类型的描述、占用的内存大小以及表示的范围</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>描述</th>
<th>大小（通常）</th>
<th>范围</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td>整数类型，表示带符号的整型数据</td>
<td>4 字节(考试可能会问)</td>
<td>-2,147,483,648 到 2,147,483,647</td>
</tr>
<tr>
<td><code>unsigned int</code></td>
<td>无符号整数类型</td>
<td>4 字节</td>
<td>0 到 4,294,967,295</td>
</tr>
<tr>
<td><code>short</code></td>
<td>短整型，带符号</td>
<td>2 字节</td>
<td>-32,768 到 32,767</td>
</tr>
<tr>
<td><code>unsigned short</code></td>
<td>无符号短整型</td>
<td>2 字节</td>
<td>0 到 65,535</td>
</tr>
<tr>
<td><code>long</code></td>
<td>长整型，带符号</td>
<td>8 字节</td>
<td>-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td>
</tr>
<tr>
<td><code>unsigned long</code></td>
<td>无符号长整型</td>
<td>8 字节</td>
<td>0 到 18,446,744,073,709,551,615</td>
</tr>
<tr>
<td><code>float</code></td>
<td>单精度浮点型，用于表示小数</td>
<td>4 字节</td>
<td>3.4E-38 到 3.4E+38（6 位有效数字）</td>
</tr>
<tr>
<td><code>double</code></td>
<td>双精度浮点型，用于表示高精度小数</td>
<td>8 字节</td>
<td>1.7E-308 到 1.7E+308（15 位有效数字）</td>
</tr>
<tr>
<td><code>char</code></td>
<td>字符类型，用于表示单个字符</td>
<td>1 字节</td>
<td>-128 到 127（或 0 到 255，取决于系统）</td>
</tr>
<tr>
<td><code>unsigned char</code></td>
<td>无符号字符类型</td>
<td>1 字节</td>
<td>0 到 255</td>
</tr>
<tr>
<td><code>long double</code></td>
<td>扩展精度浮点型</td>
<td>16 字节</td>
<td>3.4E-4932 到 1.1E+4932（18-19 位有效数字）</td>
</tr>
<tr>
<td><code>_Bool</code></td>
<td>布尔类型（C99 引入），表示真或假</td>
<td>1 字节</td>
<td>0（假）或 1（真）</td>
</tr>
<tr>
<td><code>void</code></td>
<td>无类型，通常用于函数返回类型和指针类型</td>
<td>无</td>
<td>无法表示数据</td>
</tr>
</tbody></table>
<hr>
<h3 id="标准输出函数"><a href="#标准输出函数" class="headerlink" title="标准输出函数"></a>标准输出函数</h3><h4 id="prtinf"><a href="#prtinf" class="headerlink" title="prtinf( )"></a><code>prtinf( )</code></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1234</span>;</span><br><span class="line">    <span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    <span class="type">float</span> e = <span class="number">1.3</span>;</span><br><span class="line">         </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Integer: %d\n Character: %c\n&quot;</span>, a, c); <span class="comment">//printf(&quot;字符串%格式化类型&quot; ,数据)    </span></span><br><span class="line">    <span class="comment">//注意 当改行代码有多个变量需要被打印时C语言是按照从左向右的顺序来识别参数的,故参数顺序需一一对应</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//修饰符混合使用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Integer: %7d\nFloat: %-7.3f\n&quot;</span>, a, e);  </span><br><span class="line">    <span class="comment">// %-7.3f 意思为 左对齐;字符最小宽度为7;浮点精度为小数点后3位;浮点数据类型</span></span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></div>

<h4 id="puts"><a href="#puts" class="headerlink" title="puts( )"></a><code>puts( )</code></h4><p>输出一个字符串到标准输出（通常是显示器）。<code>puts()</code> 会自动在输出的字符串末尾加上一个换行符</p>
<p><code>int puts(const char *str);</code></p>
<ul>
<li>参数 <code>str</code> 是要输出的字符串。</li>
<li>返回值为非负整数，表示写入的字符数量。如果发生错误，返回 <code>EOF</code>（即 -1）。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    <span class="built_in">puts</span>(str);  <span class="comment">// 输出字符串并自动换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h4 id="常用格式说明符"><a href="#常用格式说明符" class="headerlink" title="常用格式说明符"></a>常用格式说明符</h4><table>
<thead>
<tr>
<th>格式说明符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>%d</code></td>
<td>以 <strong>十进制</strong>形式输出带符号整数</td>
<td><code>printf(&quot;%d&quot;, 123);</code> &#x3D;&gt; <code>123</code></td>
</tr>
<tr>
<td><code>%i</code></td>
<td>以 <strong>十进制</strong>形式输出带符号整数（与 <code>%d</code> 相同）</td>
<td><code>printf(&quot;%i&quot;, 123);</code> &#x3D;&gt; <code>123</code></td>
</tr>
<tr>
<td><code>%u</code></td>
<td>以 <strong>十进制</strong>形式输出无符号整数</td>
<td><code>printf(&quot;%u&quot;, 123);</code> &#x3D;&gt; <code>123</code></td>
</tr>
<tr>
<td><code>%f</code></td>
<td>以 <strong>浮点数</strong>形式输出</td>
<td><code>printf(&quot;%f&quot;, 3.14);</code> &#x3D;&gt; <code>3.140000</code></td>
</tr>
<tr>
<td><code>%e</code></td>
<td>以 <strong>科学计数法</strong>形式输出浮点数</td>
<td><code>printf(&quot;%e&quot;, 123.45);</code> &#x3D;&gt; <code>1.234500e+02</code></td>
</tr>
<tr>
<td><code>%g</code></td>
<td>自动选择使用 <code>%e</code> 或 <code>%f</code> 格式</td>
<td><code>printf(&quot;%g&quot;, 123.45);</code> &#x3D;&gt; <code>123.45</code></td>
</tr>
<tr>
<td><code>%c</code></td>
<td>输出单个字符</td>
<td><code>printf(&quot;%c&quot;, &#39;A&#39;);</code> &#x3D;&gt; <code>A</code></td>
</tr>
<tr>
<td><code>%s</code></td>
<td>输出字符串</td>
<td><code>printf(&quot;%s&quot;, &quot;Hello&quot;);</code> &#x3D;&gt; <code>Hello</code></td>
</tr>
<tr>
<td><code>%x</code></td>
<td>以 <strong>小写十六进制</strong>形式输出无符号整数</td>
<td><code>printf(&quot;%x&quot;, 255);</code> &#x3D;&gt; <code>ff</code></td>
</tr>
<tr>
<td><code>%X</code></td>
<td>以 <strong>大写十六进制</strong>形式输出无符号整数</td>
<td><code>printf(&quot;%X&quot;, 255);</code> &#x3D;&gt; <code>FF</code></td>
</tr>
<tr>
<td><code>%o</code></td>
<td>以 <strong>八进制</strong>形式输出无符号整数</td>
<td><code>printf(&quot;%o&quot;, 255);</code> &#x3D;&gt; <code>377</code></td>
</tr>
<tr>
<td><code>%p</code></td>
<td>输出指针的值（地址）</td>
<td><code>printf(&quot;%p&quot;, &amp;a);</code> &#x3D;&gt; <code>0x7ff...</code></td>
</tr>
<tr>
<td><code>%%</code></td>
<td>输出百分号 <code>%</code> 本身</td>
<td><code>printf(&quot;%%&quot;);</code> &#x3D;&gt; <code>%</code></td>
</tr>
</tbody></table>
<h4 id="其他格式化修饰符"><a href="#其他格式化修饰符" class="headerlink" title="其他格式化修饰符"></a>其他格式化修饰符</h4><table>
<thead>
<tr>
<th>修饰符</th>
<th>描述</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>-</code></td>
<td>左对齐（默认右对齐）</td>
<td><code>printf(&quot;%-10d&quot;, 123);</code> &#x3D;&gt; <code>123</code></td>
</tr>
<tr>
<td><code>+</code></td>
<td>强制输出数值符号（正数显示 <code>+</code> 号）</td>
<td><code>printf(&quot;%+d&quot;, 123);</code> &#x3D;&gt; <code>+123</code></td>
</tr>
<tr>
<td><code> </code></td>
<td>正数前输出空格，负数前输出 <code>-</code> 号</td>
<td><code>printf(&quot;% d&quot;, 123);</code> &#x3D;&gt; <code>123</code></td>
</tr>
<tr>
<td><code>0</code></td>
<td>用零填充（通常用于数字）</td>
<td><code>printf(&quot;%04d&quot;, 5);</code> &#x3D;&gt; <code>0005</code></td>
</tr>
<tr>
<td><code>#</code></td>
<td>对于 <code>%o</code>、<code>%x</code> 或 <code>%X</code>，显示进制前缀</td>
<td><code>printf(&quot;%#x&quot;, 255);</code> &#x3D;&gt; <code>0xff</code></td>
</tr>
<tr>
<td>数字</td>
<td>最小字段宽度</td>
<td><code>printf(&quot;%5d&quot;, 12);</code> &#x3D;&gt; <code>12</code></td>
</tr>
<tr>
<td><code>.数字</code></td>
<td>精度控制，用于浮点数</td>
<td><code>printf(&quot;%.2f&quot;, 3.14159);</code> &#x3D;&gt; <code>3.14</code></td>
</tr>
</tbody></table>
<hr>
<h3 id="标准读取函数"><a href="#标准读取函数" class="headerlink" title="标准读取函数"></a>标准读取函数</h3><h4 id="1-scanf"><a href="#1-scanf" class="headerlink" title="1.scanf( )"></a>1.<code>scanf( )</code></h4><p><code>scanf</code> 是 C 语言中用于从标准输入（通常是键盘）读取数据的函数。它可以根据指定的格式字符串，将输入的内容转换为对应的变量值,但他在Visual Studio 2022已被弃用,改用更安全的<code>scanf_s</code> </p>
<p><code>scanf_s</code> 是 <code>scanf</code> 的安全版本，要求为字符串输入提供额外的参数，指定缓冲区的大小，以防止缓冲区溢出。在传入数组时缓冲区大小需要和数组长度相等,否者会出现致命bug,<code> (unsigned)sizeof(a)</code> 是常用的自主获取组长度的方法,传入单个数字时则不需要额外参数</p>
<p><code>scanf_s</code> 向参数传入数据时实际是向该数据的内存地址传值,因此需写为<code>&amp;变量名 </code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//传入数字</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enter a number:&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;num); <span class="comment">//传入数据时实际是向该数据的内存地址传值,因此需写为&amp;变量名</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you enter number is %d\n&quot;</span>, num);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//传入字符串</span></span><br><span class="line">    <span class="type">char</span> a[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enter a string(max length is 9):&quot;</span>);</span><br><span class="line">    <span class="comment">//scanf_s(&quot;%s&quot;,a,10);</span></span><br><span class="line">    scanf_s(<span class="string">&quot;%s&quot;</span>, a, (<span class="type">unsigned</span>)<span class="keyword">sizeof</span>(a));  <span class="comment">// 传入数组a以及它的大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you enter string is %s\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//混合传入</span></span><br><span class="line">    <span class="type">char</span> c[<span class="number">10</span>];</span><br><span class="line">    <span class="type">float</span> f[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enter a string and float (max length is 9):\n&quot;</span>);</span><br><span class="line">    <span class="comment">//scanf_s(&quot;%s&quot;,a,10);</span></span><br><span class="line">    scanf_s(<span class="string">&quot;%s&quot;</span>,c, (<span class="type">unsigned</span>)<span class="keyword">sizeof</span>(c)); </span><br><span class="line">    scanf_s(<span class="string">&quot;%f&quot;</span>,&amp;f[<span class="number">0</span>]); <span class="comment">//数组只以单个索引的形式传入值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you enter string is %s\nyou enter float is%f\n&quot;</span>,c,f[<span class="number">0</span>]);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//scanf已被启用,采用更安全感的scanf_s</span></span><br></pre></td></tr></table></figure></div>
<p><code>(unsigned)</code> 是一个<strong>类型转换运算符</strong>，它将 <code>sizeof(a)</code> 的结果强制转换为无符号整数类型 <code>unsigned int</code></p>
<p>这是为了确保传递给 <code>scanf_s</code> 的第三个参数是 <code>unsigned int</code> 类型，而不是 <code>size_t</code>，以避免类型不匹配的问题………..规范化保守策略总是好的</p>
<h4 id="关于混合传值"><a href="#关于混合传值" class="headerlink" title="关于混合传值"></a>关于混合传值</h4><p>scanf通常读数读到空格就会中断,因此一次向多个变量传值使用空格来中断第一个传值过程,再次输入则向下一个变量传值</p>
<h4 id="2-gets"><a href="#2-gets" class="headerlink" title="2.gets( )"></a><code>2.gets( )</code></h4><p>用于获取一行的输入,遇到\n时中断,但<code>gets()</code> 函数不安全，因为它没有检查缓冲区的大小。输入的字符串如果超过数组大小，可能会导致缓冲区溢出，带来严重的安全漏洞。因此，<code>gets()</code> 已经在 C11 标准中被废弃，不推荐使用。</p>
<p>由于 <code>gets()</code> 存在安全性问题，通常建议使用更安全的替代函数 <code>fgets()</code>：</p>
<p><code>fgets(str, sizeof(str), stdin)</code>：<code>str</code> 是字符数组，<code>sizeof(str)</code> 表示最多读取的字符数，<code>stdin</code> 是标准输入流。<code>fgets()</code> 会在读取到换行符或者到达指定字符数时停止</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gets&amp;fgets</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> f[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enter a string and float (max length is 9):\n&quot;</span>);</span><br><span class="line">    <span class="comment">//gets(f);</span></span><br><span class="line">    fgets(&amp;f,<span class="keyword">sizeof</span>(f), <span class="built_in">stdin</span>); <span class="comment">//fgets(字符数组变量名,数组长度,sthdin)</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;you enter int is %s\n&quot;</span>, f);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>sp : get( )在获取字符串并传给数组时会自动在末尾加上\0</p>
<h4 id="格式说明符"><a href="#格式说明符" class="headerlink" title="格式说明符"></a>格式说明符</h4><p><code>scanf</code> 函数根据 <strong>格式说明符</strong> 将输入的字符转换为相应的数据类型。以下是常用的格式说明符：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>格式说明符</th>
<th>示例代码</th>
<th>示例输入</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td><code>%d</code></td>
<td><code>scanf_s(&quot;%d&quot;, &amp;num);</code></td>
<td>123</td>
<td>读取一个十进制整数。</td>
</tr>
<tr>
<td><code>float</code></td>
<td><code>%f</code></td>
<td><code>scanf_s(&quot;%f&quot;, &amp;flt);</code></td>
<td>3.14</td>
<td>读取一个浮点数。</td>
</tr>
<tr>
<td><code>double</code></td>
<td><code>%lf</code></td>
<td></td>
<td>3.1415</td>
<td>读取一个双精度浮点数。</td>
</tr>
<tr>
<td><code>char</code></td>
<td><code>%c</code></td>
<td><code>scanf_s(&quot; %c&quot;, &amp;ch);</code></td>
<td>A</td>
<td>读取一个字符（包括空白字符）。</td>
</tr>
<tr>
<td>字符串</td>
<td><code>%s</code></td>
<td><code>scanf_s(&quot;%s&quot;, str,(unsigned)sizeof(str));</code></td>
<td>hello</td>
<td>读取字符串，遇到空白符停止。</td>
</tr>
<tr>
<td>无符号整数</td>
<td><code>%u</code></td>
<td></td>
<td>123</td>
<td>读取一个无符号整数。</td>
</tr>
<tr>
<td>八进制整数</td>
<td><code>%o</code></td>
<td></td>
<td>017</td>
<td>读取一个八进制整数。</td>
</tr>
<tr>
<td>十六进制整数</td>
<td><code>%x</code></td>
<td></td>
<td>0x1F</td>
<td>读取一个十六进制整数。</td>
</tr>
<tr>
<td>长整数</td>
<td><code>%ld</code></td>
<td></td>
<td>123456</td>
<td>读取一个长整型变量。</td>
</tr>
<tr>
<td>长长整数</td>
<td><code>%lld</code></td>
<td></td>
<td>12345678</td>
<td>读取一个长长整型变量。</td>
</tr>
<tr>
<td>指针</td>
<td><code>%p</code></td>
<td></td>
<td>0x7ffee</td>
<td>读取一个指针类型的地址。</td>
</tr>
</tbody></table>
<hr>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. <strong>算术运算符</strong></h4><p>算术运算符用于执行基本的数学运算，如加法、减法、乘法、除法等。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>+</code></td>
<td>加法</td>
<td><code>a + b</code></td>
<td><code>a</code> 与 <code>b</code> 相加</td>
</tr>
<tr>
<td><code>-</code></td>
<td>减法</td>
<td><code>a - b</code></td>
<td><code>a</code> 减去 <code>b</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>乘法</td>
<td><code>a * b</code></td>
<td><code>a</code> 乘以 <code>b</code></td>
</tr>
<tr>
<td><code>/</code></td>
<td>除法</td>
<td><code>a / b</code></td>
<td><code>a</code> 除以 <code>b</code></td>
</tr>
<tr>
<td><code>%</code></td>
<td>取模（余数）</td>
<td><code>a % b</code></td>
<td><code>a</code> 除以 <code>b</code> 的余数</td>
</tr>
<tr>
<td><code>++</code></td>
<td>自增</td>
<td><code>++a</code> 或 <code>a++</code></td>
<td><code>a</code> 递增 1</td>
</tr>
<tr>
<td><code>--</code></td>
<td>自减</td>
<td><code>--a</code> 或 <code>a--</code></td>
<td><code>a</code> 递减 1</td>
</tr>
</tbody></table>
<ul>
<li><code>++a</code> 和 <code>a++</code>：前者是<strong>前置自增</strong>（先加再用），后者是<strong>后置自增</strong>（先用再加）。</li>
<li><code>--a</code> 和 <code>a--</code>：类似地，分别为前置和后置自减。</li>
</ul>
<h4 id="2-关系运算符"><a href="#2-关系运算符" class="headerlink" title="2. 关系运算符"></a>2. <strong>关系运算符</strong></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> a = <span class="number">123</span>;</span><br><span class="line">error <span class="title function_">if</span> <span class="params">(<span class="number">3</span> &lt; a &lt; <span class="number">10</span>)</span>&#125;  <span class="comment">//比较运算符无法进行中间值判断</span></span><br><span class="line">    <span class="comment">//由于比较运算符返回的是0和1值,因此 3 &lt; a &lt; 10 实际执行的是result=3&lt;a和result&lt;10,因为result必定为0或1,故此判断式无效</span></span><br><span class="line">      <span class="title function_">if</span> <span class="params">(<span class="number">3</span> &lt; a &amp;&amp; a &lt; <span class="number">10</span>)</span> <span class="comment">//正确写法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p>关系运算符用于比较两个操作数，结果返回布尔值 <code>1</code>（真）或 <code>0</code>（假）。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>==</code></td>
<td>等于</td>
<td><code>a == b</code></td>
<td>如果 <code>a</code> 等于 <code>b</code>，返回 <code>1</code>；否则返回 <code>0</code></td>
</tr>
<tr>
<td><code>!=</code></td>
<td>不等于</td>
<td><code>a != b</code></td>
<td>如果 <code>a</code> 不等于 <code>b</code>，返回 <code>1</code>；否则返回 <code>0</code></td>
</tr>
<tr>
<td><code>&gt;</code></td>
<td>大于</td>
<td><code>a &gt; b</code></td>
<td>如果 <code>a</code> 大于 <code>b</code>，返回 <code>1</code>；否则返回 <code>0</code></td>
</tr>
<tr>
<td><code>&lt;</code></td>
<td>小于</td>
<td><code>a &lt; b</code></td>
<td>如果 <code>a</code> 小于 <code>b</code>，返回 <code>1</code>；否则返回 <code>0</code></td>
</tr>
<tr>
<td><code>&gt;=</code></td>
<td>大于等于</td>
<td><code>a &gt;= b</code></td>
<td>如果 <code>a</code> 大于等于 <code>b</code>，返回 <code>1</code>；否则返回 <code>0</code></td>
</tr>
<tr>
<td><code>&lt;=</code></td>
<td>小于等于</td>
<td><code>a &lt;= b</code></td>
<td>如果 <code>a</code> 小于等于 <code>b</code>，返回 <code>1</code>；否则返回 <code>0</code></td>
</tr>
</tbody></table>
<h4 id="3-逻辑运算符"><a href="#3-逻辑运算符" class="headerlink" title="3. 逻辑运算符"></a>3. <strong>逻辑运算符</strong></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>; </span><br><span class="line">    i &amp;&amp; <span class="title function_">printf</span><span class="params">(<span class="string">&quot;y ct see me \n&quot;</span>)</span>;  <span class="comment">//此时i被当作一个判断值使用</span></span><br><span class="line">    <span class="comment">//逻辑与短路运算,当i为0时不执行,i为1时执行逻辑语后的表达式</span></span><br><span class="line">    <span class="comment">//等价于下列if语句</span></span><br><span class="line">    <span class="keyword">if</span> (i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;y ct see me \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>; </span><br><span class="line">    a || <span class="built_in">printf</span>(<span class="string">&quot;y ct see me \n&quot;</span>);  <span class="comment">//此时i被当作一个判断值使用</span></span><br><span class="line">    <span class="comment">//逻辑或短路运算,当a为1时不执行,i为0时执行逻辑语后的表达式</span></span><br><span class="line">    <span class="comment">//等价于下列if语句</span></span><br><span class="line">    <span class="keyword">if</span> (!a)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;y ct see me \n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>逻辑运算符用于布尔运算，常用于条件语句中的复杂判断。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与</td>
<td><code>a &amp;&amp; b</code></td>
<td>如果 <code>a</code> 和 <code>b</code> 都为真，返回 <code>1</code>；否则返回 <code>0</code></td>
</tr>
<tr>
<td>||</td>
<td>逻辑或</td>
<td>a || b</td>
<td>如果 <code>a</code> 或 <code>b</code> 任一个为真，返回 <code>1</code>；否则返回 <code>0</code></td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非</td>
<td><code>!a</code></td>
<td>如果 <code>a</code> 为假，返回 <code>1</code>；否则返回 <code>0</code></td>
</tr>
</tbody></table>
<h4 id="4-位运算符"><a href="#4-位运算符" class="headerlink" title="4. 位运算符"></a>4. <strong>位运算符</strong></h4><p>位运算符用于位级操作，操作数被视为位模式而非数值。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>按位与</td>
<td><code>a &amp; b</code></td>
<td><code>a</code> 和 <code>b</code> 按位与</td>
</tr>
<tr>
<td>|</td>
<td>按位或</td>
<td>a | b</td>
<td><code>a</code> 和 <code>b</code> 按位或</td>
</tr>
<tr>
<td><code>^</code></td>
<td>按位异或</td>
<td><code>a ^ b</code></td>
<td><code>a</code> 和 <code>b</code> 按位异或</td>
</tr>
<tr>
<td><code>~</code></td>
<td>按位取反</td>
<td><code>~a</code></td>
<td><code>a</code> 的按位取反</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td><code>a &lt;&lt; 2</code></td>
<td><code>a</code> 左移 2 位</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td><code>a &gt;&gt; 2</code></td>
<td><code>a</code> 右移 2 位</td>
</tr>
</tbody></table>
<h4 id="5-赋值运算符"><a href="#5-赋值运算符" class="headerlink" title="5. 赋值运算符"></a>5. <strong>赋值运算符</strong></h4><p>赋值运算符用于为变量赋值，通常可以结合算术运算符进行简化操作。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>=</code></td>
<td>赋值</td>
<td><code>a = b</code></td>
<td>将 <code>b</code> 的值赋给 <code>a</code></td>
</tr>
<tr>
<td><code>+=</code></td>
<td>加后赋值</td>
<td><code>a += b</code></td>
<td><code>a = a + b</code></td>
</tr>
<tr>
<td><code>-=</code></td>
<td>减后赋值</td>
<td><code>a -= b</code></td>
<td><code>a = a - b</code></td>
</tr>
<tr>
<td><code>*=</code></td>
<td>乘后赋值</td>
<td><code>a *= b</code></td>
<td><code>a = a * b</code></td>
</tr>
<tr>
<td><code>/=</code></td>
<td>除后赋值</td>
<td><code>a /= b</code></td>
<td><code>a = a / b</code></td>
</tr>
<tr>
<td><code>%=</code></td>
<td>取模后赋值</td>
<td><code>a %= b</code></td>
<td><code>a = a % b</code></td>
</tr>
<tr>
<td><code>&lt;&lt;=</code></td>
<td>左移后赋值</td>
<td><code>a &lt;&lt;= 2</code></td>
<td><code>a = a &lt;&lt; 2</code></td>
</tr>
<tr>
<td><code>&gt;&gt;=</code></td>
<td>右移后赋值</td>
<td><code>a &gt;&gt;= 2</code></td>
<td><code>a = a &gt;&gt; 2</code></td>
</tr>
<tr>
<td><code>&amp;=</code></td>
<td>按位与后赋值</td>
<td><code>a &amp;= b</code></td>
<td><code>a = a &amp; b</code></td>
</tr>
<tr>
<td><code>^=</code></td>
<td>按位异或后赋值</td>
<td><code>a ^= b</code></td>
<td><code>a = a ^ b</code></td>
</tr>
<tr>
<td>|&#x3D;</td>
<td>按位或后赋值</td>
<td>a |&#x3D; b</td>
<td>a &#x3D; a | b</td>
</tr>
</tbody></table>
<h4 id="6-条件运算符（三元运算符）"><a href="#6-条件运算符（三元运算符）" class="headerlink" title="6. 条件运算符（三元运算符）"></a>6. <strong>条件运算符（三元运算符）</strong></h4><p>条件运算符用于根据条件的真假执行不同的表达式。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>? :</code></td>
<td>条件表达式（类似 if-else）</td>
<td><code>a ? b : c</code></td>
<td>如果 <code>a</code> 为真，执行 <code>b</code>，否则执行 <code>c</code></td>
</tr>
</tbody></table>
<h4 id="7-其他运算符"><a href="#7-其他运算符" class="headerlink" title="7. 其他运算符"></a>7. <strong>其他运算符</strong></h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> c = <span class="keyword">sizeof</span>(a); <span class="comment">//计算数据的字节大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;num size is %d\n&quot;</span>, c); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>除了上述常用的运算符，还有一些其他的运算符，包括取地址、取值、大小、逗号等。</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>示例</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>取地址</td>
<td><code>&amp;a</code></td>
<td>返回变量 <code>a</code> 的地址</td>
</tr>
<tr>
<td><code>*</code></td>
<td>指针解引用</td>
<td><code>*p</code></td>
<td>返回指针 <code>p</code> 指向的值</td>
</tr>
<tr>
<td><code>sizeof</code></td>
<td>计算数据类型大小</td>
<td><code>sizeof(a)</code></td>
<td>返回 <code>a</code> 的字节大小</td>
</tr>
<tr>
<td><code>,</code></td>
<td>逗号表达式</td>
<td><code>a = (x++, y++)</code></td>
<td>先执行 <code>x++</code>，再执行 <code>y++</code></td>
</tr>
<tr>
<td><code>-&gt;</code></td>
<td>结构体指针成员访问</td>
<td><code>p-&gt;member</code></td>
<td>访问指针 <code>p</code> 指向的结构体的成员</td>
</tr>
<tr>
<td><code>.</code></td>
<td>结构体成员访问</td>
<td><code>s.member</code></td>
<td>访问结构体 <code>s</code> 的成员</td>
</tr>
</tbody></table>
<h4 id="7-运算符优先级"><a href="#7-运算符优先级" class="headerlink" title="7.运算符优先级"></a>7.运算符优先级</h4><details class="blue" data-header-exclude><summary><i class="fa-solid fa-chevron-right"></i>算数 > 关系 > 逻辑 ：表格如下 </summary>
              <div class='content'>
              <p>C语言运算符优先级表</p><table><thead><tr><th>优先级最高符号</th><th>名称或含义</th><th>使用形式</th><th>结合方向</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td><code>()</code></td><td>括号</td><td>表达式</td><td>左结合</td></tr><tr><td></td><td><code>[]</code></td><td>数组下标</td><td>表达式</td><td>左结合</td></tr><tr><td></td><td><code>-&gt;</code></td><td>取结构体成员（指针）</td><td>表达式</td><td>左结合</td></tr><tr><td></td><td><code>.</code></td><td>取结构体成员（非指针）</td><td>表达式</td><td>左结合</td></tr><tr><td></td><td><code>sizeof</code></td><td>返回数据类型大小</td><td>表达式</td><td>左结合</td></tr><tr><td>2</td><td><code>!</code></td><td>逻辑非</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>~</code></td><td>位取反</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>++</code></td><td>自增</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>--</code></td><td>自减</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>-</code></td><td>负号</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>*</code></td><td>指针</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>&amp;</code></td><td>取地址</td><td>表达式</td><td>右结合</td></tr><tr><td>3</td><td><code>*</code></td><td>乘</td><td>表达式</td><td>左结合</td></tr><tr><td></td><td><code>/</code></td><td>除</td><td>表达式</td><td>左结合</td></tr><tr><td></td><td><code>%</code></td><td>取余</td><td>表达式</td><td>左结合</td></tr><tr><td>4</td><td><code>+</code></td><td>加</td><td>表达式</td><td>左结合</td></tr><tr><td></td><td><code>-</code></td><td>减</td><td>表达式</td><td>左结合</td></tr><tr><td>5</td><td><code>&lt;&lt;</code></td><td>左移</td><td>表达式</td><td>左结合</td></tr><tr><td></td><td><code>&gt;&gt;</code></td><td>右移</td><td>表达式</td><td>左结合</td></tr><tr><td>6</td><td><code>&lt;</code></td><td>小于</td><td>表达式</td><td>左结合</td></tr><tr><td></td><td><code>&lt;=</code></td><td>小于等于</td><td>表达式</td><td>左结合</td></tr><tr><td></td><td><code>&gt;</code></td><td>大于</td><td>表达式</td><td>左结合</td></tr><tr><td></td><td><code>&gt;=</code></td><td>大于等于</td><td>表达式</td><td>左结合</td></tr><tr><td>7</td><td><code>==</code></td><td>等于</td><td>表达式</td><td>左结合</td></tr><tr><td></td><td><code>!=</code></td><td>不等</td><td>表达式</td><td>左结合</td></tr><tr><td>8</td><td><code>&amp;</code></td><td>按位与</td><td>表达式</td><td>左结合</td></tr><tr><td>9</td><td><code>^</code></td><td>按位异或</td><td>表达式</td><td>左结合</td></tr><tr><td>10</td><td>|</td><td>按位或</td><td>表达式</td><td>左结合</td></tr><tr><td>11</td><td><code>&amp;&amp;</code></td><td>逻辑与</td><td>表达式</td><td>左结合</td></tr><tr><td>12</td><td>||</td><td>逻辑或</td><td>表达式</td><td>左结合</td></tr><tr><td>13</td><td><code>? :</code></td><td>条件运算符</td><td>表达式</td><td>右结合</td></tr><tr><td>14</td><td><code>=</code></td><td>赋值</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>+=</code></td><td>加赋值</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>-=</code></td><td>减赋值</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>*=</code></td><td>乘赋值</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>/=</code></td><td>除赋值</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>%=</code></td><td>取余赋值</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>&lt;&lt;=</code></td><td>左移赋值</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>&gt;&gt;=</code></td><td>右移赋值</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>&amp;=</code></td><td>按位与赋值</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td><code>^=</code></td><td>按位异或赋值</td><td>表达式</td><td>右结合</td></tr><tr><td></td><td>|&#x3D;</td><td>按位或赋值</td><td>表达式</td><td>右结合</td></tr><tr><td>15</td><td><code>,</code></td><td>逗号</td><td>表达式</td><td>左结合</td></tr></tbody></table><p>考研复试可能会用</p>
              </div>
            </details>




<h2 id="逻辑语句"><a href="#逻辑语句" class="headerlink" title="逻辑语句"></a>逻辑语句</h2><h3 id="逻辑语句概述"><a href="#逻辑语句概述" class="headerlink" title="逻辑语句概述"></a>逻辑语句概述</h3><p>注意 逻辑语句后一般不加分号(;)</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if...else 语句</span></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a is greater than b\n&quot;</span>);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a = b)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a is equcal than b\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;a is not greater than b\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逻辑与、逻辑或</span></span><br><span class="line">    <span class="keyword">if</span> (a &lt; b &amp;&amp; b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Both conditions are true\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三元运算符</span></span><br><span class="line">    <span class="type">int</span> max = (a &gt; b) ? a : b;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The maximum is %d\n&quot;</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// switch 语句</span></span><br><span class="line">    <span class="keyword">switch</span> (a) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a is 5\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a is 10\n&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;a is not 5 or 10\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//for语句</span></span><br><span class="line">    <span class="type">int</span> length = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> t = <span class="number">2</span>; t &lt; length; t++)  <span class="comment">//for(初始化变量;判断条件;变量变化表达式)</span></span><br><span class="line">        <span class="comment">//for语句第一次循环 用初始量去判断条件,执行语句,执行变量变量变化表达式</span></span><br><span class="line">        <span class="comment">//二次后的循环则是 判断条件,执行语句,执行变量变量变化表达式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;cool %d\n&quot;</span>,t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//do...while语句  先执行指令,再判断是否继续循环</span></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, SQ.data[i]);</span><br><span class="line">		i = (i + <span class="number">1</span>) % MAX_SIZE;</span><br><span class="line">	&#125; <span class="keyword">while</span> (i != SQ.rear);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>C 语言中的逻辑语句主要包括<strong>逻辑运算符</strong>和<strong>条件语句</strong>。逻辑语句用于控制程序的执行流程，常用的逻辑语句有 <code>if</code>、<code>else if</code>、<code>else</code>、<code>switch</code>、<code>while</code>、<code>for</code>、<code>do...while</code> 等。</p>
<h4 id="1-逻辑运算符"><a href="#1-逻辑运算符" class="headerlink" title="1. 逻辑运算符"></a>1. <strong>逻辑运算符</strong></h4><p>逻辑运算符用于连接条件表达式或进行条件判断。C 语言中的逻辑运算符如下表所示：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>名称</th>
<th>用法</th>
<th>结果</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;&amp;</code></td>
<td>逻辑与（AND）</td>
<td><code>expr1 &amp;&amp; expr2</code></td>
<td>若 <code>expr1</code> 和 <code>expr2</code> 均为真，结果为真，否则为假</td>
</tr>
<tr>
<td>|</td>
<td>逻辑或（OR）</td>
<td><code>expr1 逻辑或 expr2</code></td>
<td>若 <code>expr1</code> 和 <code>expr2</code> 任一真，结果为真</td>
</tr>
<tr>
<td><code>!</code></td>
<td>逻辑非（NOT）</td>
<td><code>!expr</code></td>
<td>若 <code>expr</code> 为真，结果为假，反之亦然</td>
</tr>
</tbody></table>
<h4 id="2-条件语句"><a href="#2-条件语句" class="headerlink" title="2. 条件语句"></a>2. <strong>条件语句</strong></h4><p>C 语言中的条件语句用于根据不同的条件执行不同的代码块。以下是常见的条件语句：</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>用法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>if</code></td>
<td><code>if (condition) &#123; /* code */ &#125;</code></td>
<td>当 <code>condition</code> 为真时，执行 <code>&#123; /* code */ &#125;</code></td>
</tr>
<tr>
<td><code>if...else</code></td>
<td><code>if (condition) &#123; /* code1 */ &#125; else &#123; /* code2 */ &#125;</code></td>
<td>如果 <code>condition</code> 为真，执行 <code>code1</code>，否则执行 <code>code2</code></td>
</tr>
<tr>
<td><code>else if</code></td>
<td><code>if (condition1) &#123; /* code1 */ &#125; else if (condition2) &#123; /* code2 */ &#125; else &#123; /* code3 */ &#125;</code></td>
<td>多条件判断，第一个为真的条件执行相应的代码块</td>
</tr>
<tr>
<td><code>switch</code></td>
<td><code>switch (expression) &#123; case val1: /* code */ break; case val2: /* code */ break; default: /* code */ &#125;</code></td>
<td>根据 <code>expression</code> 的值选择执行相应的 <code>case</code> 代码块</td>
</tr>
</tbody></table>
<h4 id="3-循环语句"><a href="#3-循环语句" class="headerlink" title="3. 循环语句"></a>3. <strong>循环语句</strong></h4><p>C 语言中的循环语句用于重复执行某一代码块，直到满足指定的条件。</p>
<table>
<thead>
<tr>
<th>语句</th>
<th>用法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>while</code></td>
<td><code>while (condition) &#123; /* code */ &#125;</code></td>
<td>当 <code>condition</code> 为真时，重复执行 <code>&#123; /* code */ &#125;</code></td>
</tr>
<tr>
<td><code>do...while</code></td>
<td><code>do &#123; /* code */ &#125; while (condition);</code></td>
<td>先执行一次代码块，再根据 <code>condition</code> 判断是否继续</td>
</tr>
<tr>
<td><code>for</code></td>
<td><code>for (init; condition; increment) &#123; /* code */ &#125;</code></td>
<td>常用循环，按照初始化、条件判断、增量控制的顺序执行</td>
</tr>
</tbody></table>
<h4 id="4-三元运算符"><a href="#4-三元运算符" class="headerlink" title="4. 三元运算符"></a>4. <strong>三元运算符</strong></h4><p>三元运算符是简化 <code>if...else</code> 语句的方式，语法如下：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>用法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>?:</code></td>
<td><code>condition ? expr1 : expr2</code></td>
<td>当 <code>condition</code> 为真时，返回 <code>expr1</code>，否则返回 <code>expr2</code></td>
</tr>
</tbody></table>
<h4 id="5-continue和break"><a href="#5-continue和break" class="headerlink" title="5.continue和break"></a>5.continue和break</h4><table>
<thead>
<tr>
<th>语句</th>
<th>用法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td><code>continue</code></td>
<td><code>continue;</code></td>
<td>当循环语句中出现 <code>continue</code> 时，跳过本次循环,执行下一次循环</td>
</tr>
<tr>
<td><code>break</code></td>
<td><code>break;</code></td>
<td>当循环语句中出现 <code>break</code> 时，打断循环,执行后续语句</td>
</tr>
</tbody></table>
<h4 id="SP-逻辑语句中执行的变量变化会传递到逻辑语句外"><a href="#SP-逻辑语句中执行的变量变化会传递到逻辑语句外" class="headerlink" title="SP.逻辑语句中执行的变量变化会传递到逻辑语句外"></a>SP.逻辑语句中执行的变量变化会传递到逻辑语句外</h4><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">while</span> (a &lt; <span class="number">100</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		a++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a = %d&quot;</span>, a); <span class="comment">// Output: a = 100</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><table>
<thead>
<tr>
<th>数组类型</th>
<th>用法示例</th>
<th>访问方式</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>一维数组</td>
<td><code>int arr[5];</code></td>
<td><code>arr[i]</code></td>
<td>固定大小，元素在内存中连续存储。</td>
</tr>
<tr>
<td>二维数组</td>
<td><code>int arr[3][4];</code></td>
<td><code>arr[i][j]</code></td>
<td>类似矩阵，元素按行优先存储。</td>
</tr>
<tr>
<td>多维数组</td>
<td><code>int arr[2][3][4];</code></td>
<td><code>arr[i][j][k]</code></td>
<td>用于复杂的多维数据存储。</td>
</tr>
<tr>
<td>字符数组</td>
<td><code>char str[] = &quot;Hello&quot;;</code></td>
<td><code>str[i]</code></td>
<td>以 <code>&#39;\0&#39;</code> 结尾，表示字符串。</td>
</tr>
<tr>
<td>动态数组</td>
<td><code>int *arr = (int *)malloc(5 * sizeof(int));</code></td>
<td><code>arr[i]</code></td>
<td>动态分配内存，大小可变。</td>
</tr>
<tr>
<td>参数传递</td>
<td><code>void func(int arr[], int size)</code></td>
<td><code>arr[i]</code></td>
<td>传递指针，需要传递数组大小。</td>
</tr>
</tbody></table>
<h3 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 声明并初始化</span></span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;; <span class="comment">//数组类型 数组名[数组大小] = &#123; &#125;</span></span><br><span class="line">    <span class="type">int</span> b[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">90</span>,<span class="number">34</span>,<span class="number">3</span>,<span class="number">312</span>&#125; <span class="comment">//无数组大小的初始化方式,编辑器会自动匹配数组大小</span></span><br><span class="line">    <span class="type">int</span> length_b = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>); <span class="comment">//获取数组长度,方便后续操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> arr[<span class="number">5</span>];  <span class="comment">// 声明一个长度为5的整型空数组  此时数组里的值均为0</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//访问数组</span></span><br><span class="line">    <span class="comment">// 给数组的第3个元素赋值</span></span><br><span class="line">    arr[<span class="number">2</span>] = <span class="number">10</span>;  <span class="comment">//数组名[索引号] = 值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取第1个元素的值</span></span><br><span class="line">    <span class="type">int</span> x = arr[<span class="number">0</span>];  <span class="comment">// 变量名 = 数组名[索引号]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>主要 数组索引从0开始，因此大小为10的数组实际索引为0到9</p>
<h4 id="关于数组初始化"><a href="#关于数组初始化" class="headerlink" title="关于数组初始化 :"></a>关于数组初始化 :</h4><p>通常可在数组后添加一个新的变量来动态的记录数组长度,常用的以为数组长度算法为<code>int length_a = sizeof(a) / sizeof(int);</code></p>
<h4 id="关于数组越界的问题"><a href="#关于数组越界的问题" class="headerlink" title="关于数组越界的问题 :"></a>关于数组越界的问题 :</h4><p>在访问数组时，如果使用的索引超出了数组的有效范围，可能会导致不可预知的行为或程序崩溃。从内存层面上，溢出的数组值会和该数组相邻的变量产生冲突，使得该变量获得错误的值，Visual Studio 2022会自动检测数组下标溢出问题，并阻止编译，但其他编译器仍可能出现问题</p>
<h3 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> matrix[<span class="number">3</span>][<span class="number">4</span>];  <span class="comment">// 3行4列的二维数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>] = &#123;  <span class="comment">//初始化</span></span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">    &#125;;    </span><br><span class="line">    </span><br><span class="line">    matrix[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">10</span>;  <span class="comment">// 设置第2行第3列的值为10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="多维数组的内存结构"><a href="#多维数组的内存结构" class="headerlink" title="多维数组的内存结构"></a>多维数组的内存结构</h4><p>二维数组在内存中是按行连续存储的。例如，<code>matrix[2][3]</code> 在内存中的存储顺序为：<code>matrix[0][0], matrix[0][1], matrix[0][2], matrix[1][0], matrix[1][1], matrix[1][2]</code>。</p>
<h3 id="数组传递"><a href="#数组传递" class="headerlink" title="数组传递"></a>数组传递</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型声明，确保在 main 函数之前声明 print_a 函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_a</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a[<span class="number">10</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span> &#125;;</span><br><span class="line">    <span class="type">int</span> length_a = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    </span><br><span class="line">    print_a(a, length_a); <span class="comment">// 调用 print_a 函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length_a = %d\n&quot;</span>, length_a); <span class="comment">// 输出数组长度，输出为10</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_a</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> length)</span>  <span class="comment">//数组a传递进print_a时传递的不是数组本身，而是指针</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> length_a_p = <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="type">int</span>); <span class="comment">//此时sizeof(a)的值为它指针的大小，即8byte，故length_a_p此时的值并不能反映数组a的大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;length_a_p = %d\n&quot;</span>, length_a_p); <span class="comment">//输出为2</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, a[i]); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>数组传递是按指针传递的</strong>，你传递的是数组首元素的地址，而不是整个数组。数组名退化为指针</p>
<p><strong>数组的长度信息不会自动传递</strong>，数组长度信息丢失，需要手动传递长度。上述代码提供了一个可行的长度传递逻辑</p>
<p><strong>指针传递使得函数可以修改原数组的值</strong>，因为指针指向的是相同的内存地址。</p>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">6</span>] = &#123; <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;  <span class="comment">// 定义并初始化一个字符串。</span></span><br><span class="line">    <span class="comment">//此方法有诸多弊端,例如结尾符忘写会输出乱码</span></span><br><span class="line">    <span class="type">char</span> str2[] = <span class="string">&quot;Hello&quot;</span>;  <span class="comment">// 字符串的简化初始化形式。通常使用这种方法初始化</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;str = %c\n&quot;</span>, str2[i]);  <span class="comment">//由于数组字符初始化时最后以为必定为\0,故长度为6的字符数组实际有效值只有5个,有效索引为0到4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str = %s\n&quot;</span>, str); <span class="comment">//字符数组可通过%s格式化来整体输出</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="关于字符数组初始化"><a href="#关于字符数组初始化" class="headerlink" title="关于字符数组初始化"></a>关于字符数组初始化</h4><p>字符数组是用于存储字符的数组，通常用于存储和处理字符串。在C语言中，字符串是以空字符 <code>&#39;\0&#39;</code> 结尾的字符数组,在对字符数组进行操作是要尤为注意索引问题</p>
<h4 id="数据大小问题"><a href="#数据大小问题" class="headerlink" title="数据大小问题"></a>数据大小问题</h4><table>
<thead>
<tr>
<th>数据类型</th>
<th>每个元素占用的内存大小</th>
</tr>
</thead>
<tbody><tr>
<td><code>int</code></td>
<td>通常 4 字节</td>
</tr>
<tr>
<td><code>float</code></td>
<td>通常 4 字节</td>
</tr>
<tr>
<td><code>double</code></td>
<td>通常 8 字节</td>
</tr>
<tr>
<td><code>char</code></td>
<td>通常 1 字节</td>
</tr>
<tr>
<td><code>*p</code>指针</td>
<td>32 位系统是 4 字节，64 位系统是 8 字节</td>
</tr>
</tbody></table>
<p>这些大小可能会根据平台和编译器有所不同，<code>sizeof</code>运算符是确定实际大小的最可靠方式,常用的算法为<code>sizefo(arrname)/siezof(datat[0])</code></p>
<h4 id="关于sizeof"><a href="#关于sizeof" class="headerlink" title="关于sizeof()"></a>关于<code>sizeof()</code></h4><ul>
<li><code>sizeof(type)</code>：计算指定类型的大小</li>
<li><code>sizeof(variable)</code>：计算变量所占的内存大小</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于数组大小的计算</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of array: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(arr)); <span class="comment">//计算整个数组的大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of one element: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])); <span class="comment">//计算单个数据的大小</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of elements in the array: %zu\n&quot;</span>, <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>])); <span class="comment">//真个数组大小/单个数据大小=数组长度  ***常用***</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于构造体大小的计算</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">char</span> b;</span><br><span class="line">    <span class="type">float</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">myStruct</span> <span class="title">s</span>;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Size of struct: %zu bytes\n&quot;</span>, <span class="keyword">sizeof</span>(s)); <span class="comment">//输出为12</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>尽管 <code>int</code> 是 4 字节，<code>char</code> 是 1 字节，<code>float</code> 是 4 字节，但结构体可能因为内存对齐而占用更多的字节数,详见<strong>构造体对齐</strong>章节</p>
<h4 id="字符串操作函数str系列"><a href="#字符串操作函数str系列" class="headerlink" title="字符串操作函数str系列"></a>字符串操作函数str系列</h4><p>该系列操作函数需调用&lt;string.h&gt;</p>
<p>在 C 语言中，<code>string.h</code> 头文件中提供了一些常用的字符串操作函数，包括 <code>strlen</code>、<code>strcpy</code>、<code>strcat</code> 和 <code>strcmp</code>。这些函数专门用于处理以 <code>&#39;\0&#39;</code> 结尾的字符串</p>
<p>其中<code>strcpy</code>、<code>strcat</code>由于其安全性的不足而被弃用,现用更安全的<code>strcpy_s</code>和<code>strcat_s</code> ,他们要求提供<code>dest_size</code>: 目标字符串的大小（总字节数，必须包含足够的空间来容纳源字符串和终止符 <code>\0</code>）来防止字符串溢出组中</p>
<p><code>dest_size</code> 必须包含现有字符串、源字符串以及终止符 <code>\0</code>。</p>
<p>如果目标缓冲区不够大，函数将不会追加字符串并返回错误。</p>
<p>如果目标或源字符串指针为 <code>NULL</code>，函数也会返回错误。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str_x[] = <span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str_b[<span class="number">30</span>] = <span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str_a[<span class="number">6</span>] = &#123; <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">    <span class="type">char</span> str_c[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> lenth_a;</span><br><span class="line">    lenth_a = <span class="built_in">strlen</span>(str_a); <span class="comment">//字符串计数器不包含组结尾的\0,因此返回值比实际组长度小1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;lenth of str_a is %d\n&quot;</span>, lenth_a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;size of str_a is %d\n&quot;</span>, <span class="number">6</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//字符串复制到另一字符串</span></span><br><span class="line">    strcpy_s(str_c,<span class="keyword">sizeof</span>(str_c), str_b);  <span class="comment">//strcpy_s(目标组,目标组大小,源组)</span></span><br><span class="line">    <span class="built_in">puts</span>(str_c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//字符串尾追加字符串</span></span><br><span class="line">    strcat_s(str_b,<span class="keyword">sizeof</span>(str_b),str_x);  <span class="comment">//strcat_s(目标组,目标组大小,源组)</span></span><br><span class="line">    <span class="built_in">puts</span>(str_b);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//ASK码比较字符串大小</span></span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">strcmp</span>(str_x, str_b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str_x campare with str_b %d\n&quot;</span>,j);</span><br><span class="line">    <span class="comment">//strcmp依照阿斯克码表进行比较,比较的大小结果并非实际字符长度大小,实际用途不明</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure></div>



<table>
<thead>
<tr>
<th>函数</th>
<th>功能</th>
<th>返回值</th>
<th>用法示例</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td><code>strlen</code></td>
<td>计算字符串长度</td>
<td>返回字符串长度，不含 <code>\0</code></td>
<td><code>size_t len = strlen(str);</code></td>
<td>只计算 <code>\0</code> 之前的字符，不包括 <code>\0</code>，且传入字符串必须以 <code>\0</code> 结尾</td>
</tr>
<tr>
<td><code>strcpy_s</code></td>
<td>安全地将源字符串复制到目标字符串</td>
<td>返回目标字符串指针</td>
<td><code>strcpy(dest,sizeof(dest), src);</code></td>
<td>目标缓冲区必须足够大以容纳源字符串和 <code>\0</code>，否则失败</td>
</tr>
<tr>
<td><code>strcat_s</code></td>
<td>安全地将源字符串追加到目标字符串后</td>
<td>返回目标字符串指针</td>
<td><code>strcat(dest,sizeof(dest), src);</code></td>
<td>目标缓冲区必须包含现有字符串、源字符串和 <code>\0</code>，否则失败</td>
</tr>
<tr>
<td><code>strcmp</code></td>
<td>比较两个字符串</td>
<td>0:相等，正数:大于，负数:小于</td>
<td><code>int cmp = strcmp(str1, str2);</code></td>
<td>按字典顺序比较，区分大小写，比较到第一个不同的字符即停止</td>
</tr>
</tbody></table>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="指针变量"><a href="#指针变量" class="headerlink" title="指针变量"></a>指针变量</h3><p><strong>指针</strong>是一个存储地址的变量，而<strong>指针变量</strong>就是指针的具体实现。它存储的是另一个变量的内存地址，而不是直接存储数据值。指针是C语言的一个核心概念，允许你更高效和灵活地操作内存、数组、字符串以及函数等</p>
<h4 id="取地址操作符-和解引用操作符"><a href="#取地址操作符-和解引用操作符" class="headerlink" title="取地址操作符 &amp; 和解引用操作符 *"></a>取地址操作符 <code>&amp;</code> 和解引用操作符 <code>*</code></h4><ul>
<li><code>&amp;</code> 取地址符：用于获取变量的内存地址。例如 <code>&amp;a</code> 就是变量 <code>a</code> 的内存地址。</li>
<li><code>*</code> 解引用符：用于访问指针指向的变量的值。例如 <code>*p</code> 表示访问 <code>p</code> 所指向的变量的值。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;    <span class="comment">// 普通变量</span></span><br><span class="line">    <span class="type">int</span> *p = &amp;a;   <span class="comment">// p是指向a的指针  // 数据类型 *指针变量名 = &amp;变量名</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a的值: %d\n&quot;</span>, a);      <span class="comment">// 输出a的值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a的地址: %p\n&quot;</span>, &amp;a);   <span class="comment">// 输出a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p的值: %p\n&quot;</span>, p);      <span class="comment">// 输出p的值（即a的地址）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p指向的值: %d\n&quot;</span>, *p); <span class="comment">// 输出p指向的值，即a的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>注意！指针的类型决定了指针指向的数据类型，比如：</p>
<ul>
<li><code>int *p;</code> 指向 <code>int</code> 类型的指针</li>
<li><code>char *p;</code> 指向 <code>char</code> 类型的指针</li>
<li><code>float *p;</code> 指向 <code>float</code> 类型的指针 指针类型决定了在解引用时如何解释内存中的数据。</li>
</ul>
<h4 id="指针变量和普通变量的区别："><a href="#指针变量和普通变量的区别：" class="headerlink" title="指针变量和普通变量的区别："></a>指针变量和普通变量的区别：</h4><table>
<thead>
<tr>
<th>特性</th>
<th>普通变量</th>
<th>指针变量</th>
</tr>
</thead>
<tbody><tr>
<td>存储内容</td>
<td>变量的值</td>
<td>另一个变量的地址</td>
</tr>
<tr>
<td>访问方式</td>
<td>直接访问变量值</td>
<td>通过解引用访问指向的变量值</td>
</tr>
<tr>
<td>取地址符使用</td>
<td>不需要</td>
<td>需要使用<code>*</code>进行解引用</td>
</tr>
<tr>
<td>使用场景</td>
<td>存储基本数据</td>
<td>存储内存地址，操作复杂数据结构</td>
</tr>
</tbody></table>
<h3 id="指针传递"><a href="#指针传递" class="headerlink" title="指针传递"></a>指针传递</h3><p><strong>指针传递</strong>指的是通过函数参数传递指针（即变量的地址），从而使函数能够直接操作原始变量的值。这是C语言实现“传引用”功能的方式，因为C语言默认的参数传递是“传值”，即传递的是变量的副本，而不是变量本身。</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">change_value</span><span class="params">(<span class="type">int</span> *p)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p的地址: %p\n&quot;</span>, p);</span><br><span class="line">    *p = <span class="number">99</span>; <span class="comment">//通过解引用符*直接访问a所在的内存地址,实现对a的修改</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;    <span class="comment">// 普通变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a的值: %d\n&quot;</span>, a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a的地址: %p\n&quot;</span>, &amp;a);</span><br><span class="line"></span><br><span class="line">    change_value(&amp;a); <span class="comment">//将a的地址传给形参p</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a的值: %d\n&quot;</span>, a);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>change_value(int *p)</code>：这个函数接受一个<code>int</code>类型的指针<code>p</code>，即指向一个<code>int</code>类型变量的地址。</li>
<li><code>*p = 99;</code>：通过解引用指针<code>p</code>，直接修改了指针指向的变量（即<code>a</code>）的值。</li>
</ul>
<h3 id="指针偏移"><a href="#指针偏移" class="headerlink" title="指针偏移"></a>指针偏移</h3><p><strong>指针偏移</strong>指的是通过对指针进行算术运算来访问相邻的内存单元。它与数组访问紧密相关。指针偏移是通过修改指针的值，使其指向内存中的不同位置，从而访问相邻的元素</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">9</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;    <span class="comment">// 普通变量</span></span><br><span class="line">    <span class="type">int</span> *p = arr; <span class="comment">//数组名储存的是起始地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//*p = 99; //通过解引用符*直接访问a所在的内存地址,实现对a的修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//printf(&quot;%d&quot;, arr[0]);</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(<span class="type">int</span>); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//正序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i=%d arr[i]=%d\n&quot;</span>,i,*(p+i)); </span><br><span class="line">        <span class="comment">//int的大小为4byte,指针+1相当于内存地址向后移动4位</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒序</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i=%d arr[i]=%d\n&quot;</span>, i, *(p + <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(<span class="type">int</span>)<span class="number">-1</span>-i));</span><br><span class="line">        <span class="comment">//通过起始地址和数组大小定位到结束地址,反向递归</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>int *p = arr;</code>：指针<code>p</code>指向数组<code>arr</code>的第一个元素。</li>
<li><code>*(p + i)</code>：通过指针偏移，访问数组的第<code>i</code>个元素。这里的<code>p + i</code>表示指针<code>p</code>向后偏移<code>i</code>个位置，<code>*(p + i)</code>解引用偏移后的地址，得到对应的元素值。</li>
</ul>
<h3 id="动态内存分配"><a href="#动态内存分配" class="headerlink" title="动态内存分配"></a>动态内存分配</h3><p>在C语言中，内存可以通过<strong>动态内存分配</strong>的方式进行管理。静态内存分配是在程序编译时确定的，如局部变量和全局变量，它们在程序运行时占用固定的内存。相比之下，<strong>动态内存分配</strong>是在程序运行时，通过显式调用特定的函数来申请或释放内存，内存的大小可以根据需要动态变化，且程序员需要手动释放不再使用的内存</p>
<p>动态内存的申请可以使用标准库中的函数<code>malloc()</code>、<code>calloc()</code>、<code>realloc()</code>等。最常用的函数是<code>malloc()</code>，它用于申请指定字节数的内存</p>
<h4 id="1-malloc-函数"><a href="#1-malloc-函数" class="headerlink" title="1.malloc() 函数"></a>1.<code>malloc()</code> 函数</h4><p>使用<code>malloc()</code>前应先引入<code>&lt;stdlib.h&gt;</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">//申请空间填入数组</span></span><br><span class="line">    <span class="type">int</span>* arr;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态分配内存以存储 5 个整数</span></span><br><span class="line">    arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>));  <span class="comment">//指针名=(指针类型)malloc(申请空间大小)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查内存是否分配成功</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Memory allocation failed!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        arr[i] = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印数组元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放分配的内存</span></span><br><span class="line">    <span class="built_in">free</span>(arr); </span><br><span class="line"><span class="comment">//-------------------------------------------------------------------------------//</span></span><br><span class="line">    <span class="comment">//申请空间填入字符串</span></span><br><span class="line">    <span class="type">char</span>* arr_str;</span><br><span class="line">    <span class="type">char</span> c_arr[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> size_arr = <span class="keyword">sizeof</span>(c_arr) / <span class="keyword">sizeof</span>(<span class="type">char</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;enter c_arr&#x27;s value\n&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%s&quot;</span>, c_arr, (<span class="type">unsigned</span>)<span class="keyword">sizeof</span>(c_arr));</span><br><span class="line">    <span class="comment">//puts(c_arr);</span></span><br><span class="line"></span><br><span class="line">    arr_str = (<span class="type">char</span>*)<span class="built_in">malloc</span>(size_arr);  <span class="comment">//申请内存空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_arr; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        arr_str[i] = c_arr[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size_arr; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;arr[%d] is %c\n&quot;</span>,i, arr_str[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(arr_str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<ul>
<li>内存申请：我们使用<code>malloc()</code>分配了<code>n</code>个整数大小的内存，并将其返回的通用指针转换为<code>int*</code>类型。</li>
<li>内存使用：内存分配后可以像普通数组一样使用指针来访问。</li>
<li>内存释放：使用完内存后，必须调用<code>free()</code>函数来释放之前动态分配的内存，以避免<strong>内存泄漏</strong>。</li>
</ul>
<h4 id="2-calloc-函数"><a href="#2-calloc-函数" class="headerlink" title="2. calloc() 函数"></a>2. <code>calloc()</code> 函数</h4><p><code>calloc()</code>函数用于动态分配内存，并将分配的内存初始化为0</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配 5 个整型，并初始化为 0</span></span><br><span class="line"><span class="type">int</span>* arr = (<span class="type">int</span>*)<span class="built_in">calloc</span>(<span class="number">5</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));  </span><br></pre></td></tr></table></figure></div>

<p><code>calloc()</code>在初始化数组时非常有用，它会将所有分配的内存块初始化为0，而<code>malloc()</code>不会进行初始化。</p>
<h4 id="3-realloc-函数"><a href="#3-realloc-函数" class="headerlink" title="3. realloc() 函数"></a>3. <code>realloc()</code> 函数</h4><p><code>realloc()</code>函数用于重新调整已经动态分配的内存块的大小。它的语法如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 将原内存大小调整为可以存储 10 个整型</span></span><br><span class="line">arr = (<span class="type">int</span>*)<span class="built_in">realloc</span>(arr, <span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="type">int</span>)); </span><br></pre></td></tr></table></figure></div>

<p><code>realloc()</code>可以扩展或缩小之前分配的内存块。如果扩展，新的内存区域的内容是未初始化的</p>
<h4 id="4-free-函数"><a href="#4-free-函数" class="headerlink" title="4. free() 函数"></a>4. <code>free()</code> 函数</h4><p><code>free()</code>函数用于释放<code>malloc()</code>、<code>calloc()</code>、或<code>realloc()</code>动态分配的内存。它的语法非常简单：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(arr);</span><br></pre></td></tr></table></figure></div>

<p><strong>注意</strong>：释放后不能再访问释放的内存区域，否则会导致未定义的行为</p>
<h3 id="栈与堆的差异"><a href="#栈与堆的差异" class="headerlink" title="栈与堆的差异"></a>栈与堆的差异</h3><h4 id="1-栈（Stack）"><a href="#1-栈（Stack）" class="headerlink" title="1. 栈（Stack）"></a>1. 栈（Stack）</h4><p>栈是内存中的一块区域，用于存储局部变量、函数调用相关的信息（如返回地址、参数等）。它遵循后进先出（LIFO, Last In First Out）的原则</p>
<ul>
<li><p><strong>自动管理</strong>：栈的内存是由编译器自动分配和释放的，程序不需要手动管理。</p>
</li>
<li><p><strong>存储局部变量和函数调用信息</strong>：栈用于存储局部变量（如函数内部定义的变量）以及函数调用的参数、返回地址等信息。</p>
</li>
<li><p><strong>内存空间有限</strong>：栈的大小通常是有限的，因为它的内存是为单个线程分配的固定大小。栈溢出（Stack Overflow）可能发生在递归深度过大或者分配的局部变量过多时。</p>
</li>
<li><p><strong>快速分配与释放</strong>：由于栈是自动管理的，其内存分配和释放速度非常快，只需调整栈指针即可。</p>
</li>
<li><p><strong>存储方式</strong>：内存按照严格的顺序（LIFO）进行分配。每次调用函数时，都会在栈上为其分配一块空间，函数结束后，这块空间会被立即释放,如果采用取地址的方式对栈进行访问,会等到不同于第一次访问得到的乱码</p>
</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">stack_print</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> c[<span class="number">20</span>] = <span class="string">&quot;i am so tired\n&quot;</span>;<span class="comment">//字符串数组c被存在栈中</span></span><br><span class="line">    <span class="type">char</span>* p;<span class="comment">//指针p被存在栈中</span></span><br><span class="line">    p = c; <span class="comment">//将指针c赋值给p</span></span><br><span class="line">    <span class="built_in">puts</span>(p); <span class="comment">//通过p的值锁定字符串c的起始地址,并开始打印字符串c中的值</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">    <span class="comment">//此步是自动在栈中执行的,执行并return完毕后字符串c和指针p的值都会被自动清除,后续无法再通过指针p来找到字符串c,</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* p;</span><br><span class="line">    p = stack_print();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;print again\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(p); <span class="comment">//即使传回存放着c地址的指针p,由于该地址中c的值也早已消失,故此步编译不通</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>  <code>c</code>和<code>p</code>会存储在栈中，函数返回时，这些变量会被自动释放,无法通过指针再次访问</p>
<h4 id="2-堆（Heap）"><a href="#2-堆（Heap）" class="headerlink" title="2. 堆（Heap）"></a>2. 堆（Heap）</h4><p>堆是内存中用于动态分配的区域，程序员可以通过函数（如<code>malloc()</code>、<code>calloc()</code>、<code>realloc()</code>等）手动管理堆内存。</p>
<ul>
<li><strong>手动管理</strong>：堆中的内存是由程序员通过函数手动分配和释放的。分配的内存不会自动释放，程序员需要显式地调用<code>free()</code>函数释放内存。</li>
<li><strong>适合动态内存分配</strong>：堆适合用于动态内存分配，可以根据程序的需要分配任意大小的内存，这在程序需要灵活的内存管理时非常有用。</li>
<li><strong>内存空间较大</strong>：堆的内存通常比栈大得多，但堆的内存分配速度通常比栈慢，因为它需要找到合适大小的空闲内存块，并进行更多的管理操作。</li>
<li><strong>内存碎片问题</strong>：由于堆中的内存分配和释放是动态的，频繁的分配和释放操作会导致内存碎片问题，即大量的小块未使用的内存分散在堆中，影响内存利用率。</li>
<li><strong>访问较慢</strong>：由于堆中的内存分配不如栈的内存分配有序，因此访问堆中的内存通常比栈中的内存要慢。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span>* <span class="title function_">malloc_print</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span>* p = (<span class="type">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>);</span><br><span class="line">    <span class="type">char</span> c[<span class="number">20</span>] = <span class="string">&quot;i am so tired\n&quot;</span>;<span class="comment">//字符串数组c被存在栈中</span></span><br><span class="line">    strcpy_s(p,<span class="number">20</span>,c);  <span class="comment">//需要将c复制给p才能在方法结束时保留其中数据</span></span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="keyword">return</span> p;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span>* p;</span><br><span class="line">    p = malloc_print();</span><br><span class="line">    <span class="comment">//printf(&quot;print finish&quot;);</span></span><br><span class="line">    <span class="built_in">puts</span>(p);</span><br><span class="line">    <span class="comment">//由于堆会在进程结束之前始终存在,故其中数据可重复读取</span></span><br><span class="line">    <span class="built_in">free</span>(p); <span class="comment">//手动释放内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-栈与堆的区别"><a href="#3-栈与堆的区别" class="headerlink" title="3. 栈与堆的区别"></a>3. 栈与堆的区别</h4><table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>栈（Stack）</strong></th>
<th><strong>堆（Heap）</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>内存分配</strong></td>
<td>自动由编译器管理</td>
<td>手动管理（通过<code>malloc()</code>、<code>free()</code>等函数）</td>
</tr>
<tr>
<td><strong>内存大小</strong></td>
<td>较小（通常为几MB，因平台而异）</td>
<td>较大（受限于系统可用内存）</td>
</tr>
<tr>
<td><strong>存储内容</strong></td>
<td>局部变量、函数参数、函数返回地址等</td>
<td>动态分配的内存（如动态数组、链表节点等）</td>
</tr>
<tr>
<td><strong>分配速度</strong></td>
<td>快速（由编译器完成）</td>
<td>较慢（需要手动分配，查找合适的内存块）</td>
</tr>
<tr>
<td><strong>管理方式</strong></td>
<td>后进先出（LIFO）</td>
<td>无特定的管理方式，基于内存池和自由链表等技术</td>
</tr>
<tr>
<td><strong>释放内存</strong></td>
<td>自动（函数返回时释放）</td>
<td>手动（必须调用<code>free()</code>释放）</td>
</tr>
<tr>
<td><strong>内存碎片问题</strong></td>
<td>不会产生碎片</td>
<td>频繁分配和释放会产生内存碎片</td>
</tr>
<tr>
<td><strong>访问速度</strong></td>
<td>较快（顺序访问）</td>
<td>较慢（随机访问，查找耗时）</td>
</tr>
<tr>
<td><strong>常见问题</strong></td>
<td>栈溢出（Stack Overflow）</td>
<td>内存泄漏、碎片问题</td>
</tr>
</tbody></table>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是一个独立的代码片段，完成某个特定的任务。它可以接收输入（参数），并返回结果,通常用于实现一些经常使用的功能，可以减少代码的重复，提高代码的可读性和可维护性。</p>
<h3 id="标准函数"><a href="#标准函数" class="headerlink" title="标准函数"></a>标准函数</h3><div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fuc_print</span><span class="params">(<span class="type">int</span> f)</span>;  <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main_1</span><span class="params">()</span> &#123;  <span class="comment">//主函数</span></span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    j = fuc_print(j); <span class="comment">// 调用fuc_print函数,函数()中填入实参,实现参数传递,当函数有返回值时,该值将被赋值给j</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j is %d\n&quot;</span>, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fuc_print</span><span class="params">(<span class="type">int</span> f)</span> &#123;   <span class="comment">//函数类型 函数名字(形参)&#123; 函数体 &#125;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function is running\n&quot;</span>);</span><br><span class="line">    f = <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">return</span> f;  <span class="comment">//函数返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h5 id="函数定义的组成："><a href="#函数定义的组成：" class="headerlink" title="函数定义的组成："></a>函数定义的组成：</h5><ul>
<li><p><strong>返回类型</strong>：函数返回的值的类型。例如，<code>int</code> 表示函数返回一个整数，<code>void</code> 表示函数不返回任何值。</p>
<p>函数的类型即他的返回值类型,具体种类参考数据类型列表</p>
</li>
<li><p><strong>函数名</strong>：标识函数的名称，程序通过名称调用函数。<strong>函数名储存了函数的入口地址,其本质是个指针</strong></p>
</li>
<li><p><strong>参数列表</strong>：传递给函数的输入数据，可以是多个参数，每个参数都有其类型。参数列表位于括号内，如果没有参数，括号为空。</p>
</li>
<li><p><strong>函数体</strong>：函数执行的具体代码块。</p>
</li>
<li><p><strong>返回值</strong>：通过 <code>return</code> 语句返回给调用者的结果，如果函数的返回类型是 <code>void</code>，则不需要 <code>return</code> 值。</p>
</li>
</ul>
<h3 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h3><p>通过导入库来调用的函数,称之为库函数,例如</p>
<p><code>#include &lt;string.h&gt;</code>包含 :</p>
<p><strong><code>printf</code></strong>：用于格式化输出。</p>
<p><strong><code>scanf</code></strong>：用于从标准输入读取数据。</p>
<p><strong><code>strlen</code></strong>：用于计算字符串的长度。</p>
<p><strong><code>strcpy</code></strong>：用于复制字符串。</p>
<p><code>#include &lt;stdlib.h&gt;</code>包含 :</p>
<p><strong><code>malloc</code></strong>：用于动态内存分配。</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>内联函数建议编译器在函数调用处展开函数代码，而不是进行真正的函数调用，避免了函数调用的开销，从而提高性能,即在<code>return</code>处写计算代码,省略了函数体</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="comment">//形参中定义变量</span></span><br><span class="line">    <span class="keyword">return</span> a + b;  <span class="comment">//return中进行计算</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h3><p>函数在 C 语言中可以通过指针来引用，这使得可以动态选择要调用的函数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*funcPtr)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 定义一个函数指针</span></span><br><span class="line">    funcPtr = &amp;add;            <span class="comment">// 将add函数地址赋给指针</span></span><br><span class="line">    <span class="type">int</span> result = funcPtr(<span class="number">2</span>, <span class="number">3</span>);  <span class="comment">// 通过指针调用函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, result);  <span class="comment">// 输出 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>C 语言支持递归，即一个函数可以在其定义中调用自身。递归用于解决分解为较小子问题的复杂问题,递归函数题目的关键是找到公式</p>
<p>考试爱考</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//阶乘问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;C_L_Header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fuc_factorial</span><span class="params">(<span class="type">int</span> f)</span>;  <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;input int number\n&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">    a = fuc_factorial(a);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number be factorialad is %d\n&quot;</span>, a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fuc_factorial</span><span class="params">(<span class="type">int</span> f)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f * fuc_factorial(f<span class="number">-1</span>);  <span class="comment">//函数计算中包含函数本体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>递归问题对数学思维能力有极高的要求,作为一个普通人,我选择多看多记</p>
<a class="button  regular" href='https://mikumikudaifans.github.io/Displace.github.io/2024/10/23/Recursive%20problem_List/' title='递归问题'><i class='fa-solid fa-play-circle'></i> 递归问题</a>

<h3 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h3><p>在 C 语言中，<strong>头文件</strong>（<code>.h</code> 文件）是一个包含常量、函数原型、数据类型定义、宏定义等的文件。头文件的主要作用是让多个 <code>.c</code> 文件共享声明，以实现代码的<strong>重用性</strong>和<strong>模块化</strong>，并且头文件能够<strong>避免重复定义</strong>，提升代码的可读性和维护性</p>
<p>在复杂的项目中，可能会有多个文件包含同一个头文件，这样会造成<strong>重复包含</strong>，导致编译错误。为了防止这种情况，通常会在头文件中添加<strong>包含保护</strong> : <code>#pragma once</code>用于使头文件仅被调用一次,</p>
<h4 id="ifndef-和-endif-的使用"><a href="#ifndef-和-endif-的使用" class="headerlink" title="ifndef 和 #endif 的使用"></a><code>ifndef</code> 和 <code>#endif</code> 的使用</h4><p>通过 <code>#ifndef</code> 和 <code>#define</code> 的组合，确保头文件的内容只会被处理一次</p>
<ul>
<li><p><code>#ifndef</code> 是 “if not defined” 的缩写，意思是如果宏 <code>EXAMPLE_H</code> <strong>没有定义</strong>，则继续执行后面的代码。而 <code>#define EXAMPLE_H</code> 则是在第一次进入时定义这个宏。这样做的目的是确保头文件不会被多次包含</p>
</li>
<li><p><code>#endif</code> 是用于结束这个条件编译块，它标志着 <code>#ifndef</code> 块的结束</p>
</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// example.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> EXAMPLE_H <span class="comment">// 如果没有定义EXAMPLE_H</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_H <span class="comment">// 定义EXAMPLE_H</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_VALUE 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printMessage</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">addNumbers</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">&#125; Student;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>

<p>其中的<code>fuc_print(int f)</code>是其他<code>.c</code>文件中定义的函数,将其在头文件中声明可被其它<code>.c</code>文件的调用</p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>要在一个 C 文件中使用头文件，通常需要使用 <code>#include</code> 预处理指令。它的作用是将头文件的内容复制到包含它的源文件中。包含头文件有两种方式：</p>
<ul>
<li><strong>尖括号方式</strong>：<code>#include &lt;file.h&gt;</code><br>用于包含系统库文件或标准头文件。编译器会在系统预定义的目录中查找这些文件。</li>
<li><strong>双引号方式</strong>：<code>#include &quot;file.h&quot;</code><br>用于包含用户定义的头文件。编译器会首先在当前目录查找头文件，如果找不到，再到系统目录查找,通常使用此种方法</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// C_L_Header.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once  <span class="comment">//能防止文件被多次包含</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>  <span class="comment">//库声明</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  head_b  10;  <span class="comment">//常量宏声明</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fuc_print</span><span class="params">(<span class="type">int</span> f)</span>;  <span class="comment">// 函数声明</span></span><br></pre></td></tr></table></figure></div>



<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">///C_Language_Learning_TEST.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;C_L_Header.h&quot;</span>  <span class="comment">//导入头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fuc_print</span><span class="params">(<span class="type">int</span> f)</span>;  <span class="comment">// 函数声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main_1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    j = fuc_print(j); <span class="comment">// 正确调用fuc_print函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;j is %d\n&quot;</span>, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fuc_print</span><span class="params">(<span class="type">int</span> f)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;function is running\n&quot;</span>);</span><br><span class="line">    f = <span class="number">8888</span>;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>此案例使用了头文件来省略库文件的导入</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;C_L_Header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line">    l = fuc_print(l);  <span class="comment">// 正确调用fuc_print函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fuc used successfully, l is %d\n&quot;</span>, l);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span> * head_b;  <span class="comment">//对头文件中定义的常量宏head_b进行调用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, b);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>此案例使用头文件对<code>C_Language_Learning_TEST.c</code>中的<code>int fuc_print(int f)</code>实现调用</p>
<p>注意,一个项目中只能有一个<code>main</code>函数,他是程序执行的入口,当出现复数<code>main</code>时会导致程序无法找到入口,从而报错</p>
<h3 id="局部变量与全局变量"><a href="#局部变量与全局变量" class="headerlink" title="局部变量与全局变量"></a>局部变量与全局变量</h3><h4 id="全局变量-不要用-不要用-不要用"><a href="#全局变量-不要用-不要用-不要用" class="headerlink" title="全局变量(不要用! 不要用!! 不要用!!!)"></a>全局变量(不要用! 不要用!! 不要用!!!)</h4><p><strong>全局变量</strong>是指在所有函数之外定义的变量，可以被程序中所有函数访问和修改,它的作用域是从变量定义开始，直到程序结束为止，<strong>在整个程序的生命周期内存在</strong>,</p>
<ul>
<li><p><strong>作用域</strong>：全局变量的作用域是整个程序，即可以在程序中的任何地方被访问（在同一源文件或通过<code>extern</code>声明的其他源文件）且全局变量常用于在多个函数之间共享数据，而不需要显式传递参数</p>
</li>
<li><p><strong>生命周期</strong>：全局变量从程序开始执行时创建，并且直到程序结束时才会被销毁。</p>
</li>
<li><p><strong>内存位置</strong>：全局变量通常存储在静态数据区（静态存储区）中，而不是栈或堆中</p>
</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global_var = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function 1, global_var = %d\n&quot;</span>, global_var);</span><br><span class="line">    global_var++; <span class="comment">// 修改全局变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Function 1, global_var = %d\n&quot;</span>, global_var);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h5 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h5><ol>
<li><strong>命名冲突</strong>：全局变量如果和局部变量同名时，局部变量会覆盖全局变量的作用域。</li>
<li><strong>全局变量修改容易影响其他函数</strong>：由于全局变量可以被任何函数修改，可能会造成意外的数据修改。因此，需要小心使用全局变量，避免在复杂程序中难以跟踪的错误,故此我们一般避免使用全局变量</li>
</ol>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p><strong>局部变量</strong>是指在函数或代码块内部定义的变量，它只能在该函数或代码块内部使用，<strong>在该范围之外是不可见的</strong>,局部变量通常用于函数的内部计算，不需要与其他函数共享数据,但可通过接口将局部变量传值给外部函数</p>
<ul>
<li><p><strong>作用域</strong>：局部变量的作用域仅限于定义它的函数或代码块。它在函数或块外是不可见的。</p>
</li>
<li><p><strong>生命周期</strong>：局部变量的生命周期开始于函数或块的执行，结束于函数或块的结束。每次函数调用时，都会创建新的局部变量。</p>
</li>
<li><p><strong>内存位置</strong>：局部变量通常存储在<strong>栈</strong>中，函数结束时会自动销毁</p>
</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;C_L_Header.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fuc_factorial</span><span class="params">(<span class="type">int</span> f)</span></span><br><span class="line">&#123;</span><br><span class="line">    f = <span class="number">22</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number is %d\n&quot;</span>, f);</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>; <span class="comment">//局部变量a的作用域仅在main()函数的&#123;&#125;中</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;number is %d\n&quot;</span>,a);</span><br><span class="line"></span><br><span class="line">    fuc_factorial(a); <span class="comment">//局部变量a传值给fuc_factorial()函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h5 id="注意事项：-1"><a href="#注意事项：-1" class="headerlink" title="注意事项："></a>注意事项：</h5><ol>
<li><strong>作用范围受限</strong>：局部变量只能在它定义的函数或代码块内使用，不能在其他函数中访问。</li>
<li><strong>局部变量不保留值</strong>：每次进入函数时，局部变量都会重新创建，之前的值不会保留。</li>
<li><strong>栈溢出</strong>：过多的局部变量会导致栈内存不足，导致程序栈溢出（特别是在递归调用中）</li>
</ol>
<h4 id="sp-静态局部变量"><a href="#sp-静态局部变量" class="headerlink" title="sp.静态局部变量"></a>sp.静态局部变量</h4><p>静态局部变量是局部变量的一种特殊形式，它的生命周期是程序的整个执行过程，但它的作用域仍然局限在定义它的函数中,静态局部变量在程序执行期间只被初始化一次，并且它的值在函数调用结束后仍然保持</p>
<ul>
<li>在局部变量的定义前加上关键字<code>static</code>即可定义静态变量</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> static_var = <span class="number">0</span>; <span class="comment">// 静态局部变量 //static 变量类型 变量名 = 值;</span></span><br><span class="line">    static_var++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;static_var = %d\n&quot;</span>, static_var);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    function();</span><br><span class="line">    function();</span><br><span class="line">    function(); <span class="comment">// 连续调用函数，static_var的值会累加</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>适合用来当全局计数器</p>
<h2 id="构造体"><a href="#构造体" class="headerlink" title="构造体"></a>构造体</h2><p>构造体（<code>struct</code>）是C语言中非常重要的特性，它允许将不同类型的变量组合在一起，形成一种更复杂的数据类型</p>
<h3 id="标准构造体"><a href="#标准构造体" class="headerlink" title="标准构造体"></a>标准构造体</h3><ul>
<li>定义一个<code>struct</code>类型的变量时，需要使用<code>struct</code>关键字，后跟结构体标签，例如<code>struct name &#123; &#125;</code>进行构造体定义</li>
<li>在函数中使用时应先进行实例化<code>struct name instancename;</code></li>
<li>通过**<code>.</code>（点操作符）**来访问构造体成员，例如<code>instance mane.parameter = value</code>进行指名修改值</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ababa_s</span>  //定义一般构造体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> ber;</span><br><span class="line">    <span class="type">float</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ababa_s</span> <span class="title">s</span>=</span>&#123; <span class="number">19</span>,<span class="string">&#x27;k&#x27;</span>,<span class="number">1.6</span>&#125;; <span class="comment">//创建构造体实例,初始化并赋值</span></span><br><span class="line">    s.age = <span class="number">99</span>; <span class="comment">//指名赋值  //实例名.变量名 = 值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;构造体 :  %d %c %f \n&quot;</span>, s.age, s.ber, s.num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>sp.构造体初始化也可有<code>struct ababa_s s=&#123;0&#125;;</code>,其含义为所有值均为0</p>
<h3 id="构造体数组"><a href="#构造体数组" class="headerlink" title="构造体数组"></a>构造体数组</h3><p>利用构造体可以储存不同类型数值的特性,可以定义<strong>构造体数组</strong>，用于存储同类型的多个结构体变量,常用于构建信息列表</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ababa_s</span>  //一般构造体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">char</span> ber;</span><br><span class="line">    <span class="type">float</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">ababa_s</span> <span class="title">s</span>[3];</span> <span class="comment">//创建构造体数组</span></span><br><span class="line">    </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line"> &#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;请输入第 %d 组数据 (格式: 整数 字符 浮点数): \n&quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">     </span><br><span class="line">     scanf_s(<span class="string">&quot;%d %c %f&quot;</span>,&amp;s[i].age, &amp;s[i].ber,<span class="number">1</span>, &amp;s[i].num);  <span class="comment">//复合类型输入时&quot;&quot;中的空格决定了一个类型数据输入的中断</span></span><br><span class="line"></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;构造体 : %d %c %f \n&quot;</span>, s[i].age, s[i].ber, s[i].num);</span><br><span class="line"> &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>







<h3 id="构造体指针"><a href="#构造体指针" class="headerlink" title="构造体指针"></a>构造体指针</h3><p>可以使用<strong>指针</strong>来指向构造体变量，并通过<strong>箭头操作符 <code>-&gt;</code></strong> 访问成员</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ababa_s</span>  //一般构造体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;   </span><br><span class="line">    <span class="type">float</span> tall;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ababa_s</span> <span class="title">s</span> =</span> &#123;<span class="string">&quot;jojo&quot;</span>,<span class="number">17</span>,<span class="number">1.87</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ababa_s</span> <span class="title">sarr</span>[3] =</span> &#123; <span class="string">&quot;jojo&quot;</span>,<span class="number">17</span>,<span class="number">1.87</span> ,<span class="string">&quot;koko&quot;</span>,<span class="number">14</span>,<span class="number">1.56</span>,<span class="string">&quot;didi&quot;</span>,<span class="number">23</span>,<span class="number">1.77</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ababa_s</span>* <span class="title">p</span>;</span> <span class="comment">//定义构造体指针</span></span><br><span class="line">    p = &amp;s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用解地址符实现对构造体的修改 不常用</span></span><br><span class="line">    (*p).age = <span class="number">22</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d %.3fm\n&quot;</span>, (*p).name, (*p).age, (*p).tall); <span class="comment">//*的运算优先级低于.故此应加()才能保证编译正确</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用指针箭头实现对构造体的修改 常用</span></span><br><span class="line">    p = sarr;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;age = <span class="number">18</span>; <span class="comment">//此时p指向sarr[0] </span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s %d %.3fm\n&quot;</span>, p-&gt;name, p-&gt;age, p-&gt;tall);</span><br><span class="line">        p++; <span class="comment">//p+1后p指向sarr[1]</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>值的注意的是指针<code>p</code>每次加1,就会跳转到构造体数组下一个索引的起始位置</p>
<h3 id="匿名构造体"><a href="#匿名构造体" class="headerlink" title="匿名构造体"></a>匿名构造体</h3><p>在定义时可以省略标签，这种结构体被称为<strong>匿名结构体</strong>，适用于仅需要一次的结构体定义</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; point;</span><br></pre></td></tr></table></figure></div>



<h3 id="使用typedef另命名构造体"><a href="#使用typedef另命名构造体" class="headerlink" title="使用typedef另命名构造体"></a>使用<code>typedef</code>另命名构造体</h3><p><code>typedef</code>声明新的类型名来代替已有的类型名,方便后续调用</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ababa_s</span>  </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> tall;</span><br><span class="line">&#125;ab, * pab; <span class="comment">//定义构造体别名 和 指针别名</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> INTEGER; <span class="comment">//定义数据类型int的别名</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    ab s = &#123; <span class="number">0</span> &#125;; <span class="comment">//实例化构造体并初始化</span></span><br><span class="line">    pab p; <span class="comment">//实例化指针</span></span><br><span class="line">    INTEGER i = <span class="number">888</span>; <span class="comment">//INTEGER等价于int</span></span><br><span class="line"></span><br><span class="line">    p = &amp;s;</span><br><span class="line">    p-&gt;age = i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;age is %d&quot;</span>, p-&gt;age);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><code>typedef int INTEGER;</code>会在项目需要修改一类数据的类型时起到方便修改的作用</p>
<h3 id="构造体的嵌套"><a href="#构造体的嵌套" class="headerlink" title="构造体的嵌套"></a>构造体的嵌套</h3><p>可实现多个构造体的统一调用，使用<code>.</code>来进行层级穿透实现对子构造体实例的调用</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">address_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> addr[<span class="number">50</span>];</span><br><span class="line">&#125;ad;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    ad a; <span class="comment">//在构造体中实例化另一个构造体</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Info</span> <span class="title">nin</span> =</span> &#123;<span class="string">&quot;jojo&quot;</span>,<span class="number">14</span>&#125;;</span><br><span class="line">    strcpy_s(nin.name, <span class="keyword">sizeof</span>(nin.name), <span class="string">&quot;dio&quot;</span>);</span><br><span class="line">    strcpy_s(nin.a.addr, <span class="keyword">sizeof</span>(nin.a.addr), <span class="string">&quot;Mo li o jo&quot;</span>); <span class="comment">//通过nin向a写入数据</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;name %s \nage %d \naddress %s\n&quot;</span>, nin.name, nin.age, nin.a.addr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="构造体对齐"><a href="#构造体对齐" class="headerlink" title="构造体对齐"></a>构造体对齐</h3><h4 id="一般内存对齐"><a href="#一般内存对齐" class="headerlink" title="一般内存对齐"></a>一般内存对齐</h4><p>构造体中的成员会存储在内存中，但它们的存储位置通常会受<strong>对齐限制</strong>的影响。<strong>对齐</strong>是指编译器为提高CPU访问速度，对数据在内存中的存储方式进行调整。具体来说，编译器会根据<strong>对齐规则</strong>决定每个成员的存储位置，可能在成员之间插入一些“填充字节”（也叫做“空洞”）</p>
<ul>
<li><strong>基本对齐规则</strong>：构造体中每个成员的存储地址必须是该成员大小的整数倍。</li>
<li><strong>整体对齐规则</strong>：构造体的总大小必须是最大成员大小的整数倍。</li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;   <span class="comment">// 1字节</span></span><br><span class="line">    <span class="type">int</span> b;    <span class="comment">// 4字节</span></span><br><span class="line">    <span class="type">char</span> c;   <span class="comment">// 1字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Memory Layout: | a | - | - | - | b | b | b | b | c | - | - | - |</span></span><br><span class="line"><span class="comment">//该构造体的总大小应为 1+3 + 4 + 1+3 = 12个字节</span></span><br></pre></td></tr></table></figure></div>

<ul>
<li><code>char a</code>：占用1个字节，但为了对齐，接下来3个字节会被填充（padding），使得<code>b</code>的地址是4字节对齐。</li>
<li><code>int b</code>：占用4个字节。</li>
<li><code>char c</code>：占用1个字节，但为了对齐整个结构体的大小为最大成员（4字节<code>int</code>）的整数倍，最后会再填充3个字节。</li>
</ul>
<h4 id="强制对齐"><a href="#强制对齐" class="headerlink" title="强制对齐"></a>强制对齐</h4><p>C语言允许使用**<code>#pragma pack</code>**指令来改变默认的对齐方式，减少内存浪费，但可能会影响访问速度</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack(1)  <span class="comment">// 强制1字节对齐</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> pack()   <span class="comment">// 恢复默认对齐</span></span></span><br></pre></td></tr></table></figure></div>

<p>此时，该结构体的大小变为<strong>6字节</strong>，没有填充字节</p>
<h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体（<code>union</code>）是C语言中的一种数据结构，与结构体类似，但它们的内存分配方式不同。在共用体中，所有成员共享同一块内存空间，因此同一时间只能存储一个成员的值，这使得共用体的大小等于其最大成员的大小。共用体主要用于节省内存，特别适合在需要在不同时间存储不同类型的数据的场景下使用。</p>
<ul>
<li><p><strong>存储覆盖</strong>：由于共用体的所有成员共享内存空间，修改一个成员的值会覆盖其他成员的值。</p>
</li>
<li><p><strong>大小</strong>：共用体的大小等于其最大成员的大小，而不是所有成员大小之和。</p>
</li>
<li><p><strong>初始化</strong>：可以只对一个成员进行初始化，后续对其他成员赋值会覆盖之前的数据。</p>
</li>
<li><p><strong>用途场景</strong>：适用于需要节省内存的场景，或需要在同一位置以不同方式解释数据的场景，比如网络数据包、硬件寄存器操作等。</p>
</li>
</ul>
<p>共用体的定义与结构体类似，使用关键字 <code>union</code>。语法格式如下：</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line"></span><br><span class="line">    data.i = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data.i: %d\n&quot;</span>, data.i);</span><br><span class="line"></span><br><span class="line">    data.f = <span class="number">3.14</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data.f: %.2f\n&quot;</span>, data.f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：由于共用体成员共享同一内存空间，先前的 `i` 和 `f` 值会被覆盖</span></span><br><span class="line">    <span class="built_in">snprintf</span>(data.str, <span class="keyword">sizeof</span>(data.str), <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data.str: %s\n&quot;</span>, data.str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这段代码中，由于共用体 <code>data</code> 的成员共享同一块内存，赋值给 <code>data.f</code> 后会覆盖 <code>data.i</code> 的值。同理，赋值 <code>data.str</code> 后也会覆盖之前的成员值。</p>
<h5 id="共用体的优点"><a href="#共用体的优点" class="headerlink" title="共用体的优点"></a>共用体的优点</h5><ul>
<li><strong>节省内存</strong>：特别是在嵌入式系统或内存紧张的场景中，可以用共用体减少内存使用。</li>
<li><strong>数据解析</strong>：共用体可以用来解析复杂的数据结构，例如解析协议报文，可以用不同成员表示同一数据的不同解释方式。</li>
<li><strong>数据转换</strong>：在数据转换中，可以用共用体将数据视为不同类型处理，比如将 <code>int</code> 直接看作 <code>char</code> 数组处理。</li>
</ul>
<p>他或许可以作为一个可接收多数据类型但只保留最后一种输入类型的存储池,若是能有数据类型识别算法,应该可以实现无限制输入…..</p>
<h4 id="共用体与结构体的区别"><a href="#共用体与结构体的区别" class="headerlink" title="共用体与结构体的区别"></a>共用体与结构体的区别</h4><table>
<thead>
<tr>
<th>特性</th>
<th>共用体 (<code>union</code>)</th>
<th>结构体 (<code>struct</code>)</th>
</tr>
</thead>
<tbody><tr>
<td>内存分配</td>
<td>所有成员共享同一块内存空间，只分配最大成员的内存大小。</td>
<td>每个成员都有独立的内存空间，总大小是所有成员大小之和。</td>
</tr>
<tr>
<td>同时存储多个成员</td>
<td>不可以，只能同时存储一个成员的值。</td>
<td>可以，每个成员的值独立存在。</td>
</tr>
<tr>
<td>用途</td>
<td>节省内存，在不同时间存储不同类型的变量。</td>
<td>管理多个相关变量。</td>
</tr>
</tbody></table>
<h3 id="共用体与构造体的组合"><a href="#共用体与构造体的组合" class="headerlink" title="共用体与构造体的组合"></a>共用体与构造体的组合</h3><p>将共用体作为数据传入构造体的中间商,使得构造体实例可以调用共用体中的数据</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Info</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 strcpy_s 给 info.name 赋值</span></span><br><span class="line">    strcpy_s(info.name, <span class="keyword">sizeof</span>(info.name), <span class="string">&quot;John&quot;</span>);</span><br><span class="line"></span><br><span class="line">    info.data.i = <span class="number">10</span>;  <span class="comment">// 使用整数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s, Data: %d\n&quot;</span>, info.name, info.data.i);</span><br><span class="line"></span><br><span class="line">    info.data.f = <span class="number">3.14</span>;  <span class="comment">// 使用浮点数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s, Data: %.2f\n&quot;</span>, info.name, info.data.f);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 strcpy_s 给 info.data.str 赋值</span></span><br><span class="line">    strcpy_s(info.data.str, <span class="keyword">sizeof</span>(info.data.str), <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Name: %s, Data: %s\n&quot;</span>, info.name, info.data.str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>共用体<code>Data</code>中的<code>int</code>、<code>float</code>和<code>char</code>共享同一块内存。每次赋值时，前一个值会被覆盖</p>
<h2 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h2><p>C++是完全兼容C的，故此在正式学习数据结构前C++的个别语法可极大方便数据操作</p>
<h3 id="C-引用-1"><a href="#C-引用-1" class="headerlink" title="C++&amp;引用"></a>C++<code>&amp;</code>引用</h3><p>在函数参数列表中使用引用（例如 <code>int &amp;b</code>），告诉编译器不要创建参数的副本，而是直接使用调用函数时传入的变量，在这种情况下，<code>b</code> 成为传入变量的一个别名，可以直接操作这个变量的内容，而不需要通过指针或重新复制数据</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">AAA</span><span class="params">(<span class="type">int</span>&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	b++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">AAA</span>(a);  <span class="comment">//通过&amp;p操作，直接将AAA中计算的b值返回给了a</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>, a); <span class="comment">//此时a的值为2</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<h3 id="C-bool"><a href="#C-bool" class="headerlink" title="C++bool"></a>C++<code>bool</code></h3><p>没啥好说的，是个人都认识</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">bool</span> a = <span class="literal">true</span>;</span><br><span class="line">	<span class="type">bool</span> b = <span class="literal">false</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;a=%d,b=%d\n&quot;</span>, a, b); <span class="comment">//true为1 false为0</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>



<p>C BASE GRAMMER OVER</p>
]]></content>
      <categories>
        <category>C_Note</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>Data_structures_BaseDataType</title>
    <url>/2024/11/28/DataStructuresBase/</url>
    <content><![CDATA[<p>Data_structures_BaseDataType</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/images/DataStructures/house_tech.png"></p>
<p>本文代码采用C语言编写,用到了部分Cpp语法,详见<a class="button  regular" href="https://mikumikudaifans.github.io/Displace.github.io/2024/10/14/C_Note/" title="C_NOTE"><i class="fa-solid fa-play-circle"></i> C_NOTE</a> 的Cpp引用部分</p>
<p>由于每种数据结构各种操作需要相互协同工作才能起作用,总体代码长度过长,不方便阅读,故此我决定将不同操作分开讲解,并在章节最后附上整体的代码 <del>(其实就是合到一起)</del></p>
<h2 id="时间复杂度-空间复杂度"><a href="#时间复杂度-空间复杂度" class="headerlink" title="时间复杂度&空间复杂度"></a>时间复杂度&amp;空间复杂度</h2><h3 id="时间复杂度-time-complexity"><a href="#时间复杂度-time-complexity" class="headerlink" title="时间复杂度(time complexity)"></a>时间复杂度(time complexity)</h3><p>时间复杂度是指算法执行所需时间的量度，通常以输入规模 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 的函数形式表示。它反映了算法的运行时间如何随着输入规模的增加而变化。</p>
<ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：常数时间复杂度，与输入规模无关，执行时间固定。</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：线性时间复杂度，时间与输入规模成正比，如遍历数组。</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="8.682ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3837.6 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D459" d="M117 59Q117 26 142 26Q179 26 205 131Q211 151 215 152Q217 153 225 153H229Q238 153 241 153T246 151T248 144Q247 138 245 128T234 90T214 43T183 6T137 -11Q101 -11 70 11T38 85Q38 97 39 102L104 360Q167 615 167 623Q167 626 166 628T162 632T157 634T149 635T141 636T132 637T122 637Q112 637 109 637T101 638T95 641T94 647Q94 649 96 661Q101 680 107 682T179 688Q194 689 213 690T243 693T254 694Q266 694 266 686Q266 675 193 386T118 83Q118 81 118 75T117 65V59Z"></path></g><g data-mml-node="mi" transform="translate(1450,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="msub" transform="translate(1935,0)"><g data-mml-node="mi"><path data-c="1D454" d="M311 43Q296 30 267 15T206 0Q143 0 105 45T66 160Q66 265 143 353T314 442Q361 442 401 394L404 398Q406 401 409 404T418 412T431 419T447 422Q461 422 470 413T480 394Q480 379 423 152T363 -80Q345 -134 286 -169T151 -205Q10 -205 10 -137Q10 -111 28 -91T74 -71Q89 -71 102 -80T116 -111Q116 -121 114 -130T107 -144T99 -154T92 -162L90 -164H91Q101 -167 151 -167Q189 -167 211 -155Q234 -144 254 -122T282 -75Q288 -56 298 -13Q311 35 311 43ZM384 328L380 339Q377 350 375 354T369 368T359 382T346 393T328 402T306 405Q262 405 221 352Q191 313 171 233T151 117Q151 38 213 38Q269 38 323 108L331 118L384 328Z"></path></g><g data-mml-node="mn" transform="translate(510,-150) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mi" transform="translate(2848.6,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(3448.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：对数时间复杂度，适合分治法（如二分查找）。</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：平方时间复杂度，常见于嵌套循环</li>
</ul>
<p>通常我们观察一段代码的运行次数来判断它的时间复杂度</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">example</span><span class="params">(arr)</span>:</span></span><br><span class="line"><span class="function">    for i in range(len(arr)):</span></span><br><span class="line"><span class="function">        for j in range(len(arr)):</span></span><br><span class="line"><span class="function">            print(arr[i] + arr[j])</span></span><br></pre></td></tr></table></figure></div>

<p>外层循环运行 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 次，内层循环也运行 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.025ex" role="img" focusable="false" viewBox="0 -442 600 453"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g></g></g></svg></mjx-container> 次，因此时间复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container></p>
<h3 id="空间复杂度-space-complexity"><a href="#空间复杂度-space-complexity" class="headerlink" title="空间复杂度(space complexity)"></a>空间复杂度(space complexity)</h3><h4 id="常见情况"><a href="#常见情况" class="headerlink" title="常见情况"></a>常见情况</h4><ul>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.618ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2041 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mn" transform="translate(1152,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mo" transform="translate(1652,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：仅使用常数空间，通常为变量或指针的操作，如简单循环。</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="4.844ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 2141 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="mi" transform="translate(1152,0)"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mo" transform="translate(1752,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：需要存储所有输入元素的大小空间，如线性数组。</li>
<li><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="5.832ex" height="2.452ex" role="img" focusable="false" viewBox="0 -833.9 2577.6 1083.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D442" d="M740 435Q740 320 676 213T511 42T304 -22Q207 -22 138 35T51 201Q50 209 50 244Q50 346 98 438T227 601Q351 704 476 704Q514 704 524 703Q621 689 680 617T740 435ZM637 476Q637 565 591 615T476 665Q396 665 322 605Q242 542 200 428T157 216Q157 126 200 73T314 19Q404 19 485 98T608 313Q637 408 637 476Z"></path></g><g data-mml-node="mo" transform="translate(763,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msup" transform="translate(1152,0)"><g data-mml-node="mi"><path data-c="1D45B" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mn" transform="translate(633,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mo" transform="translate(2188.6,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>：需要矩阵或二维表结构的空间，如图论算法。</li>
</ul>
<h4 id="计算空间复杂度的步骤"><a href="#计算空间复杂度的步骤" class="headerlink" title="计算空间复杂度的步骤"></a>计算空间复杂度的步骤</h4><ol>
<li><strong>识别固定存储</strong>：如函数内的常量。</li>
<li><strong>计算辅助结构</strong>：例如数组、栈、队列。</li>
<li><strong>加和取上限</strong>：得到整体复杂度。</li>
</ol>
<p>高效算法应在降低时间复杂度的前提下尽量减少空间开销</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><p>线性表（Linear List）是计算机科学中一种常见的数据结构，用来表示元素按顺序排列的一组数据。在线性表中，数据元素之间存在一对一的线性关系，即每个数据元素有且仅有一个直接前驱和一个直接后继（第一个和最后一个元素除外）。线性表可用于各种场景，包括队列、栈、链表等</p>
<h3 id="顺序表-Sequence-List"><a href="#顺序表-Sequence-List" class="headerlink" title="顺序表(Sequence List)"></a>顺序表(Sequence List)</h3><p>顺序表 (Sequnce List) 使用一块连续的内存空间来存储线性表的数据元素。每个元素的存储位置可以通过一个下标直接访问,其本质是一个数组。</p>
<ul>
<li><p>优点：</p>
<ul>
<li>支持快速的随机访问，可以通过下标直接访问任何位置的元素。</li>
<li>空间利用率较高，不需要额外的存储空间。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>插入和删除元素的操作效率较低，涉及大量元素的移动。</li>
<li>顺序存储的大小固定，无法动态扩展。</li>
</ul>
</li>
</ul>
<h4 id="1-顺序表的静态定义"><a href="#1-顺序表的静态定义" class="headerlink" title="1. 顺序表的静态定义 :"></a>1. 顺序表的静态定义 :</h4><p>包含一个数组 和 一个用来记录当前顺序表长度的int变量</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  <span class="comment">//将顺序表的值类型另命名，方便后续修改数据类型类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义顺序表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">	ElemType data[MaxSize]; <span class="comment">//线性表本质是一个数组,被人为的添加了逻辑顺序和排序长度</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前顺序表中有多少个元素</span></span><br><span class="line">}SqList;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<h4 id="2-插入"><a href="#2-插入" class="headerlink" title="2.插入 :"></a>2.插入 :</h4><p>从插入位置开始，将后续元素依次向后移动，腾出插入位置</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在排序表第i个位置添加元素  //排序表从1开始  //索引表从0开始</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, ElemType element)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//参数归一化,方便后续操作</span></span><br><span class="line">	<span class="type">int</span> i_index = i - <span class="number">1</span>; <span class="comment">//将参数从排序表转换为索引表</span></span><br><span class="line">	<span class="type">int</span> length_index = L.length - <span class="number">1</span>; <span class="comment">//将参数从排序表长度转换为末端索引值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i_index &lt; <span class="number">0</span> || i_index &gt; length_index)  <span class="comment">//判断i是否合法,</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the position of i is illegal , change it to less than L.length\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (length_index == MaxSize)   <span class="comment">//存储空间满了则无法继续插入值</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"MaxSize cannot insert value\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	L.length++; <span class="comment">//因为要加入一个新元素,故长度加一</span></span><br><span class="line">	length_index = L.length - <span class="number">1</span>; <span class="comment">//由于L.length发生了变化,需更新length_index</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = length_index; j &gt;= i_index; j--) <span class="comment">//根据索引</span></span><br><span class="line">	{</span><br><span class="line">		L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	L.data[i_index] = element;</span><br><span class="line">	</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除 :"></a>3.删除 :</h4><p>从删除位置开始，将后续元素向前移动</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定元素值删除首个符合条件的元素  //若想删除所有的同一元素,则只需循环调用此函数即可</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DelteElement_by_value</span><span class="params">(SqList&amp; L, ElemType element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//初始化j,否则无法作为左操作数输入将其他变量的值赋予j</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length<span class="number">-1</span>; i++)<span class="comment">//获取第一个符合目标元素值的索引值</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (element == L.data[i])</span><br><span class="line">		{</span><br><span class="line">			j = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若未找到元素，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="number">-1</span>) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Element not found.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = j; i &lt; L.length - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		L.data[i] = L.data[i + <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定排序位置删除元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DelteElement_by_position</span><span class="params">(SqList&amp; L, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//参数归一化,方便后续操作</span></span><br><span class="line">	<span class="type">int</span> i_index = i - <span class="number">1</span>; <span class="comment">//将参数从排序表转换为索引表</span></span><br><span class="line">	<span class="type">int</span> length_index = L.length - <span class="number">1</span>; <span class="comment">//将参数从排序表长度转换为末端索引值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i_index &lt; <span class="number">0</span> || i_index &gt; length_index)  <span class="comment">//判断i是否合法,</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the position of i is illegal , change it to less than L.length\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = i_index; i &lt; L.length - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		L.data[i] = L.data[i + <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="4-查找"><a href="#4-查找" class="headerlink" title="4.查找 :"></a>4.查找 :</h4><p>直接通过下标访问目标位置元素</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//根据值查找该值所在的首个排序位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SerchFirstPosition_by_value</span><span class="params">(SqList&amp; L, ElemType element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//初始化j,否则无法作为左操作数输入将其他变量的值赋予j</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length - <span class="number">1</span>; i++)<span class="comment">//获取第一个符合目标元素值的排序位置</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (element == L.data[i])</span><br><span class="line">		{</span><br><span class="line">			j = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若未找到元素，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="number">-1</span>) </span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Element not found.\n"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the first position of value:%d is %d\n"</span>, element,j);</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据值查找该值所在的所有排序位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SerchAllPositions_by_value</span><span class="params">(SqList&amp; L, ElemType element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//初始化j,否则无法作为左操作数输入将其他变量的值赋予j</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= L.length<span class="number">-1</span>; i++)<span class="comment">//获取第一个符合目标元素值的排序位置</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (element == L.data[i])</span><br><span class="line">		{</span><br><span class="line">			j = i + <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the position of value:%d is %d\n"</span>, element, j);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若未找到元素，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The Element of %d is not found.\n"</span>, element);</span><br><span class="line">	}	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="顺序表总体代码"><a href="#顺序表总体代码" class="headerlink" title="顺序表总体代码"></a>顺序表总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>顺序表 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;  <span class="comment">//将顺序表的值类型另命名，方便后续修改数据类型类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义顺序表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">	ElemType data[MaxSize]; <span class="comment">//线性表本质是一个数组,被人为的添加了逻辑顺序和排序长度</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//当前顺序表中有多少个元素</span></span><br><span class="line">}SqList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在排序表第i个位置添加元素  //排序表从1开始  //索引表从0开始</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ListInsert</span><span class="params">(SqList&amp; L, <span class="type">int</span> i, ElemType element)</span> </span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//参数归一化,方便后续操作</span></span><br><span class="line">	<span class="type">int</span> i_index = i - <span class="number">1</span>; <span class="comment">//将参数从排序表转换为索引表</span></span><br><span class="line">	<span class="type">int</span> length_index = L.length - <span class="number">1</span>; <span class="comment">//将参数从排序表长度转换为末端索引值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i_index &lt; <span class="number">0</span> || i_index &gt; length_index)  <span class="comment">//判断i是否合法,</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the position of i is illegal , change it to less than L.length\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (length_index == MaxSize)   <span class="comment">//存储空间满了则无法继续插入值</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"MaxSize cannot insert value\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	L.length++; <span class="comment">//因为要加入一个新元素,故长度加一</span></span><br><span class="line">	length_index = L.length - <span class="number">1</span>; <span class="comment">//由于L.length发生了变化,需更新length_index</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = length_index; j &gt;= i_index; j--) <span class="comment">//根据索引</span></span><br><span class="line">	{</span><br><span class="line">		L.data[j] = L.data[j - <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	L.data[i_index] = element;</span><br><span class="line">	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定元素值删除首个符合条件的元素  //若想删除所有的同一元素,则只需循环调用此函数即可</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DelteElement_by_value</span><span class="params">(SqList&amp; L, ElemType element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//初始化j,否则无法作为左操作数输入将其他变量的值赋予j</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length<span class="number">-1</span>; i++)<span class="comment">//获取第一个符合目标元素值的索引值</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (element == L.data[i])</span><br><span class="line">		{</span><br><span class="line">			j = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若未找到元素，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="number">-1</span>) {</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Element not found.\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = j; i &lt; L.length - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		L.data[i] = L.data[i + <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//指定排序位置删除元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DelteElement_by_position</span><span class="params">(SqList&amp; L, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="comment">//参数归一化,方便后续操作</span></span><br><span class="line">	<span class="type">int</span> i_index = i - <span class="number">1</span>; <span class="comment">//将参数从排序表转换为索引表</span></span><br><span class="line">	<span class="type">int</span> length_index = L.length - <span class="number">1</span>; <span class="comment">//将参数从排序表长度转换为末端索引值</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (i_index &lt; <span class="number">0</span> || i_index &gt; length_index)  <span class="comment">//判断i是否合法,</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"the position of i is illegal , change it to less than L.length\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = i_index; i &lt; L.length - <span class="number">1</span>; i++)</span><br><span class="line">	{</span><br><span class="line">		L.data[i] = L.data[i + <span class="number">1</span>];</span><br><span class="line">	}</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据值查找该值所在的首个排序位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SerchFirstPosition_by_value</span><span class="params">(SqList&amp; L, ElemType element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//初始化j,否则无法作为左操作数输入将其他变量的值赋予j</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length - <span class="number">1</span>; i++)<span class="comment">//获取第一个符合目标元素值的排序位置</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (element == L.data[i])</span><br><span class="line">		{</span><br><span class="line">			j = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若未找到元素，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="number">-1</span>) </span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Element not found.\n"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"the first position of value:%d is %d\n"</span>, element,j);</span><br><span class="line">	<span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据值查找该值所在的所有排序位置</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SerchAllPositions_by_value</span><span class="params">(SqList&amp; L, ElemType element)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//初始化j,否则无法作为左操作数输入将其他变量的值赋予j</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= L.length<span class="number">-1</span>; i++)<span class="comment">//获取第一个符合目标元素值的排序位置</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span> (element == L.data[i])</span><br><span class="line">		{</span><br><span class="line">			j = i + <span class="number">1</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"the position of value:%d is %d\n"</span>, element, j);</span><br><span class="line">		}</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 若未找到元素，返回 false</span></span><br><span class="line">	<span class="keyword">if</span> (j == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The Element of %d is not found.\n"</span>, element);</span><br><span class="line">	}	</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印列表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintList</span><span class="params">(SqList L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">{</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%3d"</span>, L.data[i]);</span><br><span class="line">}</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n-------length=%d---------\n"</span>, L.length);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SqList L;</span><br><span class="line">	L.data[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//向顺序表中添加数值</span></span><br><span class="line">	L.data[<span class="number">1</span>] = <span class="number">7</span>;</span><br><span class="line">	L.data[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">	L.data[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">	L.data[<span class="number">4</span>] = <span class="number">5</span>;</span><br><span class="line">	L.data[<span class="number">5</span>] = <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">	L.length = <span class="number">6</span>; <span class="comment">//设置长度</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">PrintList</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//ListInsert(L, 3, 99);</span></span><br><span class="line">	<span class="comment">//PrintList(L);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//ListInsert(L, 7, 90);</span></span><br><span class="line">	<span class="comment">//PrintList(L);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//DelteElement_by_value(L,7);</span></span><br><span class="line">	<span class="comment">//PrintList(L);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//DelteElement_by_position(L, 4);</span></span><br><span class="line">	<span class="comment">//PrintList(L);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//SerchFirstPosition_by_value(L, 7);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">SerchAllPositions_by_value</span>(L, <span class="number">88</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>



<hr>
<h3 id="单链表-Single-Linked-List"><a href="#单链表-Single-Linked-List" class="headerlink" title="单链表(Single Linked List)"></a>单链表(Single Linked List)</h3><p>单链表是一种链式数据结构，用于存储一组节点。每个节点包含数据域和指针域，其中：</p>
<ol>
<li><strong>数据域（Data Field）</strong>：存储节点的数据。</li>
<li><strong>指针域（Next Field）</strong>：存储指向下一个节点的指针。</li>
</ol>
<p><del><strong>注意</strong>,这里构造的单链表头节点内无值,但因visual studio2022会自动在输出时为空的值域填充随机值,故用我们这里NULL即0填充,在实际使用链表时头节点会被填充数据,写入链表长度或其他数值信息</del></p>
<p>我改主意了,头节点数据填入链表长度</p>
<p>在链表中,节点的概念是逻辑性的虚拟的,实际代码层面只存在<strong>包含于构造体中的指针和数据</strong></p>
<h4 id="1-创建单链表"><a href="#1-创建单链表" class="headerlink" title="1.创建单链表"></a>1.创建单链表</h4><p>包含数据域 和 指针域,指针用于指向下一个结构体(节点)</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>{</span><br><span class="line">	ElementType data;  <span class="comment">//数据域</span></span><br><span class="line">	LNode* next;  <span class="comment">//指向结构体LNode的指针  </span></span><br><span class="line">}LNode,*LinkList;   <span class="comment">//定义链表的名字和头指针  //*LinkList表示LinkList是一个指针变量，指向结构体LNode的首地址</span></span><br><span class="line"><span class="comment">//LNode* 和 LinkList 都可以表示结构体LNode的首地址</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-头插法添加节点"><a href="#2-头插法添加节点" class="headerlink" title="2.头插法添加节点"></a>2.头插法添加节点</h4><p><img lazyload="" src="/images/loading.svg" data-src="/images/DataStructures/head_insert.png"></p>
<p>头插法是一种在链表头部插入节点的方式，适用于倒序建立链表。步骤如下：</p>
<ol>
<li>为新节点分配内存。</li>
<li>设置新节点的数据值。</li>
<li>将新节点的 <code>next</code> 指针指向当前的头节点。</li>
<li>更新头指针，使其指向新节点。</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//头插法，将新结点插入到链表的头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_head_insert</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LNode* s; <span class="comment">//定义一个指针变量s，指向新结点</span></span><br><span class="line">	ElementType x = <span class="number">0</span>; <span class="comment">//定义一个变量x，用于输入数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建头结点</span></span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给链表的头结点,malloc申请内存后返回首地址给到L,则L为结构体LNode的首地址(即头指针)</span></span><br><span class="line">	L-&gt;data = x;  <span class="comment">//头结点的data域置0</span></span><br><span class="line">	L-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//头插法，将新结点插入到链表的头部</span></span><br><span class="line">	<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//首次输入数据</span></span><br><span class="line">	<span class="keyword">while</span>(x != <span class="number">9999</span>) </span><br><span class="line">	{</span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给新结点		</span></span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		s-&gt;next = L-&gt;next; <span class="comment">//新结点的指针域指向旧头结点</span></span><br><span class="line">		L-&gt;next = s; <span class="comment">//将头结点的指针域指向新结点</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//再次输入数据,直到输入9999结束</span></span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkList L; <span class="comment">//定义链表的头指针.L为结构体类型的指针变量，指向结构体LNode的头节点地址</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="3-尾插法添加节点"><a href="#3-尾插法添加节点" class="headerlink" title="3.尾插法添加节点"></a>3.尾插法添加节点</h4><p><img lazyload="" src="/images/loading.svg" data-src="/images/DataStructures/tail_insert.png"></p>
<p>尾插法是将新节点添加到链表尾部，适用于顺序建立链表。步骤如下：</p>
<ol>
<li>为新节点分配内存。</li>
<li>设置新节点的数据值。</li>
<li>将当前尾节点的 <code>next</code> 指针指向新节点。</li>
<li>更新尾节点，使其指向新节点</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//尾插法，将新结点插入到链表的尾部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_tail_insert</span><span class="params">(LinkList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LNode* s,*r; <span class="comment">//定义一个指针变量s，指向新结点</span></span><br><span class="line">	ElementType x = <span class="number">0</span>; <span class="comment">//定义一个变量x，用于输入数据</span></span><br><span class="line">	<span class="comment">//创建头结点</span></span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给链表的头结点,malloc申请内存后返回首地址给到L,则L为结构体LNode的首地址(即头指针)</span></span><br><span class="line">	L-&gt;data = x;  <span class="comment">//头结点的data域置0</span></span><br><span class="line">	L-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	r = L; <span class="comment">//r指向头结点</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    <span class="comment">//尾插法，将新结点插入到链表的尾部</span></span><br><span class="line">	<span class="keyword">while</span>(x != <span class="number">9999</span>)</span><br><span class="line">	{ </span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		r-&gt;next =s; <span class="comment">//将r的指针域指向新结点,在第一次循环时,相当于让L的指针域指向新结点,以为上文定义了*r =L</span></span><br><span class="line">		r = s; <span class="comment">//r指向新结点</span></span><br><span class="line">		<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//输入数据</span></span><br><span class="line">	}</span><br><span class="line">	r-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//最后一个结点的指针域置空</span></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkList L; <span class="comment">//定义链表的头指针.L为结构体类型的指针变量，指向结构体LNode的头节点地址</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="5-单链表查询"><a href="#5-单链表查询" class="headerlink" title="5.单链表查询"></a>5.单链表查询</h4><ol>
<li>定义计数器变量</li>
<li>考虑非法参数并给出返回值</li>
<li>用while循环从头节点开始遍历链表,由计数器控制步数</li>
<li>考虑查找失败结果</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按位置查找结点</span></span><br><span class="line"><span class="function">LNode* <span class="title">List_search_position</span><span class="params">(LinkList L, <span class="type">int</span> serch_position)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//定义一个变量i，用于记录当前结点的位置</span></span><br><span class="line">	<span class="keyword">if</span> (serch_position &lt; <span class="number">1</span>) <span class="comment">//如果serch_position小于1,则返回空指针</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"serch_position is less than 1,i will return head pointer,it means the serch_position is 1\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (serch_position &gt; L-&gt;data) <span class="comment">//如果serch_position大于链表的长度,则返回空指针</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"serch_position is greater than the length of the list\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (L != <span class="literal">nullptr</span> &amp;&amp; i != serch_position)<span class="comment">//当L不为空且i不等于serch_position时,遍历链表</span></span><br><span class="line">	{</span><br><span class="line">		L = L-&gt;next; <span class="comment">//L指向下一个结点</span></span><br><span class="line">		i++; </span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i != serch_position) <span class="comment">//如果循环完毕后,i不等于serch_position,则说明没有找到serch_position位置的结点</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The serch_position is not found,it may because the serch_position is greater than the length of the list\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> L; <span class="comment">//返回目标结点的指针</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找结点</span></span><br><span class="line"><span class="function">LNode* <span class="title">List_search_value</span><span class="params">(LinkList L, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (L != <span class="literal">nullptr</span> &amp;&amp; L-&gt;data != x) <span class="comment">//当L不为空且L的data域不等于x时,循环</span></span><br><span class="line">	{</span><br><span class="line">		L = L-&gt;next; <span class="comment">//L指向下一个结点</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (L != <span class="literal">nullptr</span>) <span class="comment">//如果L不为空,则返回L</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> L;  <span class="comment">//当循环完毕后,如果L不为空且L的data域等于x,则说明找到了x值对应的结点 //返回找到的结点</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//如果L为空,则说明没有找到x值对应的结点</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The value is not found\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkList Serch_pointer;<span class="comment">//定义指针变量，指向要查找的结点</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="6-按位置插入节点"><a href="#6-按位置插入节点" class="headerlink" title="6.按位置插入节点"></a>6.按位置插入节点</h4><ol>
<li>定义一个指针变量s，用于指向新结点</li>
<li>考虑在第一个位置插入的结点的情况，此时直接应用头插法算法</li>
<li>通过<code>List_search_position(L, insert_position - 1)</code>获取<strong>目标结点的前一个结点的指针域的值</strong></li>
<li>判断p是否为空，决定是否执行插入算法</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按位置插入结点到第insert_position个位置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List_insert_position</span><span class="params">(LinkList L, <span class="type">int</span> insert_position, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	</span><br><span class="line">	LinkList s; <span class="comment">//定义一个指针变量s，用于指向新结点</span></span><br><span class="line">	<span class="keyword">if</span> (insert_position == <span class="number">1</span>) {</span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给新结点</span></span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		s-&gt;next = L-&gt;next; <span class="comment">//新结点的指针域指向旧头结点</span></span><br><span class="line">		L-&gt;next = s; <span class="comment">//将头结点的指针域指向新结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	LinkList p = <span class="built_in">List_search_position</span>(L, insert_position - <span class="number">1</span>);<span class="comment">//p指向insert_position位置的结点，即p的值为目标结点的前一个结点的指针域的值</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">//如果s为空,则说明insert_position大于链表的长度,插入到尾结点之后</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"insert_position is greater than the length of the list,you can't insert it\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给新结点</span></span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		s-&gt;next = p-&gt;next; <span class="comment">//新结点的指针域指向旧结点的下一个结点</span></span><br><span class="line">		p-&gt;next = s; <span class="comment">//将旧结点的指针域指向新结点</span></span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="7-单链表删除节点"><a href="#7-单链表删除节点" class="headerlink" title="7.单链表删除节点"></a>7.单链表删除节点</h4><ol>
<li>通过<code>List_search_position(L, insert_position - 1)</code>获取<strong>目标结点的前一个结点的指针域的值</strong></li>
<li>判断p是否为空，决定是否执行删除算法</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按位置删除指定结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List_delete_position</span><span class="params">(LinkList &amp;L, <span class="type">int</span> delete_position)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">	LinkList p = <span class="built_in">List_search_position</span>(L, delete_position - <span class="number">1</span>); <span class="comment">//p指向要删除的结点</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">//如果p为空,则说明delete_position大于链表的长度,删除失败</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"delete_position is greater than the length of the list,you can't delete it\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		LinkList q; <span class="comment">//定义一个指针变量q，用于储存被删除结点的地址</span></span><br><span class="line">		q = p-&gt;next; <span class="comment">//q获得了目标节点的指针域的值</span></span><br><span class="line">		p-&gt;next = q-&gt;next; <span class="comment">//将p的指针域指向q的下一个结点</span></span><br><span class="line">		<span class="built_in">free</span>(q); <span class="comment">//释放要删除的结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="单链表总体代码"><a href="#单链表总体代码" class="headerlink" title="单链表总体代码"></a>单链表总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>单链表总体代码 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span>{</span><br><span class="line">	ElementType data;  <span class="comment">//数据域</span></span><br><span class="line">	LNode* next;  <span class="comment">//指向结构体LNode的指针  </span></span><br><span class="line">}LNode,*LinkList;   <span class="comment">//定义链表的名字和头指针  //*LinkList表示LinkList是一个指针变量，指向结构体LNode的首地址</span></span><br><span class="line"><span class="comment">//LNode* 和 LinkList 都可以表示结构体LNode的首地址</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法，将新结点插入到链表的头部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_head_insert</span><span class="params">(LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LNode* s; <span class="comment">//定义一个指针变量s，指向新结点</span></span><br><span class="line">	ElementType x = <span class="number">0</span>; <span class="comment">//定义一个变量x，用于输入数据</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//创建头结点</span></span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给链表的头结点,malloc申请内存后返回首地址给到L,则L为结构体LNode的首地址(即头指针)</span></span><br><span class="line">	<span class="comment">//L-&gt;data = x;  //头结点的data域置0</span></span><br><span class="line">	L-&gt;data = <span class="number">99</span>;  <span class="comment">//头结点的data域置为链表长度,注意这里的99是随便设置的,具体取值要根据链表实际长度来确定</span></span><br><span class="line">	L-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//头插法，将新结点插入到链表的头部</span></span><br><span class="line">	<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//首次输入数据</span></span><br><span class="line">	<span class="keyword">while</span>(x != <span class="number">9999</span>) </span><br><span class="line">	{</span><br><span class="line"></span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给新结点		</span></span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		s-&gt;next = L-&gt;next; <span class="comment">//新结点的指针域指向旧头结点</span></span><br><span class="line">		L-&gt;next = s; <span class="comment">//将头结点的指针域指向新结点</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//再次输入数据,直到输入9999结束</span></span><br><span class="line"></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法，将新结点插入到链表的尾部</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_tail_insert</span><span class="params">(LinkList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LNode* s,*r; <span class="comment">//定义一个指针变量s，指向新结点    r，指向最后一个结点</span></span><br><span class="line">	ElementType x = <span class="number">0</span>; <span class="comment">//定义一个变量x，用于输入数据</span></span><br><span class="line">	<span class="comment">//创建头结点</span></span><br><span class="line">	L = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给链表的头结点,malloc申请内存后返回首地址给到L,则L为结构体LNode的首地址(即头指针)</span></span><br><span class="line">	<span class="comment">//L-&gt;data = x;  //头结点的data域置0</span></span><br><span class="line">	L-&gt;data = <span class="number">99</span>;  <span class="comment">//头结点的data域置为链表长度,注意这里的99是随便设置的,具体取值要根据链表实际长度来确定</span></span><br><span class="line">	L-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">	r = L; <span class="comment">//r指向头结点</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line">    <span class="comment">//尾插法，将新结点插入到链表的尾部</span></span><br><span class="line">	<span class="keyword">while</span>(x != <span class="number">9999</span>)</span><br><span class="line">	{ </span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));</span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		r-&gt;next =s; <span class="comment">//将r的指针域指向新结点,在第一次循环时,相当于让L的指针域指向新结点,以为上文定义了*r =L</span></span><br><span class="line">		r = s; <span class="comment">//r指向新结点</span></span><br><span class="line">		<span class="built_in">scanf_s</span>(<span class="string">"%d"</span>, &amp;x);<span class="comment">//输入数据</span></span><br><span class="line">	}</span><br><span class="line">	r-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//最后一个结点的指针域置空</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置查找结点</span></span><br><span class="line"><span class="function">LNode* <span class="title">List_search_position</span><span class="params">(LinkList L, <span class="type">int</span> serch_position)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//定义一个变量i，用于记录当前结点的位置</span></span><br><span class="line">	<span class="keyword">if</span> (serch_position &lt; <span class="number">1</span>) <span class="comment">//如果serch_position小于1,则返回空指针</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"serch_position is less than 1,i will return head pointer,it means the serch_position is 1\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> L;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (serch_position &gt; L-&gt;data) <span class="comment">//如果serch_position大于链表的长度,则返回空指针</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"serch_position is greater than the length of the list\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (L != <span class="literal">nullptr</span> &amp;&amp; i != serch_position)<span class="comment">//当L不为空且i不等于serch_position时,遍历链表</span></span><br><span class="line">	{</span><br><span class="line">		L = L-&gt;next; <span class="comment">//L指向下一个结点</span></span><br><span class="line">		i++; </span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(i != serch_position) <span class="comment">//如果循环完毕后,i不等于serch_position,则说明没有找到serch_position位置的结点</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The serch_position is not found,it may because the serch_position is greater than the length of the list\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> L; <span class="comment">//返回目标结点的指针</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按值查找结点</span></span><br><span class="line"><span class="function">LNode* <span class="title">List_search_value</span><span class="params">(LinkList L, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (L != <span class="literal">nullptr</span> &amp;&amp; L-&gt;data != x) <span class="comment">//当L不为空且L的data域不等于x时,循环</span></span><br><span class="line">	{</span><br><span class="line">		L = L-&gt;next; <span class="comment">//L指向下一个结点</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">if</span> (L != <span class="literal">nullptr</span>) <span class="comment">//如果L不为空,则返回L</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> L;  <span class="comment">//当循环完毕后,如果L不为空且L的data域等于x,则说明找到了x值对应的结点 //返回找到的结点</span></span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span> <span class="comment">//如果L为空,则说明没有找到x值对应的结点</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"The value is not found\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置插入结点到第insert_position个位置</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List_insert_position</span><span class="params">(LinkList L, <span class="type">int</span> insert_position, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	</span><br><span class="line">	LinkList s; <span class="comment">//定义一个指针变量s，用于指向新结点</span></span><br><span class="line">	<span class="keyword">if</span> (insert_position == <span class="number">1</span>) {</span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给新结点</span></span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		s-&gt;next = L-&gt;next; <span class="comment">//新结点的指针域指向旧头结点</span></span><br><span class="line">		L-&gt;next = s; <span class="comment">//将头结点的指针域指向新结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	LinkList p = <span class="built_in">List_search_position</span>(L, insert_position - <span class="number">1</span>);<span class="comment">//p指向insert_position位置的结点，即p的值为目标结点的前一个结点的指针域的值</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">//如果s为空,则说明insert_position大于链表的长度,插入到尾结点之后</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"insert_position is greater than the length of the list,you can't insert it\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		s = (LinkList)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LNode));  <span class="comment">//分配内存给新结点</span></span><br><span class="line">		s-&gt;data = x; <span class="comment">//给新结点赋值</span></span><br><span class="line">		s-&gt;next = p-&gt;next; <span class="comment">//新结点的指针域指向旧结点的下一个结点</span></span><br><span class="line">		p-&gt;next = s; <span class="comment">//将旧结点的指针域指向新结点</span></span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//按位置删除指定结点</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">List_delete_position</span><span class="params">(LinkList &amp;L, <span class="type">int</span> delete_position)</span></span></span><br><span class="line"><span class="function"></span>{ </span><br><span class="line">	LinkList p = <span class="built_in">List_search_position</span>(L, delete_position - <span class="number">1</span>); <span class="comment">//p指向要删除的结点</span></span><br><span class="line">	<span class="keyword">if</span> (p == <span class="literal">nullptr</span>) <span class="comment">//如果p为空,则说明delete_position大于链表的长度,删除失败</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"delete_position is greater than the length of the list,you can't delete it\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		LinkList q; <span class="comment">//定义一个指针变量q，用于储存被删除结点的地址</span></span><br><span class="line">		q = p-&gt;next; <span class="comment">//q获得了目标节点的指针域的值</span></span><br><span class="line">		p-&gt;next = q-&gt;next; <span class="comment">//将p的指针域指向q的下一个结点</span></span><br><span class="line">		<span class="built_in">free</span>(q); <span class="comment">//释放要删除的结点</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印链表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">List_print</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span>(L != <span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, L-&gt;data);</span><br><span class="line">		L = L-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}	</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LinkList L; <span class="comment">//定义链表的头指针.L为结构体类型的指针变量，指向结构体LNode的头节点地址</span></span><br><span class="line">	LinkList Serch_pointer;<span class="comment">//定义指针变量，指向要查找的结点</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">List_head_insert</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//List_tail_insert(L);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">List_print</span>(L);</span><br><span class="line"></span><br><span class="line">	Serch_pointer = <span class="built_in">List_search_position</span>(L, <span class="number">1</span>); <span class="comment">//查找第3个结点</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"The data of the serch_pointer is %d\n"</span>, Serch_pointer-&gt;data);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Serch_pointer = List_search_value(L, 10); //查找值为10的结点</span></span><br><span class="line">	<span class="comment">//printf("The data of the serch_pointer is %d and the value is %d\n", L, Serch_pointer-&gt;data);</span></span><br><span class="line">	<span class="comment">////打印指针没有实际意义，只是为了测试指针是否存在,层序每次运行的结果都不一样，所以指针的值也是随机的</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//List_insert_position(L, 1, 100); //在第3个位置插入值为100的结点</span></span><br><span class="line">	<span class="comment">//List_print(L);</span></span><br><span class="line"></span><br><span class="line">	<span class="built_in">List_delete_position</span>(L, <span class="number">1</span>); <span class="comment">//删除第3个结点</span></span><br><span class="line">	<span class="built_in">List_print</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h2 id="栈-（Stack）"><a href="#栈-（Stack）" class="headerlink" title="栈 （Stack）"></a>栈 （Stack）</h2><p>栈是一种**后进先出（LIFO）**的数据结构。栈中元素只能在一端添加或移除，这一端被称为“栈顶”。在栈的操作中，常用的操作有：</p>
<ul>
<li><strong>push</strong>：将元素压入栈顶。</li>
<li><strong>pop</strong>：将栈顶元素弹出。</li>
<li><strong>peek</strong>：查看栈顶元素，但不移除它。</li>
</ul>
<p><strong>栈的应用</strong>：广泛用于递归算法、表达式求值、括号匹配、函数调用等场景。</p>
<p>栈的本质为人为控制进出规则的数组,通过控制索引来控制数组中的数据进出，栈可以顺序定义也可链式定义</p>
<h3 id="顺序栈-squencial-stack"><a href="#顺序栈-squencial-stack" class="headerlink" title="顺序栈(squencial stack)"></a>顺序栈(squencial stack)</h3><p>有顺序表发展而来的数据结构，其在内存中需要连续的空间</p>
<h4 id="1-顺序栈结构定义"><a href="#1-顺序栈结构定义" class="headerlink" title="1.顺序栈结构定义"></a>1.顺序栈结构定义</h4><p>顺序栈由一个数组和一个用于标记数组索引的整型值组成</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈(squencial stack)结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Stack</span></span><br><span class="line">{</span><br><span class="line">	ElementType data[MAX_SIZE];<span class="comment">//栈体</span></span><br><span class="line">	<span class="type">int</span> top;<span class="comment">//栈顶索引</span></span><br><span class="line">}SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SqStack S;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="2-初始化栈"><a href="#2-初始化栈" class="headerlink" title="2.初始化栈"></a>2.初始化栈</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	S.top = <span class="number">-1</span>;<span class="comment">//栈顶索引初始化为-1,表示栈为空 同时意味着栈索引从0开始</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="3-入栈操作-Push"><a href="#3-入栈操作-Push" class="headerlink" title="3.入栈操作(Push)"></a>3.入栈操作(Push)</h4><ol>
<li>判断是否可继续入栈</li>
<li>修改索引，填值</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//判断栈是否为满</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsStackFull</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == MAdata_x_SIZE - <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is full!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作(Push)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack&amp; S, ElementType data_x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsStackFull</span>(S))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//S.top++;</span></span><br><span class="line">		<span class="comment">//S.data[S.top] = data_x; //该代码可被优化</span></span><br><span class="line"></span><br><span class="line">		S.data[++S.top] = data_x; <span class="comment">//优化后代码  其中[++S.top]表示S.data索引自增1，然后将data_x值存入栈顶</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="4-出栈操作-Pop"><a href="#4-出栈操作-Pop" class="headerlink" title="4.出栈操作(Pop)"></a>4.出栈操作(Pop)</h4><ol>
<li>判断栈内是否有值</li>
<li>取值，修改索引</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//出栈操作(Pop)(获取栈顶元素并删除栈内的栈顶元素)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack&amp; S, ElementType&amp; data_x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty,can not pop!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//data_x = S.data[S.top];</span></span><br><span class="line">		<span class="comment">//S.top--;</span></span><br><span class="line">		data_x = S.data[S.top--]; <span class="comment">//优化后代码  其中[S.top--]表示S.data先调用索引为[S.top]的值后,再将索引自减1，然后取出栈顶元素值</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">}<span class="comment">//出栈本质为索引向前移动</span></span><br></pre></td></tr></table></figure></div>



<h4 id="5-读取栈顶元素-Peek"><a href="#5-读取栈顶元素-Peek" class="headerlink" title="5.读取栈顶元素(Peek)"></a>5.读取栈顶元素(Peek)</h4><ol>
<li>判断栈内是否有值</li>
<li>取值</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//读取栈顶元素(Peek)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Peek</span><span class="params">(SqStack&amp; S, ElementType&amp; data_x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty,can not get top!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		data_x = S.data[S.top];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}	</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="顺序栈总体代码"><a href="#顺序栈总体代码" class="headerlink" title="顺序栈总体代码"></a>顺序栈总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>顺序栈总体代码 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAdata_x_SIZE 8</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈(squencial stack)结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Stack</span></span><br><span class="line">{</span><br><span class="line">	ElementType data[MAdata_x_SIZE];</span><br><span class="line">	<span class="type">int</span> top; <span class="comment">//栈顶索引</span></span><br><span class="line">}SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack&amp; S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	S.top = <span class="number">-1</span>;<span class="comment">//栈顶索引初始化为-1,表示栈为空 同时意味着栈索引从0开始</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为满</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsStackFull</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == MAdata_x_SIZE - <span class="number">1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is full!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//入栈操作</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack&amp; S, ElementType data_x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">IsStackFull</span>(S))</span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//S.top++;</span></span><br><span class="line">		<span class="comment">//S.data[S.top] = data_x; //该代码可被优化</span></span><br><span class="line"></span><br><span class="line">		S.data[++S.top] = data_x; <span class="comment">//优化后代码  其中[++S.top]表示S.data索引自增1，然后将data_x值存入栈顶</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈操作(获取栈顶元素并删除栈内的栈顶元素)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack&amp; S, ElementType&amp; data_x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty,can not pop!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		<span class="comment">//data_x = S.data[S.top];</span></span><br><span class="line">		<span class="comment">//S.top--;</span></span><br><span class="line">		data_x = S.data[S.top--]; <span class="comment">//优化后代码  其中[S.top--]表示S.data先调用索引为[S.top]的值后,再将索引自减1，然后取出栈顶元素值</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}</span><br><span class="line">}<span class="comment">//出栈本质为索引向前移动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack&amp; S, ElementType&amp; data_x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty,can not get top!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	{</span><br><span class="line">		data_x = S.data[S.top];</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	}	</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintStack</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (S.top == <span class="number">-1</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty,nothing to print!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= S.top; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, S.data[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SqStack S;</span><br><span class="line">	<span class="built_in">InitStack</span>(S);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">5</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">6</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">7</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">8</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">9</span>);</span><br><span class="line">	<span class="built_in">Push</span>(S, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//测试栈</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; MAdata_x_SIZE; i++)</span><br><span class="line">	{</span><br><span class="line">		<span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="built_in">PrintStack</span>(S);</span><br><span class="line">		ElementType y;</span><br><span class="line">		<span class="built_in">GetTop</span>(S,y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Top element is %d\n"</span>, y);</span><br><span class="line">		<span class="built_in">Pop</span>(S, y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Pop element is %d\n"</span>, y);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"After pop, stack is:\n"</span>);</span><br><span class="line">		<span class="built_in">PrintStack</span>(S);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h3 id="链栈（Link-Stack"><a href="#链栈（Link-Stack" class="headerlink" title="链栈（Link Stack)"></a>链栈（Link Stack)</h3><p>由链表发展而来,使用零散内存空间</p>
<h4 id="1-链栈定义"><a href="#1-链栈定义" class="headerlink" title="1. 链栈定义"></a>1. 链栈定义</h4><p>完全继承链表定义形式</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkStack</span></span><br><span class="line">{</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkStack</span>* next;</span><br><span class="line">}*LS;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS L;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="2-链栈初始化"><a href="#2-链栈初始化" class="headerlink" title="2. 链栈初始化"></a>2. 链栈初始化</h4><p>由于链表仅能由头结点开始遍历的特性,考虑到后续操作,链栈最佳初始化方案为头插法</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">createStack</span><span class="params">(LS &amp;L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS p;</span><br><span class="line">	ElemType x = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//头结点</span></span><br><span class="line">	L = (LS)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkStack));</span><br><span class="line">	L-&gt;data = x;</span><br><span class="line">	L-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//后续第一个进入栈的节点将指向空,当栈为空时,next指向空</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="3-栈的状态"><a href="#3-栈的状态" class="headerlink" title="3.栈的状态"></a>3.栈的状态</h4><p>链栈没必要设置上限,除非是大数据流进入,否则零散利用内存的分配方式几乎不可能将内存占满</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LS L)</span><span class="comment">//当栈为空时,next指向空</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="4-入栈"><a href="#4-入栈" class="headerlink" title="4. 入栈"></a>4. 入栈</h4><p>算法与头插法创建链表相同</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(LS&amp; L, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS p;</span><br><span class="line">	p = (LS)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkStack));</span><br><span class="line">	p-&gt;data = x;</span><br><span class="line">	p-&gt;next = L-&gt;next;</span><br><span class="line">	L-&gt;next = p;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="5-出栈"><a href="#5-出栈" class="headerlink" title="5.出栈"></a>5.出栈</h4><p>调用并删除链表中第一个结点</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(LS&amp; L, ElemType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS p;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	p = L-&gt;next;</span><br><span class="line">	x = p-&gt;data;</span><br><span class="line">	L-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="6-获取栈顶数据"><a href="#6-获取栈顶数据" class="headerlink" title="6. 获取栈顶数据"></a>6. 获取栈顶数据</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getTop</span><span class="params">(LS L, ElemType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	x = L-&gt;next-&gt;data;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="链栈总体代码"><a href="#链栈总体代码" class="headerlink" title="链栈总体代码"></a>链栈总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>链栈总体代码 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElemType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkStack</span></span><br><span class="line">{</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkStack</span>* next;</span><br><span class="line">}*LS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">createStack</span><span class="params">(LS &amp;L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS p;</span><br><span class="line">	ElemType x = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//头结点</span></span><br><span class="line">	L = (LS)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkStack));</span><br><span class="line">	L-&gt;data = x;</span><br><span class="line">	L-&gt;next = <span class="literal">nullptr</span>;<span class="comment">//后续第一个进入栈的节点将指向空,当栈为空时,next指向空</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LS L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(LS&amp; L, ElemType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS p;</span><br><span class="line">	p = (LS)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkStack));</span><br><span class="line">	p-&gt;data = x;</span><br><span class="line">	p-&gt;next = L-&gt;next;</span><br><span class="line">	L-&gt;next = p;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(LS&amp; L, ElemType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS p;</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	p = L-&gt;next;</span><br><span class="line">	x = p-&gt;data;</span><br><span class="line">	L-&gt;next = p-&gt;next;</span><br><span class="line">	<span class="built_in">free</span>(p);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">getTop</span><span class="params">(LS L, ElemType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (L-&gt;next == <span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Stack is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	x = L-&gt;next-&gt;data;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStack</span><span class="params">(LS L)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">while</span> (L-&gt;next!= <span class="literal">nullptr</span>)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, L-&gt;next-&gt;data);</span><br><span class="line">		L = L-&gt;next;</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	LS L;</span><br><span class="line">	<span class="built_in">createStack</span>(L);</span><br><span class="line">	<span class="built_in">push</span>(L, <span class="number">1</span>);</span><br><span class="line">	<span class="built_in">push</span>(L, <span class="number">2</span>);</span><br><span class="line">	<span class="built_in">push</span>(L, <span class="number">3</span>);</span><br><span class="line">	<span class="built_in">push</span>(L, <span class="number">4</span>);</span><br><span class="line">	<span class="built_in">printStack</span>(L);</span><br><span class="line"></span><br><span class="line">	ElemType x;</span><br><span class="line">	<span class="built_in">pop</span>(L, x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"poped element is %d\n"</span>, x);</span><br><span class="line">	<span class="built_in">printStack</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">getTop</span>(L, x);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"top element is %d\n"</span>, x);</span><br><span class="line">	<span class="built_in">printStack</span>(L);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h2 id="队列（Queue）"><a href="#队列（Queue）" class="headerlink" title="队列（Queue）"></a>队列（Queue）</h2><p>队列是一种**先进先出（FIFO）**的数据结构。队列中元素只能从一端进入（队尾），从另一端移除（队头）。常用操作包括：</p>
<ul>
<li><strong>enqueue</strong>：将元素加入队尾。</li>
<li><strong>dequeue</strong>：将队头元素移除。</li>
<li><strong>peek</strong>：查看队头元素。</li>
</ul>
<p><strong>队列的应用</strong>：广泛用于任务调度、广度优先搜索、数据缓冲等场景。</p>
<h3 id="循环-顺序-队列-SquenceQueue"><a href="#循环-顺序-队列-SquenceQueue" class="headerlink" title="循环(顺序)队列(SquenceQueue)"></a>循环(顺序)队列(SquenceQueue)</h3><h4 id="1-创建队列"><a href="#1-创建队列" class="headerlink" title="1. 创建队列"></a>1. 创建队列</h4><p>循环队列又一个自定义的数组和队首与队尾两个逻辑指针构成</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">	ElementType data[MAX_SIZE];</span><br><span class="line">	<span class="type">int</span> front, rear;  </span><br><span class="line">} SquenceQueue;</span><br><span class="line"><span class="comment">//在循环队列中，data[SQ.rear]中的SQ.rear的值</span></span><br></pre></td></tr></table></figure></div>

<h4 id="2-队列初始化"><a href="#2-队列初始化" class="headerlink" title="2. 队列初始化"></a>2. 队列初始化</h4><p>规定队列首尾标相等时为空</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SquenceQueue&amp; SQ)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SQ.front = SQ.rear = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SquenceQueue SQ;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="3-入队"><a href="#3-入队" class="headerlink" title="3. 入队"></a>3. 入队</h4><p><strong>循环队列核心算法</strong> : </p>
<p><code>(SQ.rear + 1) % MAX_SIZE</code>算法实现了索引循环的功能,且<code>SQ.rear + 1</code>避免了在数组被占满时尾标与头标重合的情况,即组下标越界，使得队列满时队首和队尾重合，再插入元素时会覆盖队首元素</p>
<p>该算法规定队首和队尾相等时为空,<code>(SQ.rear + 1) % MAX_SIZE</code>的存在<code>SQ.rear</code>和<code>SQ.front</code>的取值范围为<code>[0,MAX_SIZE-1]</code>,构造体中的数组最后一位的被索引跳过,该存储单元值为0,且不会被调用</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SquenceQueue&amp; SQ,ElementType value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> ((SQ.rear + <span class="number">1</span>) % MAX_SIZE == SQ.front) <span class="comment">//队尾标加1并向队列长度取余，等于队头，表示队列已满   </span></span><br><span class="line">	{                                         </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is full!\n"</span>);           </span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;                         </span><br><span class="line">	}</span><br><span class="line">	SQ.data[SQ.rear] = value;</span><br><span class="line">	SQ.rear = (SQ.rear + <span class="number">1</span>) % MAX_SIZE; <span class="comment">//当队尾标移动到倒数第二个位置时表示队列已满，向队列长度取余，使队尾标归零</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="4-出队"><a href="#4-出队" class="headerlink" title="4. 出队"></a>4. 出队</h4><p>与入队原理相同</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SquenceQueue&amp; SQ, ElementType&amp; value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (SQ.front == SQ.rear) <span class="comment">//队列为空，队头和队尾重合</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	value = SQ.data[SQ.front];</span><br><span class="line">	SQ.front = (SQ.front + <span class="number">1</span>) % MAX_SIZE; <span class="comment">//队头向队列长度取余，使队头标归零</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="5-查看队首元素"><a href="#5-查看队首元素" class="headerlink" title="5. 查看队首元素"></a>5. 查看队首元素</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">peek</span><span class="params">(SquenceQueue SQ, ElementType&amp; value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (SQ.front == SQ.rear) <span class="comment">//队列为空，队头和队尾重合</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	value = SQ.data[SQ.front];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="循环队列总体代码"><a href="#循环队列总体代码" class="headerlink" title="循环队列总体代码"></a>循环队列总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>循环队列总体代码 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">{</span><br><span class="line">	ElementType data[MAX_SIZE];</span><br><span class="line">	<span class="type">int</span> front, rear;  </span><br><span class="line">} SquenceQueue;</span><br><span class="line"><span class="comment">//在循环队列中，data[SQ.rear]中的SQ.rear的值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SquenceQueue&amp; SQ)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SQ.front = SQ.rear = <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SquenceQueue&amp; SQ,ElementType value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> ((SQ.rear + <span class="number">1</span>) % MAX_SIZE == SQ.front) <span class="comment">//队尾标加1并向队列长度取余，等于队头，表示队列已满   </span></span><br><span class="line">	{                                         </span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is full!\n"</span>);           <span class="comment">//</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;                         </span><br><span class="line">	}</span><br><span class="line">	SQ.data[SQ.rear] = value;</span><br><span class="line">	SQ.rear = (SQ.rear + <span class="number">1</span>) % MAX_SIZE; <span class="comment">//当队尾标移动到倒数第二个位置时表示队列已满，向队列长度取余，使队尾标归零</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SquenceQueue&amp; SQ, ElementType&amp; value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (SQ.front == SQ.rear) <span class="comment">//队列为空，队头和队尾重合</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	value = SQ.data[SQ.front];</span><br><span class="line">	SQ.front = (SQ.front + <span class="number">1</span>) % MAX_SIZE; <span class="comment">//队头向队列长度取余，使队头标归零</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintQueue</span><span class="params">(SquenceQueue SQ)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (SQ.front == SQ.rear) <span class="comment">//队列为空，队头和队尾重合</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	}</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = SQ.front; i != SQ.rear; i = (i + <span class="number">1</span>) % MAX_SIZE)</span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%d "</span>, SQ.data[i]);</span><br><span class="line">	}</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">peek</span><span class="params">(SquenceQueue SQ, ElementType&amp; value)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	<span class="keyword">if</span> (SQ.front == SQ.rear) <span class="comment">//队列为空，队头和队尾重合</span></span><br><span class="line">	{</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Queue is empty!\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	}</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	value = SQ.data[SQ.front];</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main_SQ</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">	SquenceQueue SQ;</span><br><span class="line">	<span class="built_in">InitQueue</span>(SQ);</span><br><span class="line">	<span class="built_in">EnQueue</span>(SQ, <span class="number">11</span>);</span><br><span class="line">	<span class="built_in">EnQueue</span>(SQ, <span class="number">22</span>);</span><br><span class="line">	<span class="built_in">EnQueue</span>(SQ, <span class="number">33</span>);	</span><br><span class="line">	<span class="built_in">EnQueue</span>(SQ, <span class="number">44</span>);</span><br><span class="line">	<span class="built_in">EnQueue</span>(SQ, <span class="number">55</span>);</span><br><span class="line">	<span class="built_in">PrintQueue</span>(SQ);</span><br><span class="line"></span><br><span class="line">	ElementType testvalue;</span><br><span class="line">	<span class="built_in">DeQueue</span>(SQ, testvalue);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"DeQueue value is %d\n"</span>, testvalue);</span><br><span class="line">	<span class="built_in">PrintQueue</span>(SQ);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">DeQueue</span>(SQ, testvalue);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"DeQueue value is %d\n"</span>, testvalue);</span><br><span class="line">	<span class="built_in">PrintQueue</span>(SQ);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">EnQueue</span>(SQ, <span class="number">66</span>);</span><br><span class="line">	<span class="built_in">PrintQueue</span>(SQ);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h3 id="链队列-LinkQueue"><a href="#链队列-LinkQueue" class="headerlink" title="链队列(LinkQueue)"></a>链队列(LinkQueue)</h3><p>链队列由一个单链表和分别指代首尾的两个指针构成,用两个构造体分别构造单链表和首尾指针组</p>
<h4 id="1-构建链队列"><a href="#1-构建链队列" class="headerlink" title="1. 构建链队列"></a>1. 构建链队列</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueueNode</span></span><br><span class="line">{</span><br><span class="line">    ElementType data;</span><br><span class="line">    LinkQueueNode *next;</span><br><span class="line">} LQN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueuePointers</span></span><br><span class="line">{</span><br><span class="line">    LQN *front;</span><br><span class="line">    LQN *rear;</span><br><span class="line">} LQP;</span><br></pre></td></tr></table></figure></div>

<h4 id="1-初始化链队列"><a href="#1-初始化链队列" class="headerlink" title="1. 初始化链队列"></a>1. 初始化链队列</h4><p>由于构造体<code>LinkQueuePointers</code>包含了用于指向<code>LinkQueueNode</code>的指针,因此只需创<code>LinkQueuePointers</code>的实例即可通过内置的指针来向内存申请空间</p>
<p>注意 : <code>(LQN*)malloc(sizeof(struct LinkQueuePointers));</code>这行代码的含义是向内存空间申请一个大小为两个指针空间,且这连个指针式用于指向构造体<code>LinkQueuePointers</code>的</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LQP &amp;P)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    P.front = P.rear = (LQN*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueuePointers));</span><br><span class="line">    P.front-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQP P;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="1-入队"><a href="#1-入队" class="headerlink" title="1. 入队"></a>1. 入队</h4><p>单链表尾插法入队,链表在内存空间足够大的情况下无需考虑长度上限问题</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LQP&amp; P, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQN *newp = (LQN*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueuePointers));   </span><br><span class="line">    newp-&gt;data = x;</span><br><span class="line">    P.rear-&gt;next = newp;<span class="comment">//尾指针的next指向新节点</span></span><br><span class="line">    P.rear = newp; <span class="comment">//尾指针向后移动</span></span><br><span class="line">    newp-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//此时尾节点更新,需设置为节点next为空</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="1-出队"><a href="#1-出队" class="headerlink" title="1. 出队"></a>1. 出队</h4><ol>
<li>判断队列是否为空</li>
<li>拿到第一个结点的数据并断链和释放内存</li>
<li>考虑当取出最后一个结点元素时,尾指针与头指针复位的问题</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LQP&amp; P, ElementType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (P.front == P.rear) <span class="comment">//判断队列是否为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Queue is Empty,nothing can DeQueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LQN* dep = P.front-&gt;next; <span class="comment">//获取队首地址</span></span><br><span class="line">    x = dep-&gt;data; <span class="comment">//获取队首数据</span></span><br><span class="line">    P.front-&gt;next = dep-&gt;next; <span class="comment">//队首指针指向取出元素的节点的后面的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (P.rear == dep) <span class="comment">//当取出的元素是最后一个元素时,使rear指针指向front指针,即队列为空</span></span><br><span class="line">    {</span><br><span class="line">        P.rear = P.front;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(dep);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<h4 id="1-查看队首元素"><a href="#1-查看队首元素" class="headerlink" title="1. 查看队首元素"></a>1. 查看队首元素</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PeekQueue</span><span class="params">(LQP P, ElementType &amp;x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (P.front == P.rear) <span class="comment">//判断队列是否为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Queue is Empty,nothing can DeQueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LQN* peekp = P.front-&gt;next; <span class="comment">//获取队首地址</span></span><br><span class="line">    x = peekp-&gt;data; <span class="comment">//获取队首数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>


<h4 id="链式队列总体代码"><a href="#链式队列总体代码" class="headerlink" title="链式队列总体代码"></a>链式队列总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>链式队列总体代码 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ElementType int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueueNode</span></span><br><span class="line">{</span><br><span class="line">    ElementType data;</span><br><span class="line">    LinkQueueNode *next;</span><br><span class="line">} LQN;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueuePointers</span></span><br><span class="line">{</span><br><span class="line">    LQN *front;</span><br><span class="line">    LQN *rear;</span><br><span class="line">} LQP;</span><br><span class="line"></span><br><span class="line"><span class="comment">//采用尾插法建立链队列,规 定链尾为rear指针,链头为front指针</span></span><br><span class="line"><span class="comment">//入队时,将新结点p插入rear指针后面,然后将rear指针指向新结点p</span></span><br><span class="line"><span class="comment">//出队时,将front指针指向front指针后面的结点,并返回其数据</span></span><br><span class="line"><span class="comment">//判空时,若front指针为空,则队列为空,否则不为空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LQP &amp;P)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    P.front = P.rear = (LQN*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueuePointers));</span><br><span class="line">    P.front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LQP&amp; P, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQN *newp = (LQN*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueuePointers));   </span><br><span class="line">    newp-&gt;data = x;</span><br><span class="line">    P.rear-&gt;next = newp;<span class="comment">//尾指针的next指向新节点</span></span><br><span class="line">    P.rear = newp; <span class="comment">//尾指针向后移动</span></span><br><span class="line">    newp-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//此时尾节点更新,需设置为节点next为空</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LQP&amp; P, ElementType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (P.front == P.rear) <span class="comment">//判断队列是否为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Queue is Empty,nothing can DeQueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LQN* dep = P.front-&gt;next; <span class="comment">//获取队首地址</span></span><br><span class="line">    x = dep-&gt;data; <span class="comment">//获取队首数据</span></span><br><span class="line">    P.front-&gt;next = dep-&gt;next; <span class="comment">//队首指针指向取出元素的节点的后面的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (P.rear == dep) <span class="comment">//当取出的元素是最后一个元素时,使rear指针指向front指针,即队列为空</span></span><br><span class="line">    {</span><br><span class="line">        P.rear = P.front;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(dep);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PeekQueue</span><span class="params">(LQP P, ElementType &amp;x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (P.front == P.rear) <span class="comment">//判断队列是否为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Queue is Empty,nothing can DeQueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LQN* peekp = P.front-&gt;next; <span class="comment">//获取队首地址</span></span><br><span class="line">    x = peekp-&gt;data; <span class="comment">//获取队首数据</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintQueue</span><span class="params">(LQP P)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQN* p = P.front-&gt;next;</span><br><span class="line">    <span class="keyword">while</span> (p!= <span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, p-&gt;data);</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);   </span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQP P;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">InitQueue</span>(P);</span><br><span class="line">    <span class="built_in">EnQueue</span>(P, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">EnQueue</span>(P, <span class="number">2</span>);</span><br><span class="line">    <span class="built_in">EnQueue</span>(P, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">EnQueue</span>(P, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">EnQueue</span>(P, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PrintQueue</span>(P);</span><br><span class="line"></span><br><span class="line">    ElementType x = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">DeQueue</span>(P, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dequeue is %d\n"</span>, x);</span><br><span class="line">    <span class="built_in">PrintQueue</span>(P);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">DeQueue</span>(P, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"dequeue is %d\n"</span>, x);</span><br><span class="line">    <span class="built_in">PrintQueue</span>(P);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">EnQueue</span>(P, <span class="number">6</span>);</span><br><span class="line">    <span class="built_in">PrintQueue</span>(P);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">PeekQueue</span>(P, x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"front of queue is %d\n"</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="二叉树-BinaryTree"><a href="#二叉树-BinaryTree" class="headerlink" title="二叉树(BinaryTree)"></a>二叉树(BinaryTree)</h3><p><strong>二叉树</strong>是一种树形数据结构，其中每个节点最多有两个子节点，称为左子节点和右子节点。二叉树具有层次关系，广泛用于数据组织和处理。</p>
<h4 id="定义二叉树"><a href="#定义二叉树" class="headerlink" title="定义二叉树"></a>定义二叉树</h4><p>二叉树主体由两个指针和一个数据组成,但构建二叉树还需要队列的辅助,采用链式队列为优</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BT_ElemType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTreeNode</span></span><br><span class="line">{</span><br><span class="line">    BT_ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTreeNode</span> *lchild, *rchild;</span><br><span class="line">} BiTreeNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTreeTagList</span> <span class="comment">//指针构造体,用于辅助构建二叉树</span></span><br><span class="line">{</span><br><span class="line">    BiTree p; <span class="comment">//指向二叉树节点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTreeTagList</span> *p_next; <span class="comment">//指向按顺序进入二叉树的下一个节点的指针(指针的指针)</span></span><br><span class="line">    <span class="comment">//用于在双亲结点构建完成后对孩子结点进行孙子结点的构建</span></span><br><span class="line">}*BiTreeTag;</span><br></pre></td></tr></table></figure></div>


<h4 id="层次创建二叉树"><a href="#层次创建二叉树" class="headerlink" title="层次创建二叉树"></a>层次创建二叉树</h4><p>依照输入字符的顺序依次从上到下从左到右插入二叉树中</p>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BiTreeCreate_by_InputChar</span><span class="params">(BiTree &amp;root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    root = <span class="literal">NULL</span>; <span class="comment">//指向树的根节点</span></span><br><span class="line">    BiTree pnew; <span class="comment">//指向新创建的树节点,用于构建二叉树</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    BiTreeTag phead = <span class="literal">NULL</span>, ptail = <span class="literal">NULL</span>; <span class="comment">//分别指向辅助构建二叉树的指针链表的头和尾</span></span><br><span class="line">    BiTreeTag listpnew = <span class="literal">NULL</span>; <span class="comment">//指向辅助构建二叉树的指针链表中新创建的节点(链表的新元素),用于构建二叉树的辅助指针链表</span></span><br><span class="line">    BiTreeTag pcur = <span class="literal">NULL</span>; <span class="comment">//指向正在处理的辅助构建二叉树的指针链表的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf_s</span>(<span class="string">"%c"</span>, &amp;c))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//换行符,表示输入结束</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pnew = (BiTree)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(BiTreeNode));</span><br><span class="line">        <span class="comment">//calloc分配内存,语法为:void *calloc(size_t num, size_t size);</span></span><br><span class="line">        <span class="comment">//calloc分配的内存空间,其大小为num*size字节,并初始化为0,即新建的节点的左右孩子指针都为NULL</span></span><br><span class="line"></span><br><span class="line">        pnew-&gt;data = c; <span class="comment">//为新创建的节点赋值</span></span><br><span class="line"></span><br><span class="line">        listpnew = (BiTreeTag)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(BiTreeTag));</span><br><span class="line">        <span class="comment">//在第一次输入值时作为辅助链表的头指针</span></span><br><span class="line">        <span class="comment">//在第二次输入值以后该指针是用于给辅助链表中的指针传值用的中间量</span></span><br><span class="line"></span><br><span class="line">        listpnew-&gt;p = pnew; <span class="comment">//为新创建的节点指针赋值,此时辅助指针链表得到了目前正在进行树节点构建的节点的指针值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">        {</span><br><span class="line">            root = pnew; <span class="comment">//如果树还没有根节点,则为根节点赋值</span></span><br><span class="line">            phead = listpnew; <span class="comment">//为辅助指针链表的头指针赋值</span></span><br><span class="line">            ptail = listpnew; <span class="comment">//为辅助指针链表的尾指针也赋值</span></span><br><span class="line">            pcur = listpnew; <span class="comment">//pcur指向当前正在处理的辅助指针链表的元素</span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            ptail-&gt;p_next = listpnew; <span class="comment">//如果树已经有根节点,则将新创建的节点指针插入到辅助指针链表的尾部</span></span><br><span class="line">            ptail = listpnew; <span class="comment">//尾指针后移</span></span><br><span class="line">            <span class="keyword">if</span> (pcur-&gt;p-&gt;lchild == <span class="literal">NULL</span>) <span class="comment">//pcur-&gt;p代表正在被加入孩子节点的节点的指针,即pnew</span></span><br><span class="line">            {</span><br><span class="line">                pcur-&gt;p-&gt;lchild = pnew; <span class="comment">//为pcur-&gt;p的左孩子指针赋值</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pcur-&gt;p-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                pcur-&gt;p-&gt;rchild = pnew; <span class="comment">//为pcur-&gt;p的右孩子指针赋值</span></span><br><span class="line">                <span class="comment">//此时pcur-&gt;p已经完成了左右孩子的构建,pcur指向下一个待处理的辅助指针链表的元素</span></span><br><span class="line">                pcur = pcur-&gt;p_next; <span class="comment">//pcur指向下一个待处理的辅助指针链表的元素</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>





<h4 id="先序遍历-深度优先遍历"><a href="#先序遍历-深度优先遍历" class="headerlink" title="先序遍历(深度优先遍历)"></a>先序遍历(深度优先遍历)</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;data); <span class="comment">//先序遍历,根节点-&gt;左子树-&gt;右子树</span></span><br><span class="line">    <span class="built_in">PreOrder</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">PreOrder</span>(root-&gt;rchild);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;   </span><br><span class="line">    <span class="built_in">InOrder</span>(root-&gt;lchild); <span class="comment">//左子树-&gt;根节点-&gt;右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;data);</span><br><span class="line">    <span class="built_in">InOrder</span>(root-&gt;rchild);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">PostOrder</span>(root-&gt;lchild); <span class="comment">//左子树-&gt;右子树-&gt;根节点</span></span><br><span class="line">    <span class="built_in">PostOrder</span>(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;data);</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>



<h4 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h4><p>需要辅助队列进行打印操作,这里使用的头文件来引用ListQueue的数据结构和方法</p>
<ol>
<li>节点入队</li>
<li>打印并出队</li>
<li>判断出队的节点左右孩子是否为空,不为空则使其左右孩子入队,为空则继续</li>
<li>返回 1</li>
</ol>
<div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//层序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQP Q; <span class="comment">//队列</span></span><br><span class="line">    BiTree p; <span class="comment">//指向当前节点</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,root);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(Q))<span class="comment">// !bool等于对bool值取反</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p); <span class="comment">//出队 p承接当前出队的节点</span></span><br><span class="line">        <span class="built_in">putchar</span>(p-&gt;data); <span class="comment">//打印当前节点 putchar(p-&gt;data) = printf("%c", p-&gt;data)</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;lchild); <span class="comment">//左孩子入队</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;rchild); <span class="comment">//右孩子入队</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>

<details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>头文件和队列方法 </summary>
              <div class="content">
              <p>头文件</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BT_ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTreeNode</span></span><br><span class="line">{</span><br><span class="line">    BT_ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTreeNode</span>* lchild, * rchild;</span><br><span class="line">} BiTreeNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTreeTagList</span> <span class="comment">//指针构造体,用于辅助构建二叉树</span></span><br><span class="line">{</span><br><span class="line">    BiTree p; <span class="comment">//指向二叉树节点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTreeTagList</span>* p_next; <span class="comment">//指向按顺序进入二叉树的下一个节点的指针(指针的指针)</span></span><br><span class="line">    <span class="comment">//用于在双亲结点构建完成后对孩子结点进行孙子结点的构建</span></span><br><span class="line">}*BiTreeTag;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> BiTree ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueueNode</span></span><br><span class="line">{</span><br><span class="line">    ElementType data;</span><br><span class="line">    LinkQueueNode* next;</span><br><span class="line">} LQN;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkQueuePointers</span></span><br><span class="line">{</span><br><span class="line">    LQN* front;</span><br><span class="line">    LQN* rear;</span><br><span class="line">} LQP;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int fuc_print(int f);  // 函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LQP&amp; P)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LQP&amp; P, ElementType x)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LQP P)</span></span>;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LQP&amp; P, ElementType&amp; x)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div><p>队列方法</p><div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LQP &amp;P)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    P.front = P.rear = (LQN*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueuePointers));</span><br><span class="line">    P.front-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LQP&amp; P, ElementType x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQN *newp = (LQN*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(<span class="keyword">struct</span> LinkQueuePointers));   </span><br><span class="line">    newp-&gt;data = x;</span><br><span class="line">    P.rear-&gt;next = newp;<span class="comment">//尾指针的next指向新节点</span></span><br><span class="line">    P.rear = newp; <span class="comment">//尾指针向后移动</span></span><br><span class="line">    newp-&gt;next = <span class="literal">nullptr</span>; <span class="comment">//此时尾节点更新,需设置为节点next为空</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LQP P)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> P.front == P.rear; <span class="comment">// 队列为空返回 true，否则返回 false</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LQP&amp; P, ElementType&amp; x)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (P.front == P.rear) <span class="comment">//判断队列是否为空</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Queue is Empty,nothing can DeQueue"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    LQN* dep = P.front-&gt;next; <span class="comment">//获取队首地址</span></span><br><span class="line">    x = dep-&gt;data; <span class="comment">//获取队首数据</span></span><br><span class="line">    P.front-&gt;next = dep-&gt;next; <span class="comment">//队首指针指向取出元素的节点的后面的节点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (P.rear == dep) <span class="comment">//当取出的元素是最后一个元素时,使rear指针指向front指针,即队列为空</span></span><br><span class="line">    {</span><br><span class="line">        P.rear = P.front;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">free</span>(dep);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure></div>
              </div>
            </details>


<h4 id="二叉树创建与遍历总体代码"><a href="#二叉树创建与遍历总体代码" class="headerlink" title="二叉树创建与遍历总体代码"></a>二叉树创建与遍历总体代码</h4><details class="blue" data-header-exclude=""><summary><i class="fa-solid fa-chevron-right"></i>二叉树创建与遍历总体代码 </summary>
              <div class="content">
              <div class="code-container" data-rel="Cpp"><figure class="iseeu highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"C_L_Header.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> BT_ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTreeNode</span></span><br><span class="line">{</span><br><span class="line">    BT_ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTreeNode</span>* lchild, * rchild;</span><br><span class="line">} BiTreeNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTreeTagList</span> <span class="comment">//指针构造体,用于辅助构建二叉树</span></span><br><span class="line">{</span><br><span class="line">    BiTree p; <span class="comment">//指向二叉树节点的指针</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTreeTagList</span>* p_next; <span class="comment">//指向按顺序进入二叉树的下一个节点的指针(指针的指针)</span></span><br><span class="line">    <span class="comment">//用于在双亲结点构建完成后对孩子结点进行孙子结点的构建</span></span><br><span class="line">}*BiTreeTag;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BiTreeCreate_by_InputChar</span><span class="params">(BiTree &amp;root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    root = <span class="literal">NULL</span>; <span class="comment">//指向树的根节点</span></span><br><span class="line">    BiTree pnew; <span class="comment">//指向新创建的树节点,用于构建二叉树</span></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    BiTreeTag phead = <span class="literal">NULL</span>, ptail = <span class="literal">NULL</span>; <span class="comment">//分别指向辅助构建二叉树的指针链表的头和尾</span></span><br><span class="line">    BiTreeTag listpnew = <span class="literal">NULL</span>; <span class="comment">//指向辅助构建二叉树的指针链表中新创建的节点(链表的新元素),用于构建二叉树的辅助指针链表</span></span><br><span class="line">    BiTreeTag pcur = <span class="literal">NULL</span>; <span class="comment">//指向正在处理的辅助构建二叉树的指针链表的元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf_s</span>(<span class="string">"%c"</span>, &amp;c))</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\n'</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">//换行符,表示输入结束</span></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        pnew = (BiTree)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(BiTreeNode));</span><br><span class="line">        <span class="comment">//calloc分配内存,语法为:void *calloc(size_t num, size_t size);</span></span><br><span class="line">        <span class="comment">//calloc分配的内存空间,其大小为num*size字节,并初始化为0,即新建的节点的左右孩子指针都为NULL</span></span><br><span class="line"></span><br><span class="line">        pnew-&gt;data = c; <span class="comment">//为新创建的节点赋值</span></span><br><span class="line"></span><br><span class="line">        listpnew = (BiTreeTag)<span class="built_in">calloc</span>(<span class="number">1</span>, <span class="built_in">sizeof</span>(BiTreeTag));</span><br><span class="line">        <span class="comment">//在第一次输入值时作为辅助链表的头指针</span></span><br><span class="line">        <span class="comment">//在第二次输入值以后该指针是用于给辅助链表中的指针传值用的中间量</span></span><br><span class="line"></span><br><span class="line">        listpnew-&gt;p = pnew; <span class="comment">//为新创建的节点指针赋值,此时辅助指针链表得到了目前正在进行树节点构建的节点的指针值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">        {</span><br><span class="line">            root = pnew; <span class="comment">//如果树还没有根节点,则为根节点赋值</span></span><br><span class="line">            phead = listpnew; <span class="comment">//为辅助指针链表的头指针赋值</span></span><br><span class="line">            ptail = listpnew; <span class="comment">//为辅助指针链表的尾指针也赋值</span></span><br><span class="line">            pcur = listpnew; <span class="comment">//pcur指向当前正在处理的辅助指针链表的元素</span></span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            ptail-&gt;p_next = listpnew; <span class="comment">//如果树已经有根节点,则将新创建的节点指针插入到辅助指针链表的尾部</span></span><br><span class="line">            ptail = listpnew; <span class="comment">//尾指针后移</span></span><br><span class="line">            <span class="keyword">if</span> (pcur-&gt;p-&gt;lchild == <span class="literal">NULL</span>) <span class="comment">//pcur-&gt;p代表正在被加入孩子节点的节点的指针,即pnew</span></span><br><span class="line">            {</span><br><span class="line">                pcur-&gt;p-&gt;lchild = pnew; <span class="comment">//为pcur-&gt;p的左孩子指针赋值</span></span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pcur-&gt;p-&gt;rchild == <span class="literal">NULL</span>)</span><br><span class="line">            {</span><br><span class="line">                pcur-&gt;p-&gt;rchild = pnew; <span class="comment">//为pcur-&gt;p的右孩子指针赋值</span></span><br><span class="line">                <span class="comment">//此时pcur-&gt;p已经完成了左右孩子的构建,pcur指向下一个待处理的辅助指针链表的元素</span></span><br><span class="line">                pcur = pcur-&gt;p_next; <span class="comment">//pcur指向下一个待处理的辅助指针链表的元素</span></span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;data); <span class="comment">//先序遍历,根节点-&gt;左子树-&gt;右子树</span></span><br><span class="line">    <span class="built_in">PreOrder</span>(root-&gt;lchild);</span><br><span class="line">    <span class="built_in">PreOrder</span>(root-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;   </span><br><span class="line">    <span class="built_in">InOrder</span>(root-&gt;lchild); <span class="comment">//左子树-&gt;根节点-&gt;右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;data);</span><br><span class="line">    <span class="built_in">InOrder</span>(root-&gt;rchild);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">PostOrder</span>(root-&gt;lchild); <span class="comment">//左子树-&gt;右子树-&gt;根节点</span></span><br><span class="line">    <span class="built_in">PostOrder</span>(root-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, root-&gt;data);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印树状二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintTree</span><span class="params">(BiTree root, <span class="type">const</span> <span class="type">char</span>* prefix, <span class="type">int</span> isLeft)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印当前节点，显示前缀与分支符号</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, prefix);</span><br><span class="line">    <span class="built_in">printf</span>(isLeft ? <span class="string">"├── "</span> : <span class="string">"└── "</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c\n"</span>, root-&gt;data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新的前缀</span></span><br><span class="line">    <span class="type">char</span> newPrefix[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">snprintf</span>(newPrefix, <span class="built_in">sizeof</span>(newPrefix), <span class="string">"%s%s"</span>, prefix, isLeft ? <span class="string">"│   "</span> : <span class="string">"    "</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归打印左右子树</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild || root-&gt;rchild) {</span><br><span class="line">        <span class="built_in">PrintTree</span>(root-&gt;rchild, newPrefix, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">PrintTree</span>(root-&gt;lchild, newPrefix, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//层序遍历二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree root)</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LQP Q; <span class="comment">//队列</span></span><br><span class="line">    BiTree p; <span class="comment">//指向当前节点</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="built_in">EnQueue</span>(Q,root);</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">IsEmpty</span>(Q))<span class="comment">// !bool等于对bool值取反</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">DeQueue</span>(Q, p); <span class="comment">//出队 p承接当前出队的节点</span></span><br><span class="line">        <span class="built_in">putchar</span>(p-&gt;data); <span class="comment">//打印当前节点 putchar(p-&gt;data) = printf("%c", p-&gt;data)</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;lchild); <span class="comment">//左孩子入队</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>)</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">EnQueue</span>(Q, p-&gt;rchild); <span class="comment">//右孩子入队</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>{</span><br><span class="line">    BiTree Btree01;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入二叉树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入二叉树节点序列（以换行结束）：\n"</span>);</span><br><span class="line">    <span class="built_in">BiTreeCreate_by_InputChar</span>(Btree01);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"先序遍历结果:\n"</span>);</span><br><span class="line">    <span class="built_in">PreOrder</span>(Btree01);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"中序遍历结果:\n"</span>);</span><br><span class="line">    <span class="built_in">InOrder</span>(Btree01);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"后序遍历结果:\n"</span>);</span><br><span class="line">    <span class="built_in">PostOrder</span>(Btree01);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层序遍历</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"层序遍历结果:\n"</span>);</span><br><span class="line">    <span class="built_in">LevelOrder</span>(Btree01);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印树状结构</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"树状打印结果:\n"</span>);</span><br><span class="line">    <span class="built_in">PrintTree</span>(Btree01, <span class="string">""</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
              </div>
            </details>

<hr>
<h3 id="哈夫曼树-Huffman-Tree"><a href="#哈夫曼树-Huffman-Tree" class="headerlink" title="哈夫曼树(Huffman Tree)"></a>哈夫曼树(Huffman Tree)</h3><p>以后再来写</p>
<h4 id="哈夫曼编码"><a href="#哈夫曼编码" class="headerlink" title="哈夫曼编码"></a>哈夫曼编码</h4>]]></content>
      <categories>
        <category>Data_structures</category>
      </categories>
      <tags>
        <tag>Data_s</tag>
      </tags>
  </entry>
</search>
